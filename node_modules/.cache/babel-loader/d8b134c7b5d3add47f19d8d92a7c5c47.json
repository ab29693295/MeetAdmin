{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst crypto = require(\"crypto\");\n\nconst SortableSet = require(\"../util/SortableSet\");\n\nconst GraphHelpers = require(\"../GraphHelpers\");\n\nconst {\n  isSubset\n} = require(\"../util/SetHelpers\");\n\nconst deterministicGrouping = require(\"../util/deterministicGrouping\");\n\nconst MinMaxSizeWarning = require(\"./MinMaxSizeWarning\");\n\nconst contextify = require(\"../util/identifier\").contextify;\n/** @typedef {import(\"../Compiler\")} Compiler */\n\n/** @typedef {import(\"../Chunk\")} Chunk */\n\n/** @typedef {import(\"../Module\")} Module */\n\n/** @typedef {import(\"../util/deterministicGrouping\").Options<Module>} DeterministicGroupingOptionsForModule */\n\n/** @typedef {import(\"../util/deterministicGrouping\").GroupedItems<Module>} DeterministicGroupingGroupedItemsForModule */\n\n\nconst deterministicGroupingForModules =\n/** @type {function(DeterministicGroupingOptionsForModule): DeterministicGroupingGroupedItemsForModule[]} */\ndeterministicGrouping;\n\nconst hashFilename = name => {\n  return crypto.createHash(\"md4\").update(name).digest(\"hex\").slice(0, 8);\n};\n\nconst sortByIdentifier = (a, b) => {\n  if (a.identifier() > b.identifier()) return 1;\n  if (a.identifier() < b.identifier()) return -1;\n  return 0;\n};\n\nconst getRequests = chunk => {\n  let requests = 0;\n\n  for (const chunkGroup of chunk.groupsIterable) {\n    requests = Math.max(requests, chunkGroup.chunks.length);\n  }\n\n  return requests;\n};\n\nconst getModulesSize = modules => {\n  let sum = 0;\n\n  for (const m of modules) {\n    sum += m.size();\n  }\n\n  return sum;\n};\n/**\n * @template T\n * @param {Set<T>} a set\n * @param {Set<T>} b other set\n * @returns {boolean} true if at least one item of a is in b\n */\n\n\nconst isOverlap = (a, b) => {\n  for (const item of a) {\n    if (b.has(item)) return true;\n  }\n\n  return false;\n};\n\nconst compareEntries = (a, b) => {\n  // 1. by priority\n  const diffPriority = a.cacheGroup.priority - b.cacheGroup.priority;\n  if (diffPriority) return diffPriority; // 2. by number of chunks\n\n  const diffCount = a.chunks.size - b.chunks.size;\n  if (diffCount) return diffCount; // 3. by size reduction\n\n  const aSizeReduce = a.size * (a.chunks.size - 1);\n  const bSizeReduce = b.size * (b.chunks.size - 1);\n  const diffSizeReduce = aSizeReduce - bSizeReduce;\n  if (diffSizeReduce) return diffSizeReduce; // 4. by number of modules (to be able to compare by identifier)\n\n  const modulesA = a.modules;\n  const modulesB = b.modules;\n  const diff = modulesA.size - modulesB.size;\n  if (diff) return diff; // 5. by module identifiers\n\n  modulesA.sort();\n  modulesB.sort();\n  const aI = modulesA[Symbol.iterator]();\n  const bI = modulesB[Symbol.iterator](); // eslint-disable-next-line no-constant-condition\n\n  while (true) {\n    const aItem = aI.next();\n    const bItem = bI.next();\n    if (aItem.done) return 0;\n    const aModuleIdentifier = aItem.value.identifier();\n    const bModuleIdentifier = bItem.value.identifier();\n    if (aModuleIdentifier > bModuleIdentifier) return -1;\n    if (aModuleIdentifier < bModuleIdentifier) return 1;\n  }\n};\n\nconst compareNumbers = (a, b) => a - b;\n\nconst INITIAL_CHUNK_FILTER = chunk => chunk.canBeInitial();\n\nconst ASYNC_CHUNK_FILTER = chunk => !chunk.canBeInitial();\n\nconst ALL_CHUNK_FILTER = chunk => true;\n\nmodule.exports = class SplitChunksPlugin {\n  constructor(options) {\n    this.options = SplitChunksPlugin.normalizeOptions(options);\n  }\n\n  static normalizeOptions(options = {}) {\n    return {\n      chunksFilter: SplitChunksPlugin.normalizeChunksFilter(options.chunks || \"all\"),\n      minSize: options.minSize || 0,\n      maxSize: options.maxSize || 0,\n      minChunks: options.minChunks || 1,\n      maxAsyncRequests: options.maxAsyncRequests || 1,\n      maxInitialRequests: options.maxInitialRequests || 1,\n      hidePathInfo: options.hidePathInfo || false,\n      filename: options.filename || undefined,\n      getCacheGroups: SplitChunksPlugin.normalizeCacheGroups({\n        cacheGroups: options.cacheGroups,\n        name: options.name,\n        automaticNameDelimiter: options.automaticNameDelimiter,\n        automaticNameMaxLength: options.automaticNameMaxLength\n      }),\n      automaticNameDelimiter: options.automaticNameDelimiter,\n      automaticNameMaxLength: options.automaticNameMaxLength || 109,\n      fallbackCacheGroup: SplitChunksPlugin.normalizeFallbackCacheGroup(options.fallbackCacheGroup || {}, options)\n    };\n  }\n\n  static normalizeName({\n    name,\n    automaticNameDelimiter,\n    automaticNamePrefix,\n    automaticNameMaxLength\n  }) {\n    if (name === true) {\n      /** @type {WeakMap<Chunk[], Record<string, string>>} */\n      const cache = new WeakMap();\n\n      const fn = (module, chunks, cacheGroup) => {\n        let cacheEntry = cache.get(chunks);\n\n        if (cacheEntry === undefined) {\n          cacheEntry = {};\n          cache.set(chunks, cacheEntry);\n        } else if (cacheGroup in cacheEntry) {\n          return cacheEntry[cacheGroup];\n        }\n\n        const names = chunks.map(c => c.name);\n\n        if (!names.every(Boolean)) {\n          cacheEntry[cacheGroup] = undefined;\n          return;\n        }\n\n        names.sort();\n        const prefix = typeof automaticNamePrefix === \"string\" ? automaticNamePrefix : cacheGroup;\n        const namePrefix = prefix ? prefix + automaticNameDelimiter : \"\";\n        let name = namePrefix + names.join(automaticNameDelimiter); // Filenames and paths can't be too long otherwise an\n        // ENAMETOOLONG error is raised. If the generated name if too\n        // long, it is truncated and a hash is appended. The limit has\n        // been set to 109 to prevent `[name].[chunkhash].[ext]` from\n        // generating a 256+ character string.\n\n        if (name.length > automaticNameMaxLength) {\n          const hashedFilename = hashFilename(name);\n          const sliceLength = automaticNameMaxLength - (automaticNameDelimiter.length + hashedFilename.length);\n          name = name.slice(0, sliceLength) + automaticNameDelimiter + hashedFilename;\n        }\n\n        cacheEntry[cacheGroup] = name;\n        return name;\n      };\n\n      return fn;\n    }\n\n    if (typeof name === \"string\") {\n      const fn = () => {\n        return name;\n      };\n\n      return fn;\n    }\n\n    if (typeof name === \"function\") return name;\n  }\n\n  static normalizeChunksFilter(chunks) {\n    if (chunks === \"initial\") {\n      return INITIAL_CHUNK_FILTER;\n    }\n\n    if (chunks === \"async\") {\n      return ASYNC_CHUNK_FILTER;\n    }\n\n    if (chunks === \"all\") {\n      return ALL_CHUNK_FILTER;\n    }\n\n    if (typeof chunks === \"function\") return chunks;\n  }\n\n  static normalizeFallbackCacheGroup({\n    minSize = undefined,\n    maxSize = undefined,\n    automaticNameDelimiter = undefined\n  }, {\n    minSize: defaultMinSize = undefined,\n    maxSize: defaultMaxSize = undefined,\n    automaticNameDelimiter: defaultAutomaticNameDelimiter = undefined\n  }) {\n    return {\n      minSize: typeof minSize === \"number\" ? minSize : defaultMinSize || 0,\n      maxSize: typeof maxSize === \"number\" ? maxSize : defaultMaxSize || 0,\n      automaticNameDelimiter: automaticNameDelimiter || defaultAutomaticNameDelimiter || \"~\"\n    };\n  }\n\n  static normalizeCacheGroups({\n    cacheGroups,\n    name,\n    automaticNameDelimiter,\n    automaticNameMaxLength\n  }) {\n    if (typeof cacheGroups === \"function\") {\n      // TODO webpack 5 remove this\n      if (cacheGroups.length !== 1) {\n        return module => cacheGroups(module, module.getChunks());\n      }\n\n      return cacheGroups;\n    }\n\n    if (cacheGroups && typeof cacheGroups === \"object\") {\n      const fn = module => {\n        let results;\n\n        for (const key of Object.keys(cacheGroups)) {\n          let option = cacheGroups[key];\n          if (option === false) continue;\n\n          if (option instanceof RegExp || typeof option === \"string\") {\n            option = {\n              test: option\n            };\n          }\n\n          if (typeof option === \"function\") {\n            let result = option(module);\n\n            if (result) {\n              if (results === undefined) results = [];\n\n              for (const r of Array.isArray(result) ? result : [result]) {\n                const result = Object.assign({\n                  key\n                }, r);\n                if (result.name) result.getName = () => result.name;\n\n                if (result.chunks) {\n                  result.chunksFilter = SplitChunksPlugin.normalizeChunksFilter(result.chunks);\n                }\n\n                results.push(result);\n              }\n            }\n          } else if (SplitChunksPlugin.checkTest(option.test, module)) {\n            if (results === undefined) results = [];\n            results.push({\n              key: key,\n              priority: option.priority,\n              getName: SplitChunksPlugin.normalizeName({\n                name: option.name || name,\n                automaticNameDelimiter: typeof option.automaticNameDelimiter === \"string\" ? option.automaticNameDelimiter : automaticNameDelimiter,\n                automaticNamePrefix: option.automaticNamePrefix,\n                automaticNameMaxLength: option.automaticNameMaxLength || automaticNameMaxLength\n              }) || (() => {}),\n              chunksFilter: SplitChunksPlugin.normalizeChunksFilter(option.chunks),\n              enforce: option.enforce,\n              minSize: option.minSize,\n              maxSize: option.maxSize,\n              minChunks: option.minChunks,\n              maxAsyncRequests: option.maxAsyncRequests,\n              maxInitialRequests: option.maxInitialRequests,\n              filename: option.filename,\n              reuseExistingChunk: option.reuseExistingChunk\n            });\n          }\n        }\n\n        return results;\n      };\n\n      return fn;\n    }\n\n    const fn = () => {};\n\n    return fn;\n  }\n\n  static checkTest(test, module) {\n    if (test === undefined) return true;\n\n    if (typeof test === \"function\") {\n      if (test.length !== 1) {\n        return test(module, module.getChunks());\n      }\n\n      return test(module);\n    }\n\n    if (typeof test === \"boolean\") return test;\n\n    if (typeof test === \"string\") {\n      if (module.nameForCondition && module.nameForCondition().startsWith(test)) {\n        return true;\n      }\n\n      for (const chunk of module.chunksIterable) {\n        if (chunk.name && chunk.name.startsWith(test)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    if (test instanceof RegExp) {\n      if (module.nameForCondition && test.test(module.nameForCondition())) {\n        return true;\n      }\n\n      for (const chunk of module.chunksIterable) {\n        if (chunk.name && test.test(chunk.name)) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    return false;\n  }\n  /**\n   * @param {Compiler} compiler webpack compiler\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    compiler.hooks.thisCompilation.tap(\"SplitChunksPlugin\", compilation => {\n      let alreadyOptimized = false;\n      compilation.hooks.unseal.tap(\"SplitChunksPlugin\", () => {\n        alreadyOptimized = false;\n      });\n      compilation.hooks.optimizeChunksAdvanced.tap(\"SplitChunksPlugin\", chunks => {\n        if (alreadyOptimized) return;\n        alreadyOptimized = true; // Give each selected chunk an index (to create strings from chunks)\n\n        const indexMap = new Map();\n        let index = 1;\n\n        for (const chunk of chunks) {\n          indexMap.set(chunk, index++);\n        }\n\n        const getKey = chunks => {\n          return Array.from(chunks, c => indexMap.get(c)).sort(compareNumbers).join();\n        };\n        /** @type {Map<string, Set<Chunk>>} */\n\n\n        const chunkSetsInGraph = new Map();\n\n        for (const module of compilation.modules) {\n          const chunksKey = getKey(module.chunksIterable);\n\n          if (!chunkSetsInGraph.has(chunksKey)) {\n            chunkSetsInGraph.set(chunksKey, new Set(module.chunksIterable));\n          }\n        } // group these set of chunks by count\n        // to allow to check less sets via isSubset\n        // (only smaller sets can be subset)\n\n        /** @type {Map<number, Array<Set<Chunk>>>} */\n\n\n        const chunkSetsByCount = new Map();\n\n        for (const chunksSet of chunkSetsInGraph.values()) {\n          const count = chunksSet.size;\n          let array = chunkSetsByCount.get(count);\n\n          if (array === undefined) {\n            array = [];\n            chunkSetsByCount.set(count, array);\n          }\n\n          array.push(chunksSet);\n        } // Create a list of possible combinations\n\n\n        const combinationsCache = new Map(); // Map<string, Set<Chunk>[]>\n\n        const getCombinations = key => {\n          const chunksSet = chunkSetsInGraph.get(key);\n          var array = [chunksSet];\n\n          if (chunksSet.size > 1) {\n            for (const [count, setArray] of chunkSetsByCount) {\n              // \"equal\" is not needed because they would have been merge in the first step\n              if (count < chunksSet.size) {\n                for (const set of setArray) {\n                  if (isSubset(chunksSet, set)) {\n                    array.push(set);\n                  }\n                }\n              }\n            }\n          }\n\n          return array;\n        };\n        /**\n         * @typedef {Object} SelectedChunksResult\n         * @property {Chunk[]} chunks the list of chunks\n         * @property {string} key a key of the list\n         */\n\n        /**\n         * @typedef {function(Chunk): boolean} ChunkFilterFunction\n         */\n\n        /** @type {WeakMap<Set<Chunk>, WeakMap<ChunkFilterFunction, SelectedChunksResult>>} */\n\n\n        const selectedChunksCacheByChunksSet = new WeakMap();\n        /**\n         * get list and key by applying the filter function to the list\n         * It is cached for performance reasons\n         * @param {Set<Chunk>} chunks list of chunks\n         * @param {ChunkFilterFunction} chunkFilter filter function for chunks\n         * @returns {SelectedChunksResult} list and key\n         */\n\n        const getSelectedChunks = (chunks, chunkFilter) => {\n          let entry = selectedChunksCacheByChunksSet.get(chunks);\n\n          if (entry === undefined) {\n            entry = new WeakMap();\n            selectedChunksCacheByChunksSet.set(chunks, entry);\n          }\n          /** @type {SelectedChunksResult} */\n\n\n          let entry2 = entry.get(chunkFilter);\n\n          if (entry2 === undefined) {\n            /** @type {Chunk[]} */\n            const selectedChunks = [];\n\n            for (const chunk of chunks) {\n              if (chunkFilter(chunk)) selectedChunks.push(chunk);\n            }\n\n            entry2 = {\n              chunks: selectedChunks,\n              key: getKey(selectedChunks)\n            };\n            entry.set(chunkFilter, entry2);\n          }\n\n          return entry2;\n        };\n        /**\n         * @typedef {Object} ChunksInfoItem\n         * @property {SortableSet} modules\n         * @property {TODO} cacheGroup\n         * @property {string} name\n         * @property {boolean} validateSize\n         * @property {number} size\n         * @property {Set<Chunk>} chunks\n         * @property {Set<Chunk>} reuseableChunks\n         * @property {Set<string>} chunksKeys\n         */\n        // Map a list of chunks to a list of modules\n        // For the key the chunk \"index\" is used, the value is a SortableSet of modules\n\n        /** @type {Map<string, ChunksInfoItem>} */\n\n\n        const chunksInfoMap = new Map();\n        /**\n         * @param {TODO} cacheGroup the current cache group\n         * @param {Chunk[]} selectedChunks chunks selected for this module\n         * @param {string} selectedChunksKey a key of selectedChunks\n         * @param {Module} module the current module\n         * @returns {void}\n         */\n\n        const addModuleToChunksInfoMap = (cacheGroup, selectedChunks, selectedChunksKey, module) => {\n          // Break if minimum number of chunks is not reached\n          if (selectedChunks.length < cacheGroup.minChunks) return; // Determine name for split chunk\n\n          const name = cacheGroup.getName(module, selectedChunks, cacheGroup.key); // Create key for maps\n          // When it has a name we use the name as key\n          // Elsewise we create the key from chunks and cache group key\n          // This automatically merges equal names\n\n          const key = cacheGroup.key + (name ? ` name:${name}` : ` chunks:${selectedChunksKey}`); // Add module to maps\n\n          let info = chunksInfoMap.get(key);\n\n          if (info === undefined) {\n            chunksInfoMap.set(key, info = {\n              modules: new SortableSet(undefined, sortByIdentifier),\n              cacheGroup,\n              name,\n              validateSize: cacheGroup.minSize > 0,\n              size: 0,\n              chunks: new Set(),\n              reuseableChunks: new Set(),\n              chunksKeys: new Set()\n            });\n          }\n\n          info.modules.add(module);\n\n          if (info.validateSize) {\n            info.size += module.size();\n          }\n\n          if (!info.chunksKeys.has(selectedChunksKey)) {\n            info.chunksKeys.add(selectedChunksKey);\n\n            for (const chunk of selectedChunks) {\n              info.chunks.add(chunk);\n            }\n          }\n        }; // Walk through all modules\n\n\n        for (const module of compilation.modules) {\n          // Get cache group\n          let cacheGroups = this.options.getCacheGroups(module);\n\n          if (!Array.isArray(cacheGroups) || cacheGroups.length === 0) {\n            continue;\n          } // Prepare some values\n\n\n          const chunksKey = getKey(module.chunksIterable);\n          let combs = combinationsCache.get(chunksKey);\n\n          if (combs === undefined) {\n            combs = getCombinations(chunksKey);\n            combinationsCache.set(chunksKey, combs);\n          }\n\n          for (const cacheGroupSource of cacheGroups) {\n            const cacheGroup = {\n              key: cacheGroupSource.key,\n              priority: cacheGroupSource.priority || 0,\n              chunksFilter: cacheGroupSource.chunksFilter || this.options.chunksFilter,\n              minSize: cacheGroupSource.minSize !== undefined ? cacheGroupSource.minSize : cacheGroupSource.enforce ? 0 : this.options.minSize,\n              minSizeForMaxSize: cacheGroupSource.minSize !== undefined ? cacheGroupSource.minSize : this.options.minSize,\n              maxSize: cacheGroupSource.maxSize !== undefined ? cacheGroupSource.maxSize : cacheGroupSource.enforce ? 0 : this.options.maxSize,\n              minChunks: cacheGroupSource.minChunks !== undefined ? cacheGroupSource.minChunks : cacheGroupSource.enforce ? 1 : this.options.minChunks,\n              maxAsyncRequests: cacheGroupSource.maxAsyncRequests !== undefined ? cacheGroupSource.maxAsyncRequests : cacheGroupSource.enforce ? Infinity : this.options.maxAsyncRequests,\n              maxInitialRequests: cacheGroupSource.maxInitialRequests !== undefined ? cacheGroupSource.maxInitialRequests : cacheGroupSource.enforce ? Infinity : this.options.maxInitialRequests,\n              getName: cacheGroupSource.getName !== undefined ? cacheGroupSource.getName : this.options.getName,\n              filename: cacheGroupSource.filename !== undefined ? cacheGroupSource.filename : this.options.filename,\n              automaticNameDelimiter: cacheGroupSource.automaticNameDelimiter !== undefined ? cacheGroupSource.automaticNameDelimiter : this.options.automaticNameDelimiter,\n              reuseExistingChunk: cacheGroupSource.reuseExistingChunk\n            }; // For all combination of chunk selection\n\n            for (const chunkCombination of combs) {\n              // Break if minimum number of chunks is not reached\n              if (chunkCombination.size < cacheGroup.minChunks) continue; // Select chunks by configuration\n\n              const {\n                chunks: selectedChunks,\n                key: selectedChunksKey\n              } = getSelectedChunks(chunkCombination, cacheGroup.chunksFilter);\n              addModuleToChunksInfoMap(cacheGroup, selectedChunks, selectedChunksKey, module);\n            }\n          }\n        } // Filter items were size < minSize\n\n\n        for (const pair of chunksInfoMap) {\n          const info = pair[1];\n\n          if (info.validateSize && info.size < info.cacheGroup.minSize) {\n            chunksInfoMap.delete(pair[0]);\n          }\n        }\n        /** @type {Map<Chunk, {minSize: number, maxSize: number, automaticNameDelimiter: string, keys: string[]}>} */\n\n\n        const maxSizeQueueMap = new Map();\n\n        while (chunksInfoMap.size > 0) {\n          // Find best matching entry\n          let bestEntryKey;\n          let bestEntry;\n\n          for (const pair of chunksInfoMap) {\n            const key = pair[0];\n            const info = pair[1];\n\n            if (bestEntry === undefined) {\n              bestEntry = info;\n              bestEntryKey = key;\n            } else if (compareEntries(bestEntry, info) < 0) {\n              bestEntry = info;\n              bestEntryKey = key;\n            }\n          }\n\n          const item = bestEntry;\n          chunksInfoMap.delete(bestEntryKey);\n          let chunkName = item.name; // Variable for the new chunk (lazy created)\n\n          /** @type {Chunk} */\n\n          let newChunk; // When no chunk name, check if we can reuse a chunk instead of creating a new one\n\n          let isReused = false;\n\n          if (item.cacheGroup.reuseExistingChunk) {\n            outer: for (const chunk of item.chunks) {\n              if (chunk.getNumberOfModules() !== item.modules.size) continue;\n              if (chunk.hasEntryModule()) continue;\n\n              for (const module of item.modules) {\n                if (!chunk.containsModule(module)) continue outer;\n              }\n\n              if (!newChunk || !newChunk.name) {\n                newChunk = chunk;\n              } else if (chunk.name && chunk.name.length < newChunk.name.length) {\n                newChunk = chunk;\n              } else if (chunk.name && chunk.name.length === newChunk.name.length && chunk.name < newChunk.name) {\n                newChunk = chunk;\n              }\n\n              chunkName = undefined;\n              isReused = true;\n            }\n          } // Check if maxRequests condition can be fulfilled\n\n\n          const usedChunks = Array.from(item.chunks).filter(chunk => {\n            // skip if we address ourself\n            return (!chunkName || chunk.name !== chunkName) && chunk !== newChunk;\n          }); // Skip when no chunk selected\n\n          if (usedChunks.length === 0) continue;\n          let validChunks = usedChunks;\n\n          if (Number.isFinite(item.cacheGroup.maxInitialRequests) || Number.isFinite(item.cacheGroup.maxAsyncRequests)) {\n            validChunks = validChunks.filter(chunk => {\n              // respect max requests when not enforced\n              const maxRequests = chunk.isOnlyInitial() ? item.cacheGroup.maxInitialRequests : chunk.canBeInitial() ? Math.min(item.cacheGroup.maxInitialRequests, item.cacheGroup.maxAsyncRequests) : item.cacheGroup.maxAsyncRequests;\n              return !isFinite(maxRequests) || getRequests(chunk) < maxRequests;\n            });\n          }\n\n          validChunks = validChunks.filter(chunk => {\n            for (const module of item.modules) {\n              if (chunk.containsModule(module)) return true;\n            }\n\n            return false;\n          });\n\n          if (validChunks.length < usedChunks.length) {\n            if (validChunks.length >= item.cacheGroup.minChunks) {\n              for (const module of item.modules) {\n                addModuleToChunksInfoMap(item.cacheGroup, validChunks, getKey(validChunks), module);\n              }\n            }\n\n            continue;\n          } // Create the new chunk if not reusing one\n\n\n          if (!isReused) {\n            newChunk = compilation.addChunk(chunkName);\n          } // Walk through all chunks\n\n\n          for (const chunk of usedChunks) {\n            // Add graph connections for splitted chunk\n            chunk.split(newChunk);\n          } // Add a note to the chunk\n\n\n          newChunk.chunkReason = isReused ? \"reused as split chunk\" : \"split chunk\";\n\n          if (item.cacheGroup.key) {\n            newChunk.chunkReason += ` (cache group: ${item.cacheGroup.key})`;\n          }\n\n          if (chunkName) {\n            newChunk.chunkReason += ` (name: ${chunkName})`; // If the chosen name is already an entry point we remove the entry point\n\n            const entrypoint = compilation.entrypoints.get(chunkName);\n\n            if (entrypoint) {\n              compilation.entrypoints.delete(chunkName);\n              entrypoint.remove();\n              newChunk.entryModule = undefined;\n            }\n          }\n\n          if (item.cacheGroup.filename) {\n            if (!newChunk.isOnlyInitial()) {\n              throw new Error(\"SplitChunksPlugin: You are trying to set a filename for a chunk which is (also) loaded on demand. \" + \"The runtime can only handle loading of chunks which match the chunkFilename schema. \" + \"Using a custom filename would fail at runtime. \" + `(cache group: ${item.cacheGroup.key})`);\n            }\n\n            newChunk.filenameTemplate = item.cacheGroup.filename;\n          }\n\n          if (!isReused) {\n            // Add all modules to the new chunk\n            for (const module of item.modules) {\n              if (typeof module.chunkCondition === \"function\") {\n                if (!module.chunkCondition(newChunk)) continue;\n              } // Add module to new chunk\n\n\n              GraphHelpers.connectChunkAndModule(newChunk, module); // Remove module from used chunks\n\n              for (const chunk of usedChunks) {\n                chunk.removeModule(module);\n                module.rewriteChunkInReasons(chunk, [newChunk]);\n              }\n            }\n          } else {\n            // Remove all modules from used chunks\n            for (const module of item.modules) {\n              for (const chunk of usedChunks) {\n                chunk.removeModule(module);\n                module.rewriteChunkInReasons(chunk, [newChunk]);\n              }\n            }\n          }\n\n          if (item.cacheGroup.maxSize > 0) {\n            const oldMaxSizeSettings = maxSizeQueueMap.get(newChunk);\n            maxSizeQueueMap.set(newChunk, {\n              minSize: Math.max(oldMaxSizeSettings ? oldMaxSizeSettings.minSize : 0, item.cacheGroup.minSizeForMaxSize),\n              maxSize: Math.min(oldMaxSizeSettings ? oldMaxSizeSettings.maxSize : Infinity, item.cacheGroup.maxSize),\n              automaticNameDelimiter: item.cacheGroup.automaticNameDelimiter,\n              keys: oldMaxSizeSettings ? oldMaxSizeSettings.keys.concat(item.cacheGroup.key) : [item.cacheGroup.key]\n            });\n          } // remove all modules from other entries and update size\n\n\n          for (const [key, info] of chunksInfoMap) {\n            if (isOverlap(info.chunks, item.chunks)) {\n              if (info.validateSize) {\n                // update modules and total size\n                // may remove it from the map when < minSize\n                const oldSize = info.modules.size;\n\n                for (const module of item.modules) {\n                  info.modules.delete(module);\n                }\n\n                if (info.modules.size === 0) {\n                  chunksInfoMap.delete(key);\n                  continue;\n                }\n\n                if (info.modules.size !== oldSize) {\n                  info.size = getModulesSize(info.modules);\n\n                  if (info.size < info.cacheGroup.minSize) {\n                    chunksInfoMap.delete(key);\n                  }\n                }\n              } else {\n                // only update the modules\n                for (const module of item.modules) {\n                  info.modules.delete(module);\n                }\n\n                if (info.modules.size === 0) {\n                  chunksInfoMap.delete(key);\n                }\n              }\n            }\n          }\n        }\n\n        const incorrectMinMaxSizeSet = new Set(); // Make sure that maxSize is fulfilled\n\n        for (const chunk of compilation.chunks.slice()) {\n          const {\n            minSize,\n            maxSize,\n            automaticNameDelimiter,\n            keys\n          } = maxSizeQueueMap.get(chunk) || this.options.fallbackCacheGroup;\n          if (!maxSize) continue;\n\n          if (minSize > maxSize) {\n            const warningKey = `${keys && keys.join()} ${minSize} ${maxSize}`;\n\n            if (!incorrectMinMaxSizeSet.has(warningKey)) {\n              incorrectMinMaxSizeSet.add(warningKey);\n              compilation.warnings.push(new MinMaxSizeWarning(keys, minSize, maxSize));\n            }\n          }\n\n          const results = deterministicGroupingForModules({\n            maxSize: Math.max(minSize, maxSize),\n            minSize,\n            items: chunk.modulesIterable,\n\n            getKey(module) {\n              const ident = contextify(compilation.options.context, module.identifier());\n              const name = module.nameForCondition ? contextify(compilation.options.context, module.nameForCondition()) : ident.replace(/^.*!|\\?[^?!]*$/g, \"\");\n              const fullKey = name + automaticNameDelimiter + hashFilename(ident);\n              return fullKey.replace(/[\\\\/?]/g, \"_\");\n            },\n\n            getSize(module) {\n              return module.size();\n            }\n\n          });\n          results.sort((a, b) => {\n            if (a.key < b.key) return -1;\n            if (a.key > b.key) return 1;\n            return 0;\n          });\n\n          for (let i = 0; i < results.length; i++) {\n            const group = results[i];\n            const key = this.options.hidePathInfo ? hashFilename(group.key) : group.key;\n            let name = chunk.name ? chunk.name + automaticNameDelimiter + key : null;\n\n            if (name && name.length > 100) {\n              name = name.slice(0, 100) + automaticNameDelimiter + hashFilename(name);\n            }\n\n            let newPart;\n\n            if (i !== results.length - 1) {\n              newPart = compilation.addChunk(name);\n              chunk.split(newPart);\n              newPart.chunkReason = chunk.chunkReason; // Add all modules to the new chunk\n\n              for (const module of group.items) {\n                if (typeof module.chunkCondition === \"function\") {\n                  if (!module.chunkCondition(newPart)) continue;\n                } // Add module to new chunk\n\n\n                GraphHelpers.connectChunkAndModule(newPart, module); // Remove module from used chunks\n\n                chunk.removeModule(module);\n                module.rewriteChunkInReasons(chunk, [newPart]);\n              }\n            } else {\n              // change the chunk to be a part\n              newPart = chunk;\n              chunk.name = name;\n            }\n          }\n        }\n      });\n    });\n  }\n\n};","map":{"version":3,"sources":["E:/Users/cnki/source/repos/ab29693295/MeetAdmin/node_modules/webpack/lib/optimize/SplitChunksPlugin.js"],"names":["crypto","require","SortableSet","GraphHelpers","isSubset","deterministicGrouping","MinMaxSizeWarning","contextify","deterministicGroupingForModules","hashFilename","name","createHash","update","digest","slice","sortByIdentifier","a","b","identifier","getRequests","chunk","requests","chunkGroup","groupsIterable","Math","max","chunks","length","getModulesSize","modules","sum","m","size","isOverlap","item","has","compareEntries","diffPriority","cacheGroup","priority","diffCount","aSizeReduce","bSizeReduce","diffSizeReduce","modulesA","modulesB","diff","sort","aI","Symbol","iterator","bI","aItem","next","bItem","done","aModuleIdentifier","value","bModuleIdentifier","compareNumbers","INITIAL_CHUNK_FILTER","canBeInitial","ASYNC_CHUNK_FILTER","ALL_CHUNK_FILTER","module","exports","SplitChunksPlugin","constructor","options","normalizeOptions","chunksFilter","normalizeChunksFilter","minSize","maxSize","minChunks","maxAsyncRequests","maxInitialRequests","hidePathInfo","filename","undefined","getCacheGroups","normalizeCacheGroups","cacheGroups","automaticNameDelimiter","automaticNameMaxLength","fallbackCacheGroup","normalizeFallbackCacheGroup","normalizeName","automaticNamePrefix","cache","WeakMap","fn","cacheEntry","get","set","names","map","c","every","Boolean","prefix","namePrefix","join","hashedFilename","sliceLength","defaultMinSize","defaultMaxSize","defaultAutomaticNameDelimiter","getChunks","results","key","Object","keys","option","RegExp","test","result","r","Array","isArray","assign","getName","push","checkTest","enforce","reuseExistingChunk","nameForCondition","startsWith","chunksIterable","apply","compiler","hooks","thisCompilation","tap","compilation","alreadyOptimized","unseal","optimizeChunksAdvanced","indexMap","Map","index","getKey","from","chunkSetsInGraph","chunksKey","Set","chunkSetsByCount","chunksSet","values","count","array","combinationsCache","getCombinations","setArray","selectedChunksCacheByChunksSet","getSelectedChunks","chunkFilter","entry","entry2","selectedChunks","chunksInfoMap","addModuleToChunksInfoMap","selectedChunksKey","info","validateSize","reuseableChunks","chunksKeys","add","combs","cacheGroupSource","minSizeForMaxSize","Infinity","chunkCombination","pair","delete","maxSizeQueueMap","bestEntryKey","bestEntry","chunkName","newChunk","isReused","outer","getNumberOfModules","hasEntryModule","containsModule","usedChunks","filter","validChunks","Number","isFinite","maxRequests","isOnlyInitial","min","addChunk","split","chunkReason","entrypoint","entrypoints","remove","entryModule","Error","filenameTemplate","chunkCondition","connectChunkAndModule","removeModule","rewriteChunkInReasons","oldMaxSizeSettings","concat","oldSize","incorrectMinMaxSizeSet","warningKey","warnings","items","modulesIterable","ident","context","replace","fullKey","getSize","i","group","newPart"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst crypto = require(\"crypto\");\nconst SortableSet = require(\"../util/SortableSet\");\nconst GraphHelpers = require(\"../GraphHelpers\");\nconst { isSubset } = require(\"../util/SetHelpers\");\nconst deterministicGrouping = require(\"../util/deterministicGrouping\");\nconst MinMaxSizeWarning = require(\"./MinMaxSizeWarning\");\nconst contextify = require(\"../util/identifier\").contextify;\n\n/** @typedef {import(\"../Compiler\")} Compiler */\n/** @typedef {import(\"../Chunk\")} Chunk */\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../util/deterministicGrouping\").Options<Module>} DeterministicGroupingOptionsForModule */\n/** @typedef {import(\"../util/deterministicGrouping\").GroupedItems<Module>} DeterministicGroupingGroupedItemsForModule */\n\nconst deterministicGroupingForModules = /** @type {function(DeterministicGroupingOptionsForModule): DeterministicGroupingGroupedItemsForModule[]} */ (deterministicGrouping);\n\nconst hashFilename = name => {\n\treturn crypto\n\t\t.createHash(\"md4\")\n\t\t.update(name)\n\t\t.digest(\"hex\")\n\t\t.slice(0, 8);\n};\n\nconst sortByIdentifier = (a, b) => {\n\tif (a.identifier() > b.identifier()) return 1;\n\tif (a.identifier() < b.identifier()) return -1;\n\treturn 0;\n};\n\nconst getRequests = chunk => {\n\tlet requests = 0;\n\tfor (const chunkGroup of chunk.groupsIterable) {\n\t\trequests = Math.max(requests, chunkGroup.chunks.length);\n\t}\n\treturn requests;\n};\n\nconst getModulesSize = modules => {\n\tlet sum = 0;\n\tfor (const m of modules) {\n\t\tsum += m.size();\n\t}\n\treturn sum;\n};\n\n/**\n * @template T\n * @param {Set<T>} a set\n * @param {Set<T>} b other set\n * @returns {boolean} true if at least one item of a is in b\n */\nconst isOverlap = (a, b) => {\n\tfor (const item of a) {\n\t\tif (b.has(item)) return true;\n\t}\n\treturn false;\n};\n\nconst compareEntries = (a, b) => {\n\t// 1. by priority\n\tconst diffPriority = a.cacheGroup.priority - b.cacheGroup.priority;\n\tif (diffPriority) return diffPriority;\n\t// 2. by number of chunks\n\tconst diffCount = a.chunks.size - b.chunks.size;\n\tif (diffCount) return diffCount;\n\t// 3. by size reduction\n\tconst aSizeReduce = a.size * (a.chunks.size - 1);\n\tconst bSizeReduce = b.size * (b.chunks.size - 1);\n\tconst diffSizeReduce = aSizeReduce - bSizeReduce;\n\tif (diffSizeReduce) return diffSizeReduce;\n\t// 4. by number of modules (to be able to compare by identifier)\n\tconst modulesA = a.modules;\n\tconst modulesB = b.modules;\n\tconst diff = modulesA.size - modulesB.size;\n\tif (diff) return diff;\n\t// 5. by module identifiers\n\tmodulesA.sort();\n\tmodulesB.sort();\n\tconst aI = modulesA[Symbol.iterator]();\n\tconst bI = modulesB[Symbol.iterator]();\n\t// eslint-disable-next-line no-constant-condition\n\twhile (true) {\n\t\tconst aItem = aI.next();\n\t\tconst bItem = bI.next();\n\t\tif (aItem.done) return 0;\n\t\tconst aModuleIdentifier = aItem.value.identifier();\n\t\tconst bModuleIdentifier = bItem.value.identifier();\n\t\tif (aModuleIdentifier > bModuleIdentifier) return -1;\n\t\tif (aModuleIdentifier < bModuleIdentifier) return 1;\n\t}\n};\n\nconst compareNumbers = (a, b) => a - b;\n\nconst INITIAL_CHUNK_FILTER = chunk => chunk.canBeInitial();\nconst ASYNC_CHUNK_FILTER = chunk => !chunk.canBeInitial();\nconst ALL_CHUNK_FILTER = chunk => true;\n\nmodule.exports = class SplitChunksPlugin {\n\tconstructor(options) {\n\t\tthis.options = SplitChunksPlugin.normalizeOptions(options);\n\t}\n\n\tstatic normalizeOptions(options = {}) {\n\t\treturn {\n\t\t\tchunksFilter: SplitChunksPlugin.normalizeChunksFilter(\n\t\t\t\toptions.chunks || \"all\"\n\t\t\t),\n\t\t\tminSize: options.minSize || 0,\n\t\t\tmaxSize: options.maxSize || 0,\n\t\t\tminChunks: options.minChunks || 1,\n\t\t\tmaxAsyncRequests: options.maxAsyncRequests || 1,\n\t\t\tmaxInitialRequests: options.maxInitialRequests || 1,\n\t\t\thidePathInfo: options.hidePathInfo || false,\n\t\t\tfilename: options.filename || undefined,\n\t\t\tgetCacheGroups: SplitChunksPlugin.normalizeCacheGroups({\n\t\t\t\tcacheGroups: options.cacheGroups,\n\t\t\t\tname: options.name,\n\t\t\t\tautomaticNameDelimiter: options.automaticNameDelimiter,\n\t\t\t\tautomaticNameMaxLength: options.automaticNameMaxLength\n\t\t\t}),\n\t\t\tautomaticNameDelimiter: options.automaticNameDelimiter,\n\t\t\tautomaticNameMaxLength: options.automaticNameMaxLength || 109,\n\t\t\tfallbackCacheGroup: SplitChunksPlugin.normalizeFallbackCacheGroup(\n\t\t\t\toptions.fallbackCacheGroup || {},\n\t\t\t\toptions\n\t\t\t)\n\t\t};\n\t}\n\n\tstatic normalizeName({\n\t\tname,\n\t\tautomaticNameDelimiter,\n\t\tautomaticNamePrefix,\n\t\tautomaticNameMaxLength\n\t}) {\n\t\tif (name === true) {\n\t\t\t/** @type {WeakMap<Chunk[], Record<string, string>>} */\n\t\t\tconst cache = new WeakMap();\n\t\t\tconst fn = (module, chunks, cacheGroup) => {\n\t\t\t\tlet cacheEntry = cache.get(chunks);\n\t\t\t\tif (cacheEntry === undefined) {\n\t\t\t\t\tcacheEntry = {};\n\t\t\t\t\tcache.set(chunks, cacheEntry);\n\t\t\t\t} else if (cacheGroup in cacheEntry) {\n\t\t\t\t\treturn cacheEntry[cacheGroup];\n\t\t\t\t}\n\t\t\t\tconst names = chunks.map(c => c.name);\n\t\t\t\tif (!names.every(Boolean)) {\n\t\t\t\t\tcacheEntry[cacheGroup] = undefined;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tnames.sort();\n\t\t\t\tconst prefix =\n\t\t\t\t\ttypeof automaticNamePrefix === \"string\"\n\t\t\t\t\t\t? automaticNamePrefix\n\t\t\t\t\t\t: cacheGroup;\n\t\t\t\tconst namePrefix = prefix ? prefix + automaticNameDelimiter : \"\";\n\t\t\t\tlet name = namePrefix + names.join(automaticNameDelimiter);\n\t\t\t\t// Filenames and paths can't be too long otherwise an\n\t\t\t\t// ENAMETOOLONG error is raised. If the generated name if too\n\t\t\t\t// long, it is truncated and a hash is appended. The limit has\n\t\t\t\t// been set to 109 to prevent `[name].[chunkhash].[ext]` from\n\t\t\t\t// generating a 256+ character string.\n\t\t\t\tif (name.length > automaticNameMaxLength) {\n\t\t\t\t\tconst hashedFilename = hashFilename(name);\n\t\t\t\t\tconst sliceLength =\n\t\t\t\t\t\tautomaticNameMaxLength -\n\t\t\t\t\t\t(automaticNameDelimiter.length + hashedFilename.length);\n\t\t\t\t\tname =\n\t\t\t\t\t\tname.slice(0, sliceLength) +\n\t\t\t\t\t\tautomaticNameDelimiter +\n\t\t\t\t\t\thashedFilename;\n\t\t\t\t}\n\t\t\t\tcacheEntry[cacheGroup] = name;\n\t\t\t\treturn name;\n\t\t\t};\n\t\t\treturn fn;\n\t\t}\n\t\tif (typeof name === \"string\") {\n\t\t\tconst fn = () => {\n\t\t\t\treturn name;\n\t\t\t};\n\t\t\treturn fn;\n\t\t}\n\t\tif (typeof name === \"function\") return name;\n\t}\n\n\tstatic normalizeChunksFilter(chunks) {\n\t\tif (chunks === \"initial\") {\n\t\t\treturn INITIAL_CHUNK_FILTER;\n\t\t}\n\t\tif (chunks === \"async\") {\n\t\t\treturn ASYNC_CHUNK_FILTER;\n\t\t}\n\t\tif (chunks === \"all\") {\n\t\t\treturn ALL_CHUNK_FILTER;\n\t\t}\n\t\tif (typeof chunks === \"function\") return chunks;\n\t}\n\n\tstatic normalizeFallbackCacheGroup(\n\t\t{\n\t\t\tminSize = undefined,\n\t\t\tmaxSize = undefined,\n\t\t\tautomaticNameDelimiter = undefined\n\t\t},\n\t\t{\n\t\t\tminSize: defaultMinSize = undefined,\n\t\t\tmaxSize: defaultMaxSize = undefined,\n\t\t\tautomaticNameDelimiter: defaultAutomaticNameDelimiter = undefined\n\t\t}\n\t) {\n\t\treturn {\n\t\t\tminSize: typeof minSize === \"number\" ? minSize : defaultMinSize || 0,\n\t\t\tmaxSize: typeof maxSize === \"number\" ? maxSize : defaultMaxSize || 0,\n\t\t\tautomaticNameDelimiter:\n\t\t\t\tautomaticNameDelimiter || defaultAutomaticNameDelimiter || \"~\"\n\t\t};\n\t}\n\n\tstatic normalizeCacheGroups({\n\t\tcacheGroups,\n\t\tname,\n\t\tautomaticNameDelimiter,\n\t\tautomaticNameMaxLength\n\t}) {\n\t\tif (typeof cacheGroups === \"function\") {\n\t\t\t// TODO webpack 5 remove this\n\t\t\tif (cacheGroups.length !== 1) {\n\t\t\t\treturn module => cacheGroups(module, module.getChunks());\n\t\t\t}\n\t\t\treturn cacheGroups;\n\t\t}\n\t\tif (cacheGroups && typeof cacheGroups === \"object\") {\n\t\t\tconst fn = module => {\n\t\t\t\tlet results;\n\t\t\t\tfor (const key of Object.keys(cacheGroups)) {\n\t\t\t\t\tlet option = cacheGroups[key];\n\t\t\t\t\tif (option === false) continue;\n\t\t\t\t\tif (option instanceof RegExp || typeof option === \"string\") {\n\t\t\t\t\t\toption = {\n\t\t\t\t\t\t\ttest: option\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof option === \"function\") {\n\t\t\t\t\t\tlet result = option(module);\n\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\tif (results === undefined) results = [];\n\t\t\t\t\t\t\tfor (const r of Array.isArray(result) ? result : [result]) {\n\t\t\t\t\t\t\t\tconst result = Object.assign({ key }, r);\n\t\t\t\t\t\t\t\tif (result.name) result.getName = () => result.name;\n\t\t\t\t\t\t\t\tif (result.chunks) {\n\t\t\t\t\t\t\t\t\tresult.chunksFilter = SplitChunksPlugin.normalizeChunksFilter(\n\t\t\t\t\t\t\t\t\t\tresult.chunks\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tresults.push(result);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (SplitChunksPlugin.checkTest(option.test, module)) {\n\t\t\t\t\t\tif (results === undefined) results = [];\n\t\t\t\t\t\tresults.push({\n\t\t\t\t\t\t\tkey: key,\n\t\t\t\t\t\t\tpriority: option.priority,\n\t\t\t\t\t\t\tgetName:\n\t\t\t\t\t\t\t\tSplitChunksPlugin.normalizeName({\n\t\t\t\t\t\t\t\t\tname: option.name || name,\n\t\t\t\t\t\t\t\t\tautomaticNameDelimiter:\n\t\t\t\t\t\t\t\t\t\ttypeof option.automaticNameDelimiter === \"string\"\n\t\t\t\t\t\t\t\t\t\t\t? option.automaticNameDelimiter\n\t\t\t\t\t\t\t\t\t\t\t: automaticNameDelimiter,\n\t\t\t\t\t\t\t\t\tautomaticNamePrefix: option.automaticNamePrefix,\n\t\t\t\t\t\t\t\t\tautomaticNameMaxLength:\n\t\t\t\t\t\t\t\t\t\toption.automaticNameMaxLength || automaticNameMaxLength\n\t\t\t\t\t\t\t\t}) || (() => {}),\n\t\t\t\t\t\t\tchunksFilter: SplitChunksPlugin.normalizeChunksFilter(\n\t\t\t\t\t\t\t\toption.chunks\n\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\tenforce: option.enforce,\n\t\t\t\t\t\t\tminSize: option.minSize,\n\t\t\t\t\t\t\tmaxSize: option.maxSize,\n\t\t\t\t\t\t\tminChunks: option.minChunks,\n\t\t\t\t\t\t\tmaxAsyncRequests: option.maxAsyncRequests,\n\t\t\t\t\t\t\tmaxInitialRequests: option.maxInitialRequests,\n\t\t\t\t\t\t\tfilename: option.filename,\n\t\t\t\t\t\t\treuseExistingChunk: option.reuseExistingChunk\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn results;\n\t\t\t};\n\t\t\treturn fn;\n\t\t}\n\t\tconst fn = () => {};\n\t\treturn fn;\n\t}\n\n\tstatic checkTest(test, module) {\n\t\tif (test === undefined) return true;\n\t\tif (typeof test === \"function\") {\n\t\t\tif (test.length !== 1) {\n\t\t\t\treturn test(module, module.getChunks());\n\t\t\t}\n\t\t\treturn test(module);\n\t\t}\n\t\tif (typeof test === \"boolean\") return test;\n\t\tif (typeof test === \"string\") {\n\t\t\tif (\n\t\t\t\tmodule.nameForCondition &&\n\t\t\t\tmodule.nameForCondition().startsWith(test)\n\t\t\t) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfor (const chunk of module.chunksIterable) {\n\t\t\t\tif (chunk.name && chunk.name.startsWith(test)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tif (test instanceof RegExp) {\n\t\t\tif (module.nameForCondition && test.test(module.nameForCondition())) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfor (const chunk of module.chunksIterable) {\n\t\t\t\tif (chunk.name && test.test(chunk.name)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * @param {Compiler} compiler webpack compiler\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tcompiler.hooks.thisCompilation.tap(\"SplitChunksPlugin\", compilation => {\n\t\t\tlet alreadyOptimized = false;\n\t\t\tcompilation.hooks.unseal.tap(\"SplitChunksPlugin\", () => {\n\t\t\t\talreadyOptimized = false;\n\t\t\t});\n\t\t\tcompilation.hooks.optimizeChunksAdvanced.tap(\n\t\t\t\t\"SplitChunksPlugin\",\n\t\t\t\tchunks => {\n\t\t\t\t\tif (alreadyOptimized) return;\n\t\t\t\t\talreadyOptimized = true;\n\t\t\t\t\t// Give each selected chunk an index (to create strings from chunks)\n\t\t\t\t\tconst indexMap = new Map();\n\t\t\t\t\tlet index = 1;\n\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\tindexMap.set(chunk, index++);\n\t\t\t\t\t}\n\t\t\t\t\tconst getKey = chunks => {\n\t\t\t\t\t\treturn Array.from(chunks, c => indexMap.get(c))\n\t\t\t\t\t\t\t.sort(compareNumbers)\n\t\t\t\t\t\t\t.join();\n\t\t\t\t\t};\n\t\t\t\t\t/** @type {Map<string, Set<Chunk>>} */\n\t\t\t\t\tconst chunkSetsInGraph = new Map();\n\t\t\t\t\tfor (const module of compilation.modules) {\n\t\t\t\t\t\tconst chunksKey = getKey(module.chunksIterable);\n\t\t\t\t\t\tif (!chunkSetsInGraph.has(chunksKey)) {\n\t\t\t\t\t\t\tchunkSetsInGraph.set(chunksKey, new Set(module.chunksIterable));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// group these set of chunks by count\n\t\t\t\t\t// to allow to check less sets via isSubset\n\t\t\t\t\t// (only smaller sets can be subset)\n\t\t\t\t\t/** @type {Map<number, Array<Set<Chunk>>>} */\n\t\t\t\t\tconst chunkSetsByCount = new Map();\n\t\t\t\t\tfor (const chunksSet of chunkSetsInGraph.values()) {\n\t\t\t\t\t\tconst count = chunksSet.size;\n\t\t\t\t\t\tlet array = chunkSetsByCount.get(count);\n\t\t\t\t\t\tif (array === undefined) {\n\t\t\t\t\t\t\tarray = [];\n\t\t\t\t\t\t\tchunkSetsByCount.set(count, array);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tarray.push(chunksSet);\n\t\t\t\t\t}\n\n\t\t\t\t\t// Create a list of possible combinations\n\t\t\t\t\tconst combinationsCache = new Map(); // Map<string, Set<Chunk>[]>\n\n\t\t\t\t\tconst getCombinations = key => {\n\t\t\t\t\t\tconst chunksSet = chunkSetsInGraph.get(key);\n\t\t\t\t\t\tvar array = [chunksSet];\n\t\t\t\t\t\tif (chunksSet.size > 1) {\n\t\t\t\t\t\t\tfor (const [count, setArray] of chunkSetsByCount) {\n\t\t\t\t\t\t\t\t// \"equal\" is not needed because they would have been merge in the first step\n\t\t\t\t\t\t\t\tif (count < chunksSet.size) {\n\t\t\t\t\t\t\t\t\tfor (const set of setArray) {\n\t\t\t\t\t\t\t\t\t\tif (isSubset(chunksSet, set)) {\n\t\t\t\t\t\t\t\t\t\t\tarray.push(set);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn array;\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @typedef {Object} SelectedChunksResult\n\t\t\t\t\t * @property {Chunk[]} chunks the list of chunks\n\t\t\t\t\t * @property {string} key a key of the list\n\t\t\t\t\t */\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @typedef {function(Chunk): boolean} ChunkFilterFunction\n\t\t\t\t\t */\n\n\t\t\t\t\t/** @type {WeakMap<Set<Chunk>, WeakMap<ChunkFilterFunction, SelectedChunksResult>>} */\n\t\t\t\t\tconst selectedChunksCacheByChunksSet = new WeakMap();\n\n\t\t\t\t\t/**\n\t\t\t\t\t * get list and key by applying the filter function to the list\n\t\t\t\t\t * It is cached for performance reasons\n\t\t\t\t\t * @param {Set<Chunk>} chunks list of chunks\n\t\t\t\t\t * @param {ChunkFilterFunction} chunkFilter filter function for chunks\n\t\t\t\t\t * @returns {SelectedChunksResult} list and key\n\t\t\t\t\t */\n\t\t\t\t\tconst getSelectedChunks = (chunks, chunkFilter) => {\n\t\t\t\t\t\tlet entry = selectedChunksCacheByChunksSet.get(chunks);\n\t\t\t\t\t\tif (entry === undefined) {\n\t\t\t\t\t\t\tentry = new WeakMap();\n\t\t\t\t\t\t\tselectedChunksCacheByChunksSet.set(chunks, entry);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/** @type {SelectedChunksResult} */\n\t\t\t\t\t\tlet entry2 = entry.get(chunkFilter);\n\t\t\t\t\t\tif (entry2 === undefined) {\n\t\t\t\t\t\t\t/** @type {Chunk[]} */\n\t\t\t\t\t\t\tconst selectedChunks = [];\n\t\t\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\t\t\tif (chunkFilter(chunk)) selectedChunks.push(chunk);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tentry2 = {\n\t\t\t\t\t\t\t\tchunks: selectedChunks,\n\t\t\t\t\t\t\t\tkey: getKey(selectedChunks)\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tentry.set(chunkFilter, entry2);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn entry2;\n\t\t\t\t\t};\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @typedef {Object} ChunksInfoItem\n\t\t\t\t\t * @property {SortableSet} modules\n\t\t\t\t\t * @property {TODO} cacheGroup\n\t\t\t\t\t * @property {string} name\n\t\t\t\t\t * @property {boolean} validateSize\n\t\t\t\t\t * @property {number} size\n\t\t\t\t\t * @property {Set<Chunk>} chunks\n\t\t\t\t\t * @property {Set<Chunk>} reuseableChunks\n\t\t\t\t\t * @property {Set<string>} chunksKeys\n\t\t\t\t\t */\n\n\t\t\t\t\t// Map a list of chunks to a list of modules\n\t\t\t\t\t// For the key the chunk \"index\" is used, the value is a SortableSet of modules\n\t\t\t\t\t/** @type {Map<string, ChunksInfoItem>} */\n\t\t\t\t\tconst chunksInfoMap = new Map();\n\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {TODO} cacheGroup the current cache group\n\t\t\t\t\t * @param {Chunk[]} selectedChunks chunks selected for this module\n\t\t\t\t\t * @param {string} selectedChunksKey a key of selectedChunks\n\t\t\t\t\t * @param {Module} module the current module\n\t\t\t\t\t * @returns {void}\n\t\t\t\t\t */\n\t\t\t\t\tconst addModuleToChunksInfoMap = (\n\t\t\t\t\t\tcacheGroup,\n\t\t\t\t\t\tselectedChunks,\n\t\t\t\t\t\tselectedChunksKey,\n\t\t\t\t\t\tmodule\n\t\t\t\t\t) => {\n\t\t\t\t\t\t// Break if minimum number of chunks is not reached\n\t\t\t\t\t\tif (selectedChunks.length < cacheGroup.minChunks) return;\n\t\t\t\t\t\t// Determine name for split chunk\n\t\t\t\t\t\tconst name = cacheGroup.getName(\n\t\t\t\t\t\t\tmodule,\n\t\t\t\t\t\t\tselectedChunks,\n\t\t\t\t\t\t\tcacheGroup.key\n\t\t\t\t\t\t);\n\t\t\t\t\t\t// Create key for maps\n\t\t\t\t\t\t// When it has a name we use the name as key\n\t\t\t\t\t\t// Elsewise we create the key from chunks and cache group key\n\t\t\t\t\t\t// This automatically merges equal names\n\t\t\t\t\t\tconst key =\n\t\t\t\t\t\t\tcacheGroup.key +\n\t\t\t\t\t\t\t(name ? ` name:${name}` : ` chunks:${selectedChunksKey}`);\n\t\t\t\t\t\t// Add module to maps\n\t\t\t\t\t\tlet info = chunksInfoMap.get(key);\n\t\t\t\t\t\tif (info === undefined) {\n\t\t\t\t\t\t\tchunksInfoMap.set(\n\t\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\t\t(info = {\n\t\t\t\t\t\t\t\t\tmodules: new SortableSet(undefined, sortByIdentifier),\n\t\t\t\t\t\t\t\t\tcacheGroup,\n\t\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\t\tvalidateSize: cacheGroup.minSize > 0,\n\t\t\t\t\t\t\t\t\tsize: 0,\n\t\t\t\t\t\t\t\t\tchunks: new Set(),\n\t\t\t\t\t\t\t\t\treuseableChunks: new Set(),\n\t\t\t\t\t\t\t\t\tchunksKeys: new Set()\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinfo.modules.add(module);\n\t\t\t\t\t\tif (info.validateSize) {\n\t\t\t\t\t\t\tinfo.size += module.size();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!info.chunksKeys.has(selectedChunksKey)) {\n\t\t\t\t\t\t\tinfo.chunksKeys.add(selectedChunksKey);\n\t\t\t\t\t\t\tfor (const chunk of selectedChunks) {\n\t\t\t\t\t\t\t\tinfo.chunks.add(chunk);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t// Walk through all modules\n\t\t\t\t\tfor (const module of compilation.modules) {\n\t\t\t\t\t\t// Get cache group\n\t\t\t\t\t\tlet cacheGroups = this.options.getCacheGroups(module);\n\t\t\t\t\t\tif (!Array.isArray(cacheGroups) || cacheGroups.length === 0) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Prepare some values\n\t\t\t\t\t\tconst chunksKey = getKey(module.chunksIterable);\n\t\t\t\t\t\tlet combs = combinationsCache.get(chunksKey);\n\t\t\t\t\t\tif (combs === undefined) {\n\t\t\t\t\t\t\tcombs = getCombinations(chunksKey);\n\t\t\t\t\t\t\tcombinationsCache.set(chunksKey, combs);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (const cacheGroupSource of cacheGroups) {\n\t\t\t\t\t\t\tconst cacheGroup = {\n\t\t\t\t\t\t\t\tkey: cacheGroupSource.key,\n\t\t\t\t\t\t\t\tpriority: cacheGroupSource.priority || 0,\n\t\t\t\t\t\t\t\tchunksFilter:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.chunksFilter || this.options.chunksFilter,\n\t\t\t\t\t\t\t\tminSize:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.minSize !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.minSize\n\t\t\t\t\t\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t\t\t\t\t\t? 0\n\t\t\t\t\t\t\t\t\t\t: this.options.minSize,\n\t\t\t\t\t\t\t\tminSizeForMaxSize:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.minSize !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.minSize\n\t\t\t\t\t\t\t\t\t\t: this.options.minSize,\n\t\t\t\t\t\t\t\tmaxSize:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.maxSize !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.maxSize\n\t\t\t\t\t\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t\t\t\t\t\t? 0\n\t\t\t\t\t\t\t\t\t\t: this.options.maxSize,\n\t\t\t\t\t\t\t\tminChunks:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.minChunks !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.minChunks\n\t\t\t\t\t\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t\t\t\t\t\t? 1\n\t\t\t\t\t\t\t\t\t\t: this.options.minChunks,\n\t\t\t\t\t\t\t\tmaxAsyncRequests:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.maxAsyncRequests !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.maxAsyncRequests\n\t\t\t\t\t\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t\t\t\t\t\t? Infinity\n\t\t\t\t\t\t\t\t\t\t: this.options.maxAsyncRequests,\n\t\t\t\t\t\t\t\tmaxInitialRequests:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.maxInitialRequests !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.maxInitialRequests\n\t\t\t\t\t\t\t\t\t\t: cacheGroupSource.enforce\n\t\t\t\t\t\t\t\t\t\t? Infinity\n\t\t\t\t\t\t\t\t\t\t: this.options.maxInitialRequests,\n\t\t\t\t\t\t\t\tgetName:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.getName !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.getName\n\t\t\t\t\t\t\t\t\t\t: this.options.getName,\n\t\t\t\t\t\t\t\tfilename:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.filename !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.filename\n\t\t\t\t\t\t\t\t\t\t: this.options.filename,\n\t\t\t\t\t\t\t\tautomaticNameDelimiter:\n\t\t\t\t\t\t\t\t\tcacheGroupSource.automaticNameDelimiter !== undefined\n\t\t\t\t\t\t\t\t\t\t? cacheGroupSource.automaticNameDelimiter\n\t\t\t\t\t\t\t\t\t\t: this.options.automaticNameDelimiter,\n\t\t\t\t\t\t\t\treuseExistingChunk: cacheGroupSource.reuseExistingChunk\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t// For all combination of chunk selection\n\t\t\t\t\t\t\tfor (const chunkCombination of combs) {\n\t\t\t\t\t\t\t\t// Break if minimum number of chunks is not reached\n\t\t\t\t\t\t\t\tif (chunkCombination.size < cacheGroup.minChunks) continue;\n\t\t\t\t\t\t\t\t// Select chunks by configuration\n\t\t\t\t\t\t\t\tconst {\n\t\t\t\t\t\t\t\t\tchunks: selectedChunks,\n\t\t\t\t\t\t\t\t\tkey: selectedChunksKey\n\t\t\t\t\t\t\t\t} = getSelectedChunks(\n\t\t\t\t\t\t\t\t\tchunkCombination,\n\t\t\t\t\t\t\t\t\tcacheGroup.chunksFilter\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\taddModuleToChunksInfoMap(\n\t\t\t\t\t\t\t\t\tcacheGroup,\n\t\t\t\t\t\t\t\t\tselectedChunks,\n\t\t\t\t\t\t\t\t\tselectedChunksKey,\n\t\t\t\t\t\t\t\t\tmodule\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Filter items were size < minSize\n\t\t\t\t\tfor (const pair of chunksInfoMap) {\n\t\t\t\t\t\tconst info = pair[1];\n\t\t\t\t\t\tif (info.validateSize && info.size < info.cacheGroup.minSize) {\n\t\t\t\t\t\t\tchunksInfoMap.delete(pair[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t/** @type {Map<Chunk, {minSize: number, maxSize: number, automaticNameDelimiter: string, keys: string[]}>} */\n\t\t\t\t\tconst maxSizeQueueMap = new Map();\n\n\t\t\t\t\twhile (chunksInfoMap.size > 0) {\n\t\t\t\t\t\t// Find best matching entry\n\t\t\t\t\t\tlet bestEntryKey;\n\t\t\t\t\t\tlet bestEntry;\n\t\t\t\t\t\tfor (const pair of chunksInfoMap) {\n\t\t\t\t\t\t\tconst key = pair[0];\n\t\t\t\t\t\t\tconst info = pair[1];\n\t\t\t\t\t\t\tif (bestEntry === undefined) {\n\t\t\t\t\t\t\t\tbestEntry = info;\n\t\t\t\t\t\t\t\tbestEntryKey = key;\n\t\t\t\t\t\t\t} else if (compareEntries(bestEntry, info) < 0) {\n\t\t\t\t\t\t\t\tbestEntry = info;\n\t\t\t\t\t\t\t\tbestEntryKey = key;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst item = bestEntry;\n\t\t\t\t\t\tchunksInfoMap.delete(bestEntryKey);\n\n\t\t\t\t\t\tlet chunkName = item.name;\n\t\t\t\t\t\t// Variable for the new chunk (lazy created)\n\t\t\t\t\t\t/** @type {Chunk} */\n\t\t\t\t\t\tlet newChunk;\n\t\t\t\t\t\t// When no chunk name, check if we can reuse a chunk instead of creating a new one\n\t\t\t\t\t\tlet isReused = false;\n\t\t\t\t\t\tif (item.cacheGroup.reuseExistingChunk) {\n\t\t\t\t\t\t\touter: for (const chunk of item.chunks) {\n\t\t\t\t\t\t\t\tif (chunk.getNumberOfModules() !== item.modules.size) continue;\n\t\t\t\t\t\t\t\tif (chunk.hasEntryModule()) continue;\n\t\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\t\tif (!chunk.containsModule(module)) continue outer;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (!newChunk || !newChunk.name) {\n\t\t\t\t\t\t\t\t\tnewChunk = chunk;\n\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\tchunk.name &&\n\t\t\t\t\t\t\t\t\tchunk.name.length < newChunk.name.length\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tnewChunk = chunk;\n\t\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\t\tchunk.name &&\n\t\t\t\t\t\t\t\t\tchunk.name.length === newChunk.name.length &&\n\t\t\t\t\t\t\t\t\tchunk.name < newChunk.name\n\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\tnewChunk = chunk;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tchunkName = undefined;\n\t\t\t\t\t\t\t\tisReused = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Check if maxRequests condition can be fulfilled\n\n\t\t\t\t\t\tconst usedChunks = Array.from(item.chunks).filter(chunk => {\n\t\t\t\t\t\t\t// skip if we address ourself\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t(!chunkName || chunk.name !== chunkName) && chunk !== newChunk\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t// Skip when no chunk selected\n\t\t\t\t\t\tif (usedChunks.length === 0) continue;\n\n\t\t\t\t\t\tlet validChunks = usedChunks;\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tNumber.isFinite(item.cacheGroup.maxInitialRequests) ||\n\t\t\t\t\t\t\tNumber.isFinite(item.cacheGroup.maxAsyncRequests)\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tvalidChunks = validChunks.filter(chunk => {\n\t\t\t\t\t\t\t\t// respect max requests when not enforced\n\t\t\t\t\t\t\t\tconst maxRequests = chunk.isOnlyInitial()\n\t\t\t\t\t\t\t\t\t? item.cacheGroup.maxInitialRequests\n\t\t\t\t\t\t\t\t\t: chunk.canBeInitial()\n\t\t\t\t\t\t\t\t\t? Math.min(\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup.maxInitialRequests,\n\t\t\t\t\t\t\t\t\t\t\titem.cacheGroup.maxAsyncRequests\n\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t: item.cacheGroup.maxAsyncRequests;\n\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t!isFinite(maxRequests) || getRequests(chunk) < maxRequests\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvalidChunks = validChunks.filter(chunk => {\n\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\tif (chunk.containsModule(module)) return true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tif (validChunks.length < usedChunks.length) {\n\t\t\t\t\t\t\tif (validChunks.length >= item.cacheGroup.minChunks) {\n\t\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\t\taddModuleToChunksInfoMap(\n\t\t\t\t\t\t\t\t\t\titem.cacheGroup,\n\t\t\t\t\t\t\t\t\t\tvalidChunks,\n\t\t\t\t\t\t\t\t\t\tgetKey(validChunks),\n\t\t\t\t\t\t\t\t\t\tmodule\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Create the new chunk if not reusing one\n\t\t\t\t\t\tif (!isReused) {\n\t\t\t\t\t\t\tnewChunk = compilation.addChunk(chunkName);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Walk through all chunks\n\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t// Add graph connections for splitted chunk\n\t\t\t\t\t\t\tchunk.split(newChunk);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Add a note to the chunk\n\t\t\t\t\t\tnewChunk.chunkReason = isReused\n\t\t\t\t\t\t\t? \"reused as split chunk\"\n\t\t\t\t\t\t\t: \"split chunk\";\n\t\t\t\t\t\tif (item.cacheGroup.key) {\n\t\t\t\t\t\t\tnewChunk.chunkReason += ` (cache group: ${item.cacheGroup.key})`;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (chunkName) {\n\t\t\t\t\t\t\tnewChunk.chunkReason += ` (name: ${chunkName})`;\n\t\t\t\t\t\t\t// If the chosen name is already an entry point we remove the entry point\n\t\t\t\t\t\t\tconst entrypoint = compilation.entrypoints.get(chunkName);\n\t\t\t\t\t\t\tif (entrypoint) {\n\t\t\t\t\t\t\t\tcompilation.entrypoints.delete(chunkName);\n\t\t\t\t\t\t\t\tentrypoint.remove();\n\t\t\t\t\t\t\t\tnewChunk.entryModule = undefined;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (item.cacheGroup.filename) {\n\t\t\t\t\t\t\tif (!newChunk.isOnlyInitial()) {\n\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t\"SplitChunksPlugin: You are trying to set a filename for a chunk which is (also) loaded on demand. \" +\n\t\t\t\t\t\t\t\t\t\t\"The runtime can only handle loading of chunks which match the chunkFilename schema. \" +\n\t\t\t\t\t\t\t\t\t\t\"Using a custom filename would fail at runtime. \" +\n\t\t\t\t\t\t\t\t\t\t`(cache group: ${item.cacheGroup.key})`\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tnewChunk.filenameTemplate = item.cacheGroup.filename;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!isReused) {\n\t\t\t\t\t\t\t// Add all modules to the new chunk\n\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\tif (typeof module.chunkCondition === \"function\") {\n\t\t\t\t\t\t\t\t\tif (!module.chunkCondition(newChunk)) continue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Add module to new chunk\n\t\t\t\t\t\t\t\tGraphHelpers.connectChunkAndModule(newChunk, module);\n\t\t\t\t\t\t\t\t// Remove module from used chunks\n\t\t\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t\t\tchunk.removeModule(module);\n\t\t\t\t\t\t\t\t\tmodule.rewriteChunkInReasons(chunk, [newChunk]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Remove all modules from used chunks\n\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\tfor (const chunk of usedChunks) {\n\t\t\t\t\t\t\t\t\tchunk.removeModule(module);\n\t\t\t\t\t\t\t\t\tmodule.rewriteChunkInReasons(chunk, [newChunk]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (item.cacheGroup.maxSize > 0) {\n\t\t\t\t\t\t\tconst oldMaxSizeSettings = maxSizeQueueMap.get(newChunk);\n\t\t\t\t\t\t\tmaxSizeQueueMap.set(newChunk, {\n\t\t\t\t\t\t\t\tminSize: Math.max(\n\t\t\t\t\t\t\t\t\toldMaxSizeSettings ? oldMaxSizeSettings.minSize : 0,\n\t\t\t\t\t\t\t\t\titem.cacheGroup.minSizeForMaxSize\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\tmaxSize: Math.min(\n\t\t\t\t\t\t\t\t\toldMaxSizeSettings ? oldMaxSizeSettings.maxSize : Infinity,\n\t\t\t\t\t\t\t\t\titem.cacheGroup.maxSize\n\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t\tautomaticNameDelimiter: item.cacheGroup.automaticNameDelimiter,\n\t\t\t\t\t\t\t\tkeys: oldMaxSizeSettings\n\t\t\t\t\t\t\t\t\t? oldMaxSizeSettings.keys.concat(item.cacheGroup.key)\n\t\t\t\t\t\t\t\t\t: [item.cacheGroup.key]\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// remove all modules from other entries and update size\n\t\t\t\t\t\tfor (const [key, info] of chunksInfoMap) {\n\t\t\t\t\t\t\tif (isOverlap(info.chunks, item.chunks)) {\n\t\t\t\t\t\t\t\tif (info.validateSize) {\n\t\t\t\t\t\t\t\t\t// update modules and total size\n\t\t\t\t\t\t\t\t\t// may remove it from the map when < minSize\n\t\t\t\t\t\t\t\t\tconst oldSize = info.modules.size;\n\t\t\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\t\t\tinfo.modules.delete(module);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (info.modules.size === 0) {\n\t\t\t\t\t\t\t\t\t\tchunksInfoMap.delete(key);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (info.modules.size !== oldSize) {\n\t\t\t\t\t\t\t\t\t\tinfo.size = getModulesSize(info.modules);\n\t\t\t\t\t\t\t\t\t\tif (info.size < info.cacheGroup.minSize) {\n\t\t\t\t\t\t\t\t\t\t\tchunksInfoMap.delete(key);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// only update the modules\n\t\t\t\t\t\t\t\t\tfor (const module of item.modules) {\n\t\t\t\t\t\t\t\t\t\tinfo.modules.delete(module);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (info.modules.size === 0) {\n\t\t\t\t\t\t\t\t\t\tchunksInfoMap.delete(key);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst incorrectMinMaxSizeSet = new Set();\n\n\t\t\t\t\t// Make sure that maxSize is fulfilled\n\t\t\t\t\tfor (const chunk of compilation.chunks.slice()) {\n\t\t\t\t\t\tconst { minSize, maxSize, automaticNameDelimiter, keys } =\n\t\t\t\t\t\t\tmaxSizeQueueMap.get(chunk) || this.options.fallbackCacheGroup;\n\t\t\t\t\t\tif (!maxSize) continue;\n\t\t\t\t\t\tif (minSize > maxSize) {\n\t\t\t\t\t\t\tconst warningKey = `${keys && keys.join()} ${minSize} ${maxSize}`;\n\t\t\t\t\t\t\tif (!incorrectMinMaxSizeSet.has(warningKey)) {\n\t\t\t\t\t\t\t\tincorrectMinMaxSizeSet.add(warningKey);\n\t\t\t\t\t\t\t\tcompilation.warnings.push(\n\t\t\t\t\t\t\t\t\tnew MinMaxSizeWarning(keys, minSize, maxSize)\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst results = deterministicGroupingForModules({\n\t\t\t\t\t\t\tmaxSize: Math.max(minSize, maxSize),\n\t\t\t\t\t\t\tminSize,\n\t\t\t\t\t\t\titems: chunk.modulesIterable,\n\t\t\t\t\t\t\tgetKey(module) {\n\t\t\t\t\t\t\t\tconst ident = contextify(\n\t\t\t\t\t\t\t\t\tcompilation.options.context,\n\t\t\t\t\t\t\t\t\tmodule.identifier()\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tconst name = module.nameForCondition\n\t\t\t\t\t\t\t\t\t? contextify(\n\t\t\t\t\t\t\t\t\t\t\tcompilation.options.context,\n\t\t\t\t\t\t\t\t\t\t\tmodule.nameForCondition()\n\t\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t\t: ident.replace(/^.*!|\\?[^?!]*$/g, \"\");\n\t\t\t\t\t\t\t\tconst fullKey =\n\t\t\t\t\t\t\t\t\tname + automaticNameDelimiter + hashFilename(ident);\n\t\t\t\t\t\t\t\treturn fullKey.replace(/[\\\\/?]/g, \"_\");\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tgetSize(module) {\n\t\t\t\t\t\t\t\treturn module.size();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t\tresults.sort((a, b) => {\n\t\t\t\t\t\t\tif (a.key < b.key) return -1;\n\t\t\t\t\t\t\tif (a.key > b.key) return 1;\n\t\t\t\t\t\t\treturn 0;\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfor (let i = 0; i < results.length; i++) {\n\t\t\t\t\t\t\tconst group = results[i];\n\t\t\t\t\t\t\tconst key = this.options.hidePathInfo\n\t\t\t\t\t\t\t\t? hashFilename(group.key)\n\t\t\t\t\t\t\t\t: group.key;\n\t\t\t\t\t\t\tlet name = chunk.name\n\t\t\t\t\t\t\t\t? chunk.name + automaticNameDelimiter + key\n\t\t\t\t\t\t\t\t: null;\n\t\t\t\t\t\t\tif (name && name.length > 100) {\n\t\t\t\t\t\t\t\tname =\n\t\t\t\t\t\t\t\t\tname.slice(0, 100) +\n\t\t\t\t\t\t\t\t\tautomaticNameDelimiter +\n\t\t\t\t\t\t\t\t\thashFilename(name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet newPart;\n\t\t\t\t\t\t\tif (i !== results.length - 1) {\n\t\t\t\t\t\t\t\tnewPart = compilation.addChunk(name);\n\t\t\t\t\t\t\t\tchunk.split(newPart);\n\t\t\t\t\t\t\t\tnewPart.chunkReason = chunk.chunkReason;\n\t\t\t\t\t\t\t\t// Add all modules to the new chunk\n\t\t\t\t\t\t\t\tfor (const module of group.items) {\n\t\t\t\t\t\t\t\t\tif (typeof module.chunkCondition === \"function\") {\n\t\t\t\t\t\t\t\t\t\tif (!module.chunkCondition(newPart)) continue;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Add module to new chunk\n\t\t\t\t\t\t\t\t\tGraphHelpers.connectChunkAndModule(newPart, module);\n\t\t\t\t\t\t\t\t\t// Remove module from used chunks\n\t\t\t\t\t\t\t\t\tchunk.removeModule(module);\n\t\t\t\t\t\t\t\t\tmodule.rewriteChunkInReasons(chunk, [newPart]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// change the chunk to be a part\n\t\t\t\t\t\t\t\tnewPart = chunk;\n\t\t\t\t\t\t\t\tchunk.name = name;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}