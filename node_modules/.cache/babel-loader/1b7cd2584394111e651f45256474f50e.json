{"ast":null,"code":"module.exports = rimraf;\nrimraf.sync = rimrafSync;\n\nvar assert = require(\"assert\");\n\nvar path = require(\"path\");\n\nvar fs = require(\"fs\");\n\nvar glob = require(\"glob\");\n\nvar _0666 = parseInt('666', 8);\n\nvar defaultGlobOpts = {\n  nosort: true,\n  silent: true\n}; // for EMFILE handling\n\nvar timeout = 0;\nvar isWindows = process.platform === \"win32\";\n\nfunction defaults(options) {\n  var methods = ['unlink', 'chmod', 'stat', 'lstat', 'rmdir', 'readdir'];\n  methods.forEach(function (m) {\n    options[m] = options[m] || fs[m];\n    m = m + 'Sync';\n    options[m] = options[m] || fs[m];\n  });\n  options.maxBusyTries = options.maxBusyTries || 3;\n  options.emfileWait = options.emfileWait || 1000;\n\n  if (options.glob === false) {\n    options.disableGlob = true;\n  }\n\n  options.disableGlob = options.disableGlob || false;\n  options.glob = options.glob || defaultGlobOpts;\n}\n\nfunction rimraf(p, options, cb) {\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  assert(p, 'rimraf: missing path');\n  assert.equal(typeof p, 'string', 'rimraf: path should be a string');\n  assert.equal(typeof cb, 'function', 'rimraf: callback function required');\n  assert(options, 'rimraf: invalid options argument provided');\n  assert.equal(typeof options, 'object', 'rimraf: options should be object');\n  defaults(options);\n  var busyTries = 0;\n  var errState = null;\n  var n = 0;\n  if (options.disableGlob || !glob.hasMagic(p)) return afterGlob(null, [p]);\n  options.lstat(p, function (er, stat) {\n    if (!er) return afterGlob(null, [p]);\n    glob(p, options.glob, afterGlob);\n  });\n\n  function next(er) {\n    errState = errState || er;\n    if (--n === 0) cb(errState);\n  }\n\n  function afterGlob(er, results) {\n    if (er) return cb(er);\n    n = results.length;\n    if (n === 0) return cb();\n    results.forEach(function (p) {\n      rimraf_(p, options, function CB(er) {\n        if (er) {\n          if ((er.code === \"EBUSY\" || er.code === \"ENOTEMPTY\" || er.code === \"EPERM\") && busyTries < options.maxBusyTries) {\n            busyTries++;\n            var time = busyTries * 100; // try again, with the same exact callback as this one.\n\n            return setTimeout(function () {\n              rimraf_(p, options, CB);\n            }, time);\n          } // this one won't happen if graceful-fs is used.\n\n\n          if (er.code === \"EMFILE\" && timeout < options.emfileWait) {\n            return setTimeout(function () {\n              rimraf_(p, options, CB);\n            }, timeout++);\n          } // already gone\n\n\n          if (er.code === \"ENOENT\") er = null;\n        }\n\n        timeout = 0;\n        next(er);\n      });\n    });\n  }\n} // Two possible strategies.\n// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR\n// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR\n//\n// Both result in an extra syscall when you guess wrong.  However, there\n// are likely far more normal files in the world than directories.  This\n// is based on the assumption that a the average number of files per\n// directory is >= 1.\n//\n// If anyone ever complains about this, then I guess the strategy could\n// be made configurable somehow.  But until then, YAGNI.\n\n\nfunction rimraf_(p, options, cb) {\n  assert(p);\n  assert(options);\n  assert(typeof cb === 'function'); // sunos lets the root user unlink directories, which is... weird.\n  // so we have to lstat here and make sure it's not a dir.\n\n  options.lstat(p, function (er, st) {\n    if (er && er.code === \"ENOENT\") return cb(null); // Windows can EPERM on stat.  Life is suffering.\n\n    if (er && er.code === \"EPERM\" && isWindows) fixWinEPERM(p, options, er, cb);\n    if (st && st.isDirectory()) return rmdir(p, options, er, cb);\n    options.unlink(p, function (er) {\n      if (er) {\n        if (er.code === \"ENOENT\") return cb(null);\n        if (er.code === \"EPERM\") return isWindows ? fixWinEPERM(p, options, er, cb) : rmdir(p, options, er, cb);\n        if (er.code === \"EISDIR\") return rmdir(p, options, er, cb);\n      }\n\n      return cb(er);\n    });\n  });\n}\n\nfunction fixWinEPERM(p, options, er, cb) {\n  assert(p);\n  assert(options);\n  assert(typeof cb === 'function');\n  if (er) assert(er instanceof Error);\n  options.chmod(p, _0666, function (er2) {\n    if (er2) cb(er2.code === \"ENOENT\" ? null : er);else options.stat(p, function (er3, stats) {\n      if (er3) cb(er3.code === \"ENOENT\" ? null : er);else if (stats.isDirectory()) rmdir(p, options, er, cb);else options.unlink(p, cb);\n    });\n  });\n}\n\nfunction fixWinEPERMSync(p, options, er) {\n  assert(p);\n  assert(options);\n  if (er) assert(er instanceof Error);\n\n  try {\n    options.chmodSync(p, _0666);\n  } catch (er2) {\n    if (er2.code === \"ENOENT\") return;else throw er;\n  }\n\n  try {\n    var stats = options.statSync(p);\n  } catch (er3) {\n    if (er3.code === \"ENOENT\") return;else throw er;\n  }\n\n  if (stats.isDirectory()) rmdirSync(p, options, er);else options.unlinkSync(p);\n}\n\nfunction rmdir(p, options, originalEr, cb) {\n  assert(p);\n  assert(options);\n  if (originalEr) assert(originalEr instanceof Error);\n  assert(typeof cb === 'function'); // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)\n  // if we guessed wrong, and it's not a directory, then\n  // raise the original error.\n\n  options.rmdir(p, function (er) {\n    if (er && (er.code === \"ENOTEMPTY\" || er.code === \"EEXIST\" || er.code === \"EPERM\")) rmkids(p, options, cb);else if (er && er.code === \"ENOTDIR\") cb(originalEr);else cb(er);\n  });\n}\n\nfunction rmkids(p, options, cb) {\n  assert(p);\n  assert(options);\n  assert(typeof cb === 'function');\n  options.readdir(p, function (er, files) {\n    if (er) return cb(er);\n    var n = files.length;\n    if (n === 0) return options.rmdir(p, cb);\n    var errState;\n    files.forEach(function (f) {\n      rimraf(path.join(p, f), options, function (er) {\n        if (errState) return;\n        if (er) return cb(errState = er);\n        if (--n === 0) options.rmdir(p, cb);\n      });\n    });\n  });\n} // this looks simpler, and is strictly *faster*, but will\n// tie up the JavaScript thread and fail on excessively\n// deep directory trees.\n\n\nfunction rimrafSync(p, options) {\n  options = options || {};\n  defaults(options);\n  assert(p, 'rimraf: missing path');\n  assert.equal(typeof p, 'string', 'rimraf: path should be a string');\n  assert(options, 'rimraf: missing options');\n  assert.equal(typeof options, 'object', 'rimraf: options should be object');\n  var results;\n\n  if (options.disableGlob || !glob.hasMagic(p)) {\n    results = [p];\n  } else {\n    try {\n      options.lstatSync(p);\n      results = [p];\n    } catch (er) {\n      results = glob.sync(p, options.glob);\n    }\n  }\n\n  if (!results.length) return;\n\n  for (var i = 0; i < results.length; i++) {\n    var p = results[i];\n\n    try {\n      var st = options.lstatSync(p);\n    } catch (er) {\n      if (er.code === \"ENOENT\") return; // Windows can EPERM on stat.  Life is suffering.\n\n      if (er.code === \"EPERM\" && isWindows) fixWinEPERMSync(p, options, er);\n    }\n\n    try {\n      // sunos lets the root user unlink directories, which is... weird.\n      if (st && st.isDirectory()) rmdirSync(p, options, null);else options.unlinkSync(p);\n    } catch (er) {\n      if (er.code === \"ENOENT\") return;\n      if (er.code === \"EPERM\") return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);\n      if (er.code !== \"EISDIR\") throw er;\n      rmdirSync(p, options, er);\n    }\n  }\n}\n\nfunction rmdirSync(p, options, originalEr) {\n  assert(p);\n  assert(options);\n  if (originalEr) assert(originalEr instanceof Error);\n\n  try {\n    options.rmdirSync(p);\n  } catch (er) {\n    if (er.code === \"ENOENT\") return;\n    if (er.code === \"ENOTDIR\") throw originalEr;\n    if (er.code === \"ENOTEMPTY\" || er.code === \"EEXIST\" || er.code === \"EPERM\") rmkidsSync(p, options);\n  }\n}\n\nfunction rmkidsSync(p, options) {\n  assert(p);\n  assert(options);\n  options.readdirSync(p).forEach(function (f) {\n    rimrafSync(path.join(p, f), options);\n  }); // We only end up here once we got ENOTEMPTY at least once, and\n  // at this point, we are guaranteed to have removed all the kids.\n  // So, we know that it won't be ENOENT or ENOTDIR or anything else.\n  // try really hard to delete stuff on windows, because it has a\n  // PROFOUNDLY annoying habit of not closing handles promptly when\n  // files are deleted, resulting in spurious ENOTEMPTY errors.\n\n  var retries = isWindows ? 100 : 1;\n  var i = 0;\n\n  do {\n    var threw = true;\n\n    try {\n      var ret = options.rmdirSync(p, options);\n      threw = false;\n      return ret;\n    } finally {\n      if (++i < retries && threw) continue;\n    }\n  } while (true);\n}","map":{"version":3,"sources":["E:/Users/cnki/source/repos/ab29693295/MeetAdmin/node_modules/rimraf/rimraf.js"],"names":["module","exports","rimraf","sync","rimrafSync","assert","require","path","fs","glob","_0666","parseInt","defaultGlobOpts","nosort","silent","timeout","isWindows","process","platform","defaults","options","methods","forEach","m","maxBusyTries","emfileWait","disableGlob","p","cb","equal","busyTries","errState","n","hasMagic","afterGlob","lstat","er","stat","next","results","length","rimraf_","CB","code","time","setTimeout","st","fixWinEPERM","isDirectory","rmdir","unlink","Error","chmod","er2","er3","stats","fixWinEPERMSync","chmodSync","statSync","rmdirSync","unlinkSync","originalEr","rmkids","readdir","files","f","join","lstatSync","i","rmkidsSync","readdirSync","retries","threw","ret"],"mappings":"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","sourcesContent":["module.exports = rimraf\nrimraf.sync = rimrafSync\n\nvar assert = require(\"assert\")\nvar path = require(\"path\")\nvar fs = require(\"fs\")\nvar glob = require(\"glob\")\nvar _0666 = parseInt('666', 8)\n\nvar defaultGlobOpts = {\n  nosort: true,\n  silent: true\n}\n\n// for EMFILE handling\nvar timeout = 0\n\nvar isWindows = (process.platform === \"win32\")\n\nfunction defaults (options) {\n  var methods = [\n    'unlink',\n    'chmod',\n    'stat',\n    'lstat',\n    'rmdir',\n    'readdir'\n  ]\n  methods.forEach(function(m) {\n    options[m] = options[m] || fs[m]\n    m = m + 'Sync'\n    options[m] = options[m] || fs[m]\n  })\n\n  options.maxBusyTries = options.maxBusyTries || 3\n  options.emfileWait = options.emfileWait || 1000\n  if (options.glob === false) {\n    options.disableGlob = true\n  }\n  options.disableGlob = options.disableGlob || false\n  options.glob = options.glob || defaultGlobOpts\n}\n\nfunction rimraf (p, options, cb) {\n  if (typeof options === 'function') {\n    cb = options\n    options = {}\n  }\n\n  assert(p, 'rimraf: missing path')\n  assert.equal(typeof p, 'string', 'rimraf: path should be a string')\n  assert.equal(typeof cb, 'function', 'rimraf: callback function required')\n  assert(options, 'rimraf: invalid options argument provided')\n  assert.equal(typeof options, 'object', 'rimraf: options should be object')\n\n  defaults(options)\n\n  var busyTries = 0\n  var errState = null\n  var n = 0\n\n  if (options.disableGlob || !glob.hasMagic(p))\n    return afterGlob(null, [p])\n\n  options.lstat(p, function (er, stat) {\n    if (!er)\n      return afterGlob(null, [p])\n\n    glob(p, options.glob, afterGlob)\n  })\n\n  function next (er) {\n    errState = errState || er\n    if (--n === 0)\n      cb(errState)\n  }\n\n  function afterGlob (er, results) {\n    if (er)\n      return cb(er)\n\n    n = results.length\n    if (n === 0)\n      return cb()\n\n    results.forEach(function (p) {\n      rimraf_(p, options, function CB (er) {\n        if (er) {\n          if ((er.code === \"EBUSY\" || er.code === \"ENOTEMPTY\" || er.code === \"EPERM\") &&\n              busyTries < options.maxBusyTries) {\n            busyTries ++\n            var time = busyTries * 100\n            // try again, with the same exact callback as this one.\n            return setTimeout(function () {\n              rimraf_(p, options, CB)\n            }, time)\n          }\n\n          // this one won't happen if graceful-fs is used.\n          if (er.code === \"EMFILE\" && timeout < options.emfileWait) {\n            return setTimeout(function () {\n              rimraf_(p, options, CB)\n            }, timeout ++)\n          }\n\n          // already gone\n          if (er.code === \"ENOENT\") er = null\n        }\n\n        timeout = 0\n        next(er)\n      })\n    })\n  }\n}\n\n// Two possible strategies.\n// 1. Assume it's a file.  unlink it, then do the dir stuff on EPERM or EISDIR\n// 2. Assume it's a directory.  readdir, then do the file stuff on ENOTDIR\n//\n// Both result in an extra syscall when you guess wrong.  However, there\n// are likely far more normal files in the world than directories.  This\n// is based on the assumption that a the average number of files per\n// directory is >= 1.\n//\n// If anyone ever complains about this, then I guess the strategy could\n// be made configurable somehow.  But until then, YAGNI.\nfunction rimraf_ (p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  // sunos lets the root user unlink directories, which is... weird.\n  // so we have to lstat here and make sure it's not a dir.\n  options.lstat(p, function (er, st) {\n    if (er && er.code === \"ENOENT\")\n      return cb(null)\n\n    // Windows can EPERM on stat.  Life is suffering.\n    if (er && er.code === \"EPERM\" && isWindows)\n      fixWinEPERM(p, options, er, cb)\n\n    if (st && st.isDirectory())\n      return rmdir(p, options, er, cb)\n\n    options.unlink(p, function (er) {\n      if (er) {\n        if (er.code === \"ENOENT\")\n          return cb(null)\n        if (er.code === \"EPERM\")\n          return (isWindows)\n            ? fixWinEPERM(p, options, er, cb)\n            : rmdir(p, options, er, cb)\n        if (er.code === \"EISDIR\")\n          return rmdir(p, options, er, cb)\n      }\n      return cb(er)\n    })\n  })\n}\n\nfunction fixWinEPERM (p, options, er, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n  if (er)\n    assert(er instanceof Error)\n\n  options.chmod(p, _0666, function (er2) {\n    if (er2)\n      cb(er2.code === \"ENOENT\" ? null : er)\n    else\n      options.stat(p, function(er3, stats) {\n        if (er3)\n          cb(er3.code === \"ENOENT\" ? null : er)\n        else if (stats.isDirectory())\n          rmdir(p, options, er, cb)\n        else\n          options.unlink(p, cb)\n      })\n  })\n}\n\nfunction fixWinEPERMSync (p, options, er) {\n  assert(p)\n  assert(options)\n  if (er)\n    assert(er instanceof Error)\n\n  try {\n    options.chmodSync(p, _0666)\n  } catch (er2) {\n    if (er2.code === \"ENOENT\")\n      return\n    else\n      throw er\n  }\n\n  try {\n    var stats = options.statSync(p)\n  } catch (er3) {\n    if (er3.code === \"ENOENT\")\n      return\n    else\n      throw er\n  }\n\n  if (stats.isDirectory())\n    rmdirSync(p, options, er)\n  else\n    options.unlinkSync(p)\n}\n\nfunction rmdir (p, options, originalEr, cb) {\n  assert(p)\n  assert(options)\n  if (originalEr)\n    assert(originalEr instanceof Error)\n  assert(typeof cb === 'function')\n\n  // try to rmdir first, and only readdir on ENOTEMPTY or EEXIST (SunOS)\n  // if we guessed wrong, and it's not a directory, then\n  // raise the original error.\n  options.rmdir(p, function (er) {\n    if (er && (er.code === \"ENOTEMPTY\" || er.code === \"EEXIST\" || er.code === \"EPERM\"))\n      rmkids(p, options, cb)\n    else if (er && er.code === \"ENOTDIR\")\n      cb(originalEr)\n    else\n      cb(er)\n  })\n}\n\nfunction rmkids(p, options, cb) {\n  assert(p)\n  assert(options)\n  assert(typeof cb === 'function')\n\n  options.readdir(p, function (er, files) {\n    if (er)\n      return cb(er)\n    var n = files.length\n    if (n === 0)\n      return options.rmdir(p, cb)\n    var errState\n    files.forEach(function (f) {\n      rimraf(path.join(p, f), options, function (er) {\n        if (errState)\n          return\n        if (er)\n          return cb(errState = er)\n        if (--n === 0)\n          options.rmdir(p, cb)\n      })\n    })\n  })\n}\n\n// this looks simpler, and is strictly *faster*, but will\n// tie up the JavaScript thread and fail on excessively\n// deep directory trees.\nfunction rimrafSync (p, options) {\n  options = options || {}\n  defaults(options)\n\n  assert(p, 'rimraf: missing path')\n  assert.equal(typeof p, 'string', 'rimraf: path should be a string')\n  assert(options, 'rimraf: missing options')\n  assert.equal(typeof options, 'object', 'rimraf: options should be object')\n\n  var results\n\n  if (options.disableGlob || !glob.hasMagic(p)) {\n    results = [p]\n  } else {\n    try {\n      options.lstatSync(p)\n      results = [p]\n    } catch (er) {\n      results = glob.sync(p, options.glob)\n    }\n  }\n\n  if (!results.length)\n    return\n\n  for (var i = 0; i < results.length; i++) {\n    var p = results[i]\n\n    try {\n      var st = options.lstatSync(p)\n    } catch (er) {\n      if (er.code === \"ENOENT\")\n        return\n\n      // Windows can EPERM on stat.  Life is suffering.\n      if (er.code === \"EPERM\" && isWindows)\n        fixWinEPERMSync(p, options, er)\n    }\n\n    try {\n      // sunos lets the root user unlink directories, which is... weird.\n      if (st && st.isDirectory())\n        rmdirSync(p, options, null)\n      else\n        options.unlinkSync(p)\n    } catch (er) {\n      if (er.code === \"ENOENT\")\n        return\n      if (er.code === \"EPERM\")\n        return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er)\n      if (er.code !== \"EISDIR\")\n        throw er\n\n      rmdirSync(p, options, er)\n    }\n  }\n}\n\nfunction rmdirSync (p, options, originalEr) {\n  assert(p)\n  assert(options)\n  if (originalEr)\n    assert(originalEr instanceof Error)\n\n  try {\n    options.rmdirSync(p)\n  } catch (er) {\n    if (er.code === \"ENOENT\")\n      return\n    if (er.code === \"ENOTDIR\")\n      throw originalEr\n    if (er.code === \"ENOTEMPTY\" || er.code === \"EEXIST\" || er.code === \"EPERM\")\n      rmkidsSync(p, options)\n  }\n}\n\nfunction rmkidsSync (p, options) {\n  assert(p)\n  assert(options)\n  options.readdirSync(p).forEach(function (f) {\n    rimrafSync(path.join(p, f), options)\n  })\n\n  // We only end up here once we got ENOTEMPTY at least once, and\n  // at this point, we are guaranteed to have removed all the kids.\n  // So, we know that it won't be ENOENT or ENOTDIR or anything else.\n  // try really hard to delete stuff on windows, because it has a\n  // PROFOUNDLY annoying habit of not closing handles promptly when\n  // files are deleted, resulting in spurious ENOTEMPTY errors.\n  var retries = isWindows ? 100 : 1\n  var i = 0\n  do {\n    var threw = true\n    try {\n      var ret = options.rmdirSync(p, options)\n      threw = false\n      return ret\n    } finally {\n      if (++i < retries && threw)\n        continue\n    }\n  } while (true)\n}\n"]},"metadata":{},"sourceType":"script"}