{"ast":null,"code":"\"use strict\";\n\nconst errorMessage = (schema, data, message) => ({\n  keyword: \"absolutePath\",\n  params: {\n    absolutePath: data\n  },\n  message: message,\n  parentSchema: schema\n});\n\nconst getErrorFor = (shouldBeAbsolute, data, schema) => {\n  const message = shouldBeAbsolute ? `The provided value ${JSON.stringify(data)} is not an absolute path!` : `A relative path is expected. However, the provided value ${JSON.stringify(data)} is an absolute path!`;\n  return errorMessage(schema, data, message);\n};\n\nmodule.exports = ajv => ajv.addKeyword(\"absolutePath\", {\n  errors: true,\n  type: \"string\",\n\n  compile(expected, schema) {\n    function callback(data) {\n      let passes = true;\n      const isExclamationMarkPresent = data.includes(\"!\");\n\n      if (isExclamationMarkPresent) {\n        callback.errors = [errorMessage(schema, data, `The provided value ${JSON.stringify(data)} contains exclamation mark (!) which is not allowed because it's reserved for loader syntax.`)];\n        passes = false;\n      } // ?:[A-Za-z]:\\\\ - Windows absolute path\n      // \\\\\\\\ - Windows network absolute path\n      // \\/ - Unix-like OS absolute path\n\n\n      const isCorrectAbsolutePath = expected === /^(?:[A-Za-z]:\\\\|\\\\\\\\|\\/)/.test(data);\n\n      if (!isCorrectAbsolutePath) {\n        callback.errors = [getErrorFor(expected, data, schema)];\n        passes = false;\n      }\n\n      return passes;\n    }\n\n    callback.errors = [];\n    return callback;\n  }\n\n});","map":{"version":3,"sources":["E:/Users/cnki/source/repos/ab29693295/MeetAdmin/node_modules/webpack/schemas/ajv.absolutePath.js"],"names":["errorMessage","schema","data","message","keyword","params","absolutePath","parentSchema","getErrorFor","shouldBeAbsolute","JSON","stringify","module","exports","ajv","addKeyword","errors","type","compile","expected","callback","passes","isExclamationMarkPresent","includes","isCorrectAbsolutePath","test"],"mappings":"AAAA;;AAEA,MAAMA,YAAY,GAAG,CAACC,MAAD,EAASC,IAAT,EAAeC,OAAf,MAA4B;AAChDC,EAAAA,OAAO,EAAE,cADuC;AAEhDC,EAAAA,MAAM,EAAE;AAAEC,IAAAA,YAAY,EAAEJ;AAAhB,GAFwC;AAGhDC,EAAAA,OAAO,EAAEA,OAHuC;AAIhDI,EAAAA,YAAY,EAAEN;AAJkC,CAA5B,CAArB;;AAOA,MAAMO,WAAW,GAAG,CAACC,gBAAD,EAAmBP,IAAnB,EAAyBD,MAAzB,KAAoC;AACvD,QAAME,OAAO,GAAGM,gBAAgB,GAC5B,sBAAqBC,IAAI,CAACC,SAAL,CAAeT,IAAf,CAAqB,2BADd,GAE5B,4DAA2DQ,IAAI,CAACC,SAAL,CAC5DT,IAD4D,CAE1D,uBAJL;AAMA,SAAOF,YAAY,CAACC,MAAD,EAASC,IAAT,EAAeC,OAAf,CAAnB;AACA,CARD;;AAUAS,MAAM,CAACC,OAAP,GAAiBC,GAAG,IACnBA,GAAG,CAACC,UAAJ,CAAe,cAAf,EAA+B;AAC9BC,EAAAA,MAAM,EAAE,IADsB;AAE9BC,EAAAA,IAAI,EAAE,QAFwB;;AAG9BC,EAAAA,OAAO,CAACC,QAAD,EAAWlB,MAAX,EAAmB;AACzB,aAASmB,QAAT,CAAkBlB,IAAlB,EAAwB;AACvB,UAAImB,MAAM,GAAG,IAAb;AACA,YAAMC,wBAAwB,GAAGpB,IAAI,CAACqB,QAAL,CAAc,GAAd,CAAjC;;AAEA,UAAID,wBAAJ,EAA8B;AAC7BF,QAAAA,QAAQ,CAACJ,MAAT,GAAkB,CACjBhB,YAAY,CACXC,MADW,EAEXC,IAFW,EAGV,sBAAqBQ,IAAI,CAACC,SAAL,CACrBT,IADqB,CAEpB,8FALS,CADK,CAAlB;AASAmB,QAAAA,MAAM,GAAG,KAAT;AACA,OAfsB,CAgBvB;AACA;AACA;;;AACA,YAAMG,qBAAqB,GAC1BL,QAAQ,KAAK,2BAA2BM,IAA3B,CAAgCvB,IAAhC,CADd;;AAEA,UAAI,CAACsB,qBAAL,EAA4B;AAC3BJ,QAAAA,QAAQ,CAACJ,MAAT,GAAkB,CAACR,WAAW,CAACW,QAAD,EAAWjB,IAAX,EAAiBD,MAAjB,CAAZ,CAAlB;AACAoB,QAAAA,MAAM,GAAG,KAAT;AACA;;AAED,aAAOA,MAAP;AACA;;AACDD,IAAAA,QAAQ,CAACJ,MAAT,GAAkB,EAAlB;AAEA,WAAOI,QAAP;AACA;;AAnC6B,CAA/B,CADD","sourcesContent":["\"use strict\";\n\nconst errorMessage = (schema, data, message) => ({\n\tkeyword: \"absolutePath\",\n\tparams: { absolutePath: data },\n\tmessage: message,\n\tparentSchema: schema\n});\n\nconst getErrorFor = (shouldBeAbsolute, data, schema) => {\n\tconst message = shouldBeAbsolute\n\t\t? `The provided value ${JSON.stringify(data)} is not an absolute path!`\n\t\t: `A relative path is expected. However, the provided value ${JSON.stringify(\n\t\t\t\tdata\n\t\t  )} is an absolute path!`;\n\n\treturn errorMessage(schema, data, message);\n};\n\nmodule.exports = ajv =>\n\tajv.addKeyword(\"absolutePath\", {\n\t\terrors: true,\n\t\ttype: \"string\",\n\t\tcompile(expected, schema) {\n\t\t\tfunction callback(data) {\n\t\t\t\tlet passes = true;\n\t\t\t\tconst isExclamationMarkPresent = data.includes(\"!\");\n\n\t\t\t\tif (isExclamationMarkPresent) {\n\t\t\t\t\tcallback.errors = [\n\t\t\t\t\t\terrorMessage(\n\t\t\t\t\t\t\tschema,\n\t\t\t\t\t\t\tdata,\n\t\t\t\t\t\t\t`The provided value ${JSON.stringify(\n\t\t\t\t\t\t\t\tdata\n\t\t\t\t\t\t\t)} contains exclamation mark (!) which is not allowed because it's reserved for loader syntax.`\n\t\t\t\t\t\t)\n\t\t\t\t\t];\n\t\t\t\t\tpasses = false;\n\t\t\t\t}\n\t\t\t\t// ?:[A-Za-z]:\\\\ - Windows absolute path\n\t\t\t\t// \\\\\\\\ - Windows network absolute path\n\t\t\t\t// \\/ - Unix-like OS absolute path\n\t\t\t\tconst isCorrectAbsolutePath =\n\t\t\t\t\texpected === /^(?:[A-Za-z]:\\\\|\\\\\\\\|\\/)/.test(data);\n\t\t\t\tif (!isCorrectAbsolutePath) {\n\t\t\t\t\tcallback.errors = [getErrorFor(expected, data, schema)];\n\t\t\t\t\tpasses = false;\n\t\t\t\t}\n\n\t\t\t\treturn passes;\n\t\t\t}\n\t\t\tcallback.errors = [];\n\n\t\t\treturn callback;\n\t\t}\n\t});\n"]},"metadata":{},"sourceType":"script"}