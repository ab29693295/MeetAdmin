{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nfunction globToRegExp(glob) {\n  // * [^\\\\\\/]*\n  // /**/ /.+/\n  // ^* \\./.+ (concord special)\n  // ? [^\\\\\\/]\n  // [!...] [^...]\n  // [^...] [^...]\n  // / [\\\\\\/]\n  // {...,...} (...|...)\n  // ?(...|...) (...|...)?\n  // +(...|...) (...|...)+\n  // *(...|...) (...|...)*\n  // @(...|...) (...|...)\n  if (/^\\(.+\\)$/.test(glob)) {\n    // allow to pass an RegExp in brackets\n    return new RegExp(glob.substr(1, glob.length - 2));\n  }\n\n  const tokens = tokenize(glob);\n  const process = createRoot();\n  const regExpStr = tokens.map(process).join(\"\");\n  return new RegExp(\"^\" + regExpStr + \"$\");\n}\n\nconst SIMPLE_TOKENS = {\n  \"@(\": \"one\",\n  \"?(\": \"zero-one\",\n  \"+(\": \"one-many\",\n  \"*(\": \"zero-many\",\n  \"|\": \"segment-sep\",\n  \"/**/\": \"any-path-segments\",\n  \"**\": \"any-path\",\n  \"*\": \"any-path-segment\",\n  \"?\": \"any-char\",\n  \"{\": \"or\",\n  \"/\": \"path-sep\",\n  \",\": \"comma\",\n  \")\": \"closing-segment\",\n  \"}\": \"closing-or\"\n};\n\nfunction tokenize(glob) {\n  return glob.split(/([@?+*]\\(|\\/\\*\\*\\/|\\*\\*|[?*]|\\[[!^]?(?:[^\\]\\\\]|\\\\.)+\\]|\\{|,|\\/|[|)}])/g).map(item => {\n    if (!item) return null;\n    const t = SIMPLE_TOKENS[item];\n\n    if (t) {\n      return {\n        type: t\n      };\n    }\n\n    if (item[0] === \"[\") {\n      if (item[1] === \"^\" || item[1] === \"!\") {\n        return {\n          type: \"inverted-char-set\",\n          value: item.substr(2, item.length - 3)\n        };\n      } else {\n        return {\n          type: \"char-set\",\n          value: item.substr(1, item.length - 2)\n        };\n      }\n    }\n\n    return {\n      type: \"string\",\n      value: item\n    };\n  }).filter(Boolean).concat({\n    type: \"end\"\n  });\n}\n\nfunction createRoot() {\n  const inOr = [];\n  const process = createSeqment();\n  let initial = true;\n  return function (token) {\n    switch (token.type) {\n      case \"or\":\n        inOr.push(initial);\n        return \"(\";\n\n      case \"comma\":\n        if (inOr.length) {\n          initial = inOr[inOr.length - 1];\n          return \"|\";\n        } else {\n          return process({\n            type: \"string\",\n            value: \",\"\n          }, initial);\n        }\n\n      case \"closing-or\":\n        if (inOr.length === 0) throw new Error(\"Unmatched '}'\");\n        inOr.pop();\n        return \")\";\n\n      case \"end\":\n        if (inOr.length) throw new Error(\"Unmatched '{'\");\n        return process(token, initial);\n\n      default:\n        {\n          const result = process(token, initial);\n          initial = false;\n          return result;\n        }\n    }\n  };\n}\n\nfunction createSeqment() {\n  const inSeqment = [];\n  const process = createSimple();\n  return function (token, initial) {\n    switch (token.type) {\n      case \"one\":\n      case \"one-many\":\n      case \"zero-many\":\n      case \"zero-one\":\n        inSeqment.push(token.type);\n        return \"(\";\n\n      case \"segment-sep\":\n        if (inSeqment.length) {\n          return \"|\";\n        } else {\n          return process({\n            type: \"string\",\n            value: \"|\"\n          }, initial);\n        }\n\n      case \"closing-segment\":\n        {\n          const segment = inSeqment.pop();\n\n          switch (segment) {\n            case \"one\":\n              return \")\";\n\n            case \"one-many\":\n              return \")+\";\n\n            case \"zero-many\":\n              return \")*\";\n\n            case \"zero-one\":\n              return \")?\";\n          }\n\n          throw new Error(\"Unexcepted segment \" + segment);\n        }\n\n      case \"end\":\n        if (inSeqment.length > 0) {\n          throw new Error(\"Unmatched segment, missing ')'\");\n        }\n\n        return process(token, initial);\n\n      default:\n        return process(token, initial);\n    }\n  };\n}\n\nfunction createSimple() {\n  return function (token, initial) {\n    switch (token.type) {\n      case \"path-sep\":\n        return \"[\\\\\\\\/]+\";\n\n      case \"any-path-segments\":\n        return \"[\\\\\\\\/]+(?:(.+)[\\\\\\\\/]+)?\";\n\n      case \"any-path\":\n        return \"(.*)\";\n\n      case \"any-path-segment\":\n        if (initial) {\n          return \"\\\\.[\\\\\\\\/]+(?:.*[\\\\\\\\/]+)?([^\\\\\\\\/]+)\";\n        } else {\n          return \"([^\\\\\\\\/]*)\";\n        }\n\n      case \"any-char\":\n        return \"[^\\\\\\\\/]\";\n\n      case \"inverted-char-set\":\n        return \"[^\" + token.value + \"]\";\n\n      case \"char-set\":\n        return \"[\" + token.value + \"]\";\n\n      case \"string\":\n        return token.value.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\n\n      case \"end\":\n        return \"\";\n\n      default:\n        throw new Error(\"Unsupported token '\" + token.type + \"'\");\n    }\n  };\n}\n\nexports.globToRegExp = globToRegExp;","map":{"version":3,"sources":["E:/Users/cnki/source/repos/ab29693295/MeetAdmin/node_modules/enhanced-resolve/lib/globToRegExp.js"],"names":["globToRegExp","glob","test","RegExp","substr","length","tokens","tokenize","process","createRoot","regExpStr","map","join","SIMPLE_TOKENS","split","item","t","type","value","filter","Boolean","concat","inOr","createSeqment","initial","token","push","Error","pop","result","inSeqment","createSimple","segment","replace","exports"],"mappings":"AAAA;;;;AAIA;;AAEA,SAASA,YAAT,CAAsBC,IAAtB,EAA4B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAI,WAAWC,IAAX,CAAgBD,IAAhB,CAAJ,EAA2B;AAC1B;AACA,WAAO,IAAIE,MAAJ,CAAWF,IAAI,CAACG,MAAL,CAAY,CAAZ,EAAeH,IAAI,CAACI,MAAL,GAAc,CAA7B,CAAX,CAAP;AACA;;AACD,QAAMC,MAAM,GAAGC,QAAQ,CAACN,IAAD,CAAvB;AACA,QAAMO,OAAO,GAAGC,UAAU,EAA1B;AACA,QAAMC,SAAS,GAAGJ,MAAM,CAACK,GAAP,CAAWH,OAAX,EAAoBI,IAApB,CAAyB,EAAzB,CAAlB;AACA,SAAO,IAAIT,MAAJ,CAAW,MAAMO,SAAN,GAAkB,GAA7B,CAAP;AACA;;AAED,MAAMG,aAAa,GAAG;AACrB,QAAM,KADe;AAErB,QAAM,UAFe;AAGrB,QAAM,UAHe;AAIrB,QAAM,WAJe;AAKrB,OAAK,aALgB;AAMrB,UAAQ,mBANa;AAOrB,QAAM,UAPe;AAQrB,OAAK,kBARgB;AASrB,OAAK,UATgB;AAUrB,OAAK,IAVgB;AAWrB,OAAK,UAXgB;AAYrB,OAAK,OAZgB;AAarB,OAAK,iBAbgB;AAcrB,OAAK;AAdgB,CAAtB;;AAiBA,SAASN,QAAT,CAAkBN,IAAlB,EAAwB;AACvB,SAAOA,IAAI,CACTa,KADK,CAEL,wEAFK,EAILH,GAJK,CAIDI,IAAI,IAAI;AACZ,QAAI,CAACA,IAAL,EAAW,OAAO,IAAP;AACX,UAAMC,CAAC,GAAGH,aAAa,CAACE,IAAD,CAAvB;;AACA,QAAIC,CAAJ,EAAO;AACN,aAAO;AACNC,QAAAA,IAAI,EAAED;AADA,OAAP;AAGA;;AACD,QAAID,IAAI,CAAC,CAAD,CAAJ,KAAY,GAAhB,EAAqB;AACpB,UAAIA,IAAI,CAAC,CAAD,CAAJ,KAAY,GAAZ,IAAmBA,IAAI,CAAC,CAAD,CAAJ,KAAY,GAAnC,EAAwC;AACvC,eAAO;AACNE,UAAAA,IAAI,EAAE,mBADA;AAENC,UAAAA,KAAK,EAAEH,IAAI,CAACX,MAAL,CAAY,CAAZ,EAAeW,IAAI,CAACV,MAAL,GAAc,CAA7B;AAFD,SAAP;AAIA,OALD,MAKO;AACN,eAAO;AACNY,UAAAA,IAAI,EAAE,UADA;AAENC,UAAAA,KAAK,EAAEH,IAAI,CAACX,MAAL,CAAY,CAAZ,EAAeW,IAAI,CAACV,MAAL,GAAc,CAA7B;AAFD,SAAP;AAIA;AACD;;AACD,WAAO;AACNY,MAAAA,IAAI,EAAE,QADA;AAENC,MAAAA,KAAK,EAAEH;AAFD,KAAP;AAIA,GA7BK,EA8BLI,MA9BK,CA8BEC,OA9BF,EA+BLC,MA/BK,CA+BE;AACPJ,IAAAA,IAAI,EAAE;AADC,GA/BF,CAAP;AAkCA;;AAED,SAASR,UAAT,GAAsB;AACrB,QAAMa,IAAI,GAAG,EAAb;AACA,QAAMd,OAAO,GAAGe,aAAa,EAA7B;AACA,MAAIC,OAAO,GAAG,IAAd;AACA,SAAO,UAASC,KAAT,EAAgB;AACtB,YAAQA,KAAK,CAACR,IAAd;AACC,WAAK,IAAL;AACCK,QAAAA,IAAI,CAACI,IAAL,CAAUF,OAAV;AACA,eAAO,GAAP;;AACD,WAAK,OAAL;AACC,YAAIF,IAAI,CAACjB,MAAT,EAAiB;AAChBmB,UAAAA,OAAO,GAAGF,IAAI,CAACA,IAAI,CAACjB,MAAL,GAAc,CAAf,CAAd;AACA,iBAAO,GAAP;AACA,SAHD,MAGO;AACN,iBAAOG,OAAO,CACb;AACCS,YAAAA,IAAI,EAAE,QADP;AAECC,YAAAA,KAAK,EAAE;AAFR,WADa,EAKbM,OALa,CAAd;AAOA;;AACF,WAAK,YAAL;AACC,YAAIF,IAAI,CAACjB,MAAL,KAAgB,CAApB,EAAuB,MAAM,IAAIsB,KAAJ,CAAU,eAAV,CAAN;AACvBL,QAAAA,IAAI,CAACM,GAAL;AACA,eAAO,GAAP;;AACD,WAAK,KAAL;AACC,YAAIN,IAAI,CAACjB,MAAT,EAAiB,MAAM,IAAIsB,KAAJ,CAAU,eAAV,CAAN;AACjB,eAAOnB,OAAO,CAACiB,KAAD,EAAQD,OAAR,CAAd;;AACD;AAAS;AACR,gBAAMK,MAAM,GAAGrB,OAAO,CAACiB,KAAD,EAAQD,OAAR,CAAtB;AACAA,UAAAA,OAAO,GAAG,KAAV;AACA,iBAAOK,MAAP;AACA;AA5BF;AA8BA,GA/BD;AAgCA;;AAED,SAASN,aAAT,GAAyB;AACxB,QAAMO,SAAS,GAAG,EAAlB;AACA,QAAMtB,OAAO,GAAGuB,YAAY,EAA5B;AACA,SAAO,UAASN,KAAT,EAAgBD,OAAhB,EAAyB;AAC/B,YAAQC,KAAK,CAACR,IAAd;AACC,WAAK,KAAL;AACA,WAAK,UAAL;AACA,WAAK,WAAL;AACA,WAAK,UAAL;AACCa,QAAAA,SAAS,CAACJ,IAAV,CAAeD,KAAK,CAACR,IAArB;AACA,eAAO,GAAP;;AACD,WAAK,aAAL;AACC,YAAIa,SAAS,CAACzB,MAAd,EAAsB;AACrB,iBAAO,GAAP;AACA,SAFD,MAEO;AACN,iBAAOG,OAAO,CACb;AACCS,YAAAA,IAAI,EAAE,QADP;AAECC,YAAAA,KAAK,EAAE;AAFR,WADa,EAKbM,OALa,CAAd;AAOA;;AACF,WAAK,iBAAL;AAAwB;AACvB,gBAAMQ,OAAO,GAAGF,SAAS,CAACF,GAAV,EAAhB;;AACA,kBAAQI,OAAR;AACC,iBAAK,KAAL;AACC,qBAAO,GAAP;;AACD,iBAAK,UAAL;AACC,qBAAO,IAAP;;AACD,iBAAK,WAAL;AACC,qBAAO,IAAP;;AACD,iBAAK,UAAL;AACC,qBAAO,IAAP;AARF;;AAUA,gBAAM,IAAIL,KAAJ,CAAU,wBAAwBK,OAAlC,CAAN;AACA;;AACD,WAAK,KAAL;AACC,YAAIF,SAAS,CAACzB,MAAV,GAAmB,CAAvB,EAA0B;AACzB,gBAAM,IAAIsB,KAAJ,CAAU,gCAAV,CAAN;AACA;;AACD,eAAOnB,OAAO,CAACiB,KAAD,EAAQD,OAAR,CAAd;;AACD;AACC,eAAOhB,OAAO,CAACiB,KAAD,EAAQD,OAAR,CAAd;AAvCF;AAyCA,GA1CD;AA2CA;;AAED,SAASO,YAAT,GAAwB;AACvB,SAAO,UAASN,KAAT,EAAgBD,OAAhB,EAAyB;AAC/B,YAAQC,KAAK,CAACR,IAAd;AACC,WAAK,UAAL;AACC,eAAO,UAAP;;AACD,WAAK,mBAAL;AACC,eAAO,2BAAP;;AACD,WAAK,UAAL;AACC,eAAO,MAAP;;AACD,WAAK,kBAAL;AACC,YAAIO,OAAJ,EAAa;AACZ,iBAAO,uCAAP;AACA,SAFD,MAEO;AACN,iBAAO,aAAP;AACA;;AACF,WAAK,UAAL;AACC,eAAO,UAAP;;AACD,WAAK,mBAAL;AACC,eAAO,OAAOC,KAAK,CAACP,KAAb,GAAqB,GAA5B;;AACD,WAAK,UAAL;AACC,eAAO,MAAMO,KAAK,CAACP,KAAZ,GAAoB,GAA3B;;AACD,WAAK,QAAL;AACC,eAAOO,KAAK,CAACP,KAAN,CAAYe,OAAZ,CAAoB,0BAApB,EAAgD,MAAhD,CAAP;;AACD,WAAK,KAAL;AACC,eAAO,EAAP;;AACD;AACC,cAAM,IAAIN,KAAJ,CAAU,wBAAwBF,KAAK,CAACR,IAA9B,GAAqC,GAA/C,CAAN;AAxBF;AA0BA,GA3BD;AA4BA;;AAEDiB,OAAO,CAAClC,YAAR,GAAuBA,YAAvB","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nfunction globToRegExp(glob) {\n\t// * [^\\\\\\/]*\n\t// /**/ /.+/\n\t// ^* \\./.+ (concord special)\n\t// ? [^\\\\\\/]\n\t// [!...] [^...]\n\t// [^...] [^...]\n\t// / [\\\\\\/]\n\t// {...,...} (...|...)\n\t// ?(...|...) (...|...)?\n\t// +(...|...) (...|...)+\n\t// *(...|...) (...|...)*\n\t// @(...|...) (...|...)\n\tif (/^\\(.+\\)$/.test(glob)) {\n\t\t// allow to pass an RegExp in brackets\n\t\treturn new RegExp(glob.substr(1, glob.length - 2));\n\t}\n\tconst tokens = tokenize(glob);\n\tconst process = createRoot();\n\tconst regExpStr = tokens.map(process).join(\"\");\n\treturn new RegExp(\"^\" + regExpStr + \"$\");\n}\n\nconst SIMPLE_TOKENS = {\n\t\"@(\": \"one\",\n\t\"?(\": \"zero-one\",\n\t\"+(\": \"one-many\",\n\t\"*(\": \"zero-many\",\n\t\"|\": \"segment-sep\",\n\t\"/**/\": \"any-path-segments\",\n\t\"**\": \"any-path\",\n\t\"*\": \"any-path-segment\",\n\t\"?\": \"any-char\",\n\t\"{\": \"or\",\n\t\"/\": \"path-sep\",\n\t\",\": \"comma\",\n\t\")\": \"closing-segment\",\n\t\"}\": \"closing-or\"\n};\n\nfunction tokenize(glob) {\n\treturn glob\n\t\t.split(\n\t\t\t/([@?+*]\\(|\\/\\*\\*\\/|\\*\\*|[?*]|\\[[!^]?(?:[^\\]\\\\]|\\\\.)+\\]|\\{|,|\\/|[|)}])/g\n\t\t)\n\t\t.map(item => {\n\t\t\tif (!item) return null;\n\t\t\tconst t = SIMPLE_TOKENS[item];\n\t\t\tif (t) {\n\t\t\t\treturn {\n\t\t\t\t\ttype: t\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (item[0] === \"[\") {\n\t\t\t\tif (item[1] === \"^\" || item[1] === \"!\") {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: \"inverted-char-set\",\n\t\t\t\t\t\tvalue: item.substr(2, item.length - 3)\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: \"char-set\",\n\t\t\t\t\t\tvalue: item.substr(1, item.length - 2)\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn {\n\t\t\t\ttype: \"string\",\n\t\t\t\tvalue: item\n\t\t\t};\n\t\t})\n\t\t.filter(Boolean)\n\t\t.concat({\n\t\t\ttype: \"end\"\n\t\t});\n}\n\nfunction createRoot() {\n\tconst inOr = [];\n\tconst process = createSeqment();\n\tlet initial = true;\n\treturn function(token) {\n\t\tswitch (token.type) {\n\t\t\tcase \"or\":\n\t\t\t\tinOr.push(initial);\n\t\t\t\treturn \"(\";\n\t\t\tcase \"comma\":\n\t\t\t\tif (inOr.length) {\n\t\t\t\t\tinitial = inOr[inOr.length - 1];\n\t\t\t\t\treturn \"|\";\n\t\t\t\t} else {\n\t\t\t\t\treturn process(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tvalue: \",\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tinitial\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\tcase \"closing-or\":\n\t\t\t\tif (inOr.length === 0) throw new Error(\"Unmatched '}'\");\n\t\t\t\tinOr.pop();\n\t\t\t\treturn \")\";\n\t\t\tcase \"end\":\n\t\t\t\tif (inOr.length) throw new Error(\"Unmatched '{'\");\n\t\t\t\treturn process(token, initial);\n\t\t\tdefault: {\n\t\t\t\tconst result = process(token, initial);\n\t\t\t\tinitial = false;\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\t};\n}\n\nfunction createSeqment() {\n\tconst inSeqment = [];\n\tconst process = createSimple();\n\treturn function(token, initial) {\n\t\tswitch (token.type) {\n\t\t\tcase \"one\":\n\t\t\tcase \"one-many\":\n\t\t\tcase \"zero-many\":\n\t\t\tcase \"zero-one\":\n\t\t\t\tinSeqment.push(token.type);\n\t\t\t\treturn \"(\";\n\t\t\tcase \"segment-sep\":\n\t\t\t\tif (inSeqment.length) {\n\t\t\t\t\treturn \"|\";\n\t\t\t\t} else {\n\t\t\t\t\treturn process(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t\tvalue: \"|\"\n\t\t\t\t\t\t},\n\t\t\t\t\t\tinitial\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\tcase \"closing-segment\": {\n\t\t\t\tconst segment = inSeqment.pop();\n\t\t\t\tswitch (segment) {\n\t\t\t\t\tcase \"one\":\n\t\t\t\t\t\treturn \")\";\n\t\t\t\t\tcase \"one-many\":\n\t\t\t\t\t\treturn \")+\";\n\t\t\t\t\tcase \"zero-many\":\n\t\t\t\t\t\treturn \")*\";\n\t\t\t\t\tcase \"zero-one\":\n\t\t\t\t\t\treturn \")?\";\n\t\t\t\t}\n\t\t\t\tthrow new Error(\"Unexcepted segment \" + segment);\n\t\t\t}\n\t\t\tcase \"end\":\n\t\t\t\tif (inSeqment.length > 0) {\n\t\t\t\t\tthrow new Error(\"Unmatched segment, missing ')'\");\n\t\t\t\t}\n\t\t\t\treturn process(token, initial);\n\t\t\tdefault:\n\t\t\t\treturn process(token, initial);\n\t\t}\n\t};\n}\n\nfunction createSimple() {\n\treturn function(token, initial) {\n\t\tswitch (token.type) {\n\t\t\tcase \"path-sep\":\n\t\t\t\treturn \"[\\\\\\\\/]+\";\n\t\t\tcase \"any-path-segments\":\n\t\t\t\treturn \"[\\\\\\\\/]+(?:(.+)[\\\\\\\\/]+)?\";\n\t\t\tcase \"any-path\":\n\t\t\t\treturn \"(.*)\";\n\t\t\tcase \"any-path-segment\":\n\t\t\t\tif (initial) {\n\t\t\t\t\treturn \"\\\\.[\\\\\\\\/]+(?:.*[\\\\\\\\/]+)?([^\\\\\\\\/]+)\";\n\t\t\t\t} else {\n\t\t\t\t\treturn \"([^\\\\\\\\/]*)\";\n\t\t\t\t}\n\t\t\tcase \"any-char\":\n\t\t\t\treturn \"[^\\\\\\\\/]\";\n\t\t\tcase \"inverted-char-set\":\n\t\t\t\treturn \"[^\" + token.value + \"]\";\n\t\t\tcase \"char-set\":\n\t\t\t\treturn \"[\" + token.value + \"]\";\n\t\t\tcase \"string\":\n\t\t\t\treturn token.value.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, \"\\\\$&\");\n\t\t\tcase \"end\":\n\t\t\t\treturn \"\";\n\t\t\tdefault:\n\t\t\t\tthrow new Error(\"Unsupported token '\" + token.type + \"'\");\n\t\t}\n\t};\n}\n\nexports.globToRegExp = globToRegExp;\n"]},"metadata":{},"sourceType":"script"}