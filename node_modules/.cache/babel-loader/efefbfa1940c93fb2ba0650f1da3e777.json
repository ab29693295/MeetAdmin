{"ast":null,"code":"\"use strict\";\n\nconst path = require(\"path\");\n/**\n * @param {string} context context for relative path\n * @param {string} relativePath path\n * @returns {string} absolute path\n */\n\n\nconst requestToAbsolute = (context, relativePath) => {\n  if (relativePath.startsWith(\"./\") || relativePath.startsWith(\"../\")) return path.join(context, relativePath);\n  return relativePath;\n};\n/**\n * @typedef {Object} MakeRelativePathsCache\n * @property {Map<string, Map<string, string>>=} relativePaths\n */\n\n/**\n *\n * @param {string} maybeAbsolutePath path to check\n * @returns {boolean} returns true if path is \"Absolute Path\"-like\n */\n\n\nconst looksLikeAbsolutePath = maybeAbsolutePath => {\n  if (/^\\/.*\\/$/.test(maybeAbsolutePath)) {\n    // this 'path' is actually a regexp generated by dynamic requires.\n    // Don't treat it as an absolute path.\n    return false;\n  }\n\n  return /^(?:[a-z]:\\\\|\\/)/i.test(maybeAbsolutePath);\n};\n/**\n *\n * @param {string} p path to normalize\n * @returns {string} normalized version of path\n */\n\n\nconst normalizePathSeparator = p => p.replace(/\\\\/g, \"/\");\n/**\n *\n * @param {string} context context for relative path\n * @param {string} identifier identifier for path\n * @returns {string} a converted relative path\n */\n\n\nconst _makePathsRelative = (context, identifier) => {\n  return identifier.split(/([|! ])/).map(str => looksLikeAbsolutePath(str) ? normalizePathSeparator(path.relative(context, str)) : str).join(\"\");\n};\n/**\n *\n * @param {string} context context used to create relative path\n * @param {string} identifier identifier used to create relative path\n * @param {MakeRelativePathsCache=} cache the cache object being set\n * @returns {string} the returned relative path\n */\n\n\nexports.makePathsRelative = (context, identifier, cache) => {\n  if (!cache) return _makePathsRelative(context, identifier);\n  const relativePaths = cache.relativePaths || (cache.relativePaths = new Map());\n  let cachedResult;\n  let contextCache = relativePaths.get(context);\n\n  if (contextCache === undefined) {\n    relativePaths.set(context, contextCache = new Map());\n  } else {\n    cachedResult = contextCache.get(identifier);\n  }\n\n  if (cachedResult !== undefined) {\n    return cachedResult;\n  } else {\n    const relativePath = _makePathsRelative(context, identifier);\n\n    contextCache.set(identifier, relativePath);\n    return relativePath;\n  }\n};\n/**\n * @param {string} context absolute context path\n * @param {string} request any request string may containing absolute paths, query string, etc.\n * @returns {string} a new request string avoiding absolute paths when possible\n */\n\n\nexports.contextify = (context, request) => {\n  return request.split(\"!\").map(r => {\n    const splitPath = r.split(\"?\", 2);\n\n    if (/^[a-zA-Z]:\\\\/.test(splitPath[0])) {\n      splitPath[0] = path.win32.relative(context, splitPath[0]);\n\n      if (!/^[a-zA-Z]:\\\\/.test(splitPath[0])) {\n        splitPath[0] = splitPath[0].replace(/\\\\/g, \"/\");\n      }\n    }\n\n    if (/^\\//.test(splitPath[0])) {\n      splitPath[0] = path.posix.relative(context, splitPath[0]);\n    }\n\n    if (!/^(\\.\\.\\/|\\/|[a-zA-Z]:\\\\)/.test(splitPath[0])) {\n      splitPath[0] = \"./\" + splitPath[0];\n    }\n\n    return splitPath.join(\"?\");\n  }).join(\"!\");\n};\n/**\n * @param {string} context absolute context path\n * @param {string} request any request string\n * @returns {string} a new request string using absolute paths when possible\n */\n\n\nconst _absolutify = (context, request) => {\n  return request.split(\"!\").map(r => requestToAbsolute(context, r)).join(\"!\");\n};\n\nexports.absolutify = _absolutify;","map":{"version":3,"sources":["E:/Users/cnki/source/repos/ab29693295/MeetAdmin/node_modules/webpack/lib/util/identifier.js"],"names":["path","require","requestToAbsolute","context","relativePath","startsWith","join","looksLikeAbsolutePath","maybeAbsolutePath","test","normalizePathSeparator","p","replace","_makePathsRelative","identifier","split","map","str","relative","exports","makePathsRelative","cache","relativePaths","Map","cachedResult","contextCache","get","undefined","set","contextify","request","r","splitPath","win32","posix","_absolutify","absolutify"],"mappings":"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","sourcesContent":["\"use strict\";\nconst path = require(\"path\");\n\n/**\n * @param {string} context context for relative path\n * @param {string} relativePath path\n * @returns {string} absolute path\n */\nconst requestToAbsolute = (context, relativePath) => {\n\tif (relativePath.startsWith(\"./\") || relativePath.startsWith(\"../\"))\n\t\treturn path.join(context, relativePath);\n\treturn relativePath;\n};\n\n/**\n * @typedef {Object} MakeRelativePathsCache\n * @property {Map<string, Map<string, string>>=} relativePaths\n */\n\n/**\n *\n * @param {string} maybeAbsolutePath path to check\n * @returns {boolean} returns true if path is \"Absolute Path\"-like\n */\nconst looksLikeAbsolutePath = maybeAbsolutePath => {\n\tif (/^\\/.*\\/$/.test(maybeAbsolutePath)) {\n\t\t// this 'path' is actually a regexp generated by dynamic requires.\n\t\t// Don't treat it as an absolute path.\n\t\treturn false;\n\t}\n\treturn /^(?:[a-z]:\\\\|\\/)/i.test(maybeAbsolutePath);\n};\n\n/**\n *\n * @param {string} p path to normalize\n * @returns {string} normalized version of path\n */\nconst normalizePathSeparator = p => p.replace(/\\\\/g, \"/\");\n\n/**\n *\n * @param {string} context context for relative path\n * @param {string} identifier identifier for path\n * @returns {string} a converted relative path\n */\nconst _makePathsRelative = (context, identifier) => {\n\treturn identifier\n\t\t.split(/([|! ])/)\n\t\t.map(str =>\n\t\t\tlooksLikeAbsolutePath(str)\n\t\t\t\t? normalizePathSeparator(path.relative(context, str))\n\t\t\t\t: str\n\t\t)\n\t\t.join(\"\");\n};\n\n/**\n *\n * @param {string} context context used to create relative path\n * @param {string} identifier identifier used to create relative path\n * @param {MakeRelativePathsCache=} cache the cache object being set\n * @returns {string} the returned relative path\n */\nexports.makePathsRelative = (context, identifier, cache) => {\n\tif (!cache) return _makePathsRelative(context, identifier);\n\n\tconst relativePaths =\n\t\tcache.relativePaths || (cache.relativePaths = new Map());\n\n\tlet cachedResult;\n\tlet contextCache = relativePaths.get(context);\n\tif (contextCache === undefined) {\n\t\trelativePaths.set(context, (contextCache = new Map()));\n\t} else {\n\t\tcachedResult = contextCache.get(identifier);\n\t}\n\n\tif (cachedResult !== undefined) {\n\t\treturn cachedResult;\n\t} else {\n\t\tconst relativePath = _makePathsRelative(context, identifier);\n\t\tcontextCache.set(identifier, relativePath);\n\t\treturn relativePath;\n\t}\n};\n\n/**\n * @param {string} context absolute context path\n * @param {string} request any request string may containing absolute paths, query string, etc.\n * @returns {string} a new request string avoiding absolute paths when possible\n */\nexports.contextify = (context, request) => {\n\treturn request\n\t\t.split(\"!\")\n\t\t.map(r => {\n\t\t\tconst splitPath = r.split(\"?\", 2);\n\t\t\tif (/^[a-zA-Z]:\\\\/.test(splitPath[0])) {\n\t\t\t\tsplitPath[0] = path.win32.relative(context, splitPath[0]);\n\t\t\t\tif (!/^[a-zA-Z]:\\\\/.test(splitPath[0])) {\n\t\t\t\t\tsplitPath[0] = splitPath[0].replace(/\\\\/g, \"/\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (/^\\//.test(splitPath[0])) {\n\t\t\t\tsplitPath[0] = path.posix.relative(context, splitPath[0]);\n\t\t\t}\n\t\t\tif (!/^(\\.\\.\\/|\\/|[a-zA-Z]:\\\\)/.test(splitPath[0])) {\n\t\t\t\tsplitPath[0] = \"./\" + splitPath[0];\n\t\t\t}\n\t\t\treturn splitPath.join(\"?\");\n\t\t})\n\t\t.join(\"!\");\n};\n\n/**\n * @param {string} context absolute context path\n * @param {string} request any request string\n * @returns {string} a new request string using absolute paths when possible\n */\nconst _absolutify = (context, request) => {\n\treturn request\n\t\t.split(\"!\")\n\t\t.map(r => requestToAbsolute(context, r))\n\t\t.join(\"!\");\n};\n\nexports.absolutify = _absolutify;\n"]},"metadata":{},"sourceType":"script"}