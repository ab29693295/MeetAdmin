{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst identifierUtils = require(\"./util/identifier\");\n/** @typedef {import(\"./Compiler\")} Compiler */\n\n/** @typedef {import(\"./Chunk\")} Chunk */\n\n/** @typedef {import(\"./Module\")} Module */\n\n/**\n * @typedef {Object} RecordsChunks\n * @property {Record<string, number>=} byName\n * @property {Record<string, number>=} bySource\n * @property {number[]=} usedIds\n */\n\n/**\n * @typedef {Object} RecordsModules\n * @property {Record<string, number>=} byIdentifier\n * @property {Record<string, number>=} bySource\n * @property {Record<number, number>=} usedIds\n */\n\n/**\n * @typedef {Object} Records\n * @property {RecordsChunks=} chunks\n * @property {RecordsModules=} modules\n */\n\n\nclass RecordIdsPlugin {\n  /**\n   * @param {Object} options Options object\n   * @param {boolean=} options.portableIds true, when ids need to be portable\n   */\n  constructor(options) {\n    this.options = options || {};\n  }\n  /**\n   * @param {Compiler} compiler the Compiler\n   * @returns {void}\n   */\n\n\n  apply(compiler) {\n    const portableIds = this.options.portableIds;\n    compiler.hooks.compilation.tap(\"RecordIdsPlugin\", compilation => {\n      compilation.hooks.recordModules.tap(\"RecordIdsPlugin\",\n      /**\n       * @param {Module[]} modules the modules array\n       * @param {Records} records the records object\n       * @returns {void}\n       */\n      (modules, records) => {\n        if (!records.modules) records.modules = {};\n        if (!records.modules.byIdentifier) records.modules.byIdentifier = {};\n        if (!records.modules.usedIds) records.modules.usedIds = {};\n\n        for (const module of modules) {\n          if (typeof module.id !== \"number\") continue;\n          const identifier = portableIds ? identifierUtils.makePathsRelative(compiler.context, module.identifier(), compilation.cache) : module.identifier();\n          records.modules.byIdentifier[identifier] = module.id;\n          records.modules.usedIds[module.id] = module.id;\n        }\n      });\n      compilation.hooks.reviveModules.tap(\"RecordIdsPlugin\",\n      /**\n       * @param {Module[]} modules the modules array\n       * @param {Records} records the records object\n       * @returns {void}\n       */\n      (modules, records) => {\n        if (!records.modules) return;\n\n        if (records.modules.byIdentifier) {\n          /** @type {Set<number>} */\n          const usedIds = new Set();\n\n          for (const module of modules) {\n            if (module.id !== null) continue;\n            const identifier = portableIds ? identifierUtils.makePathsRelative(compiler.context, module.identifier(), compilation.cache) : module.identifier();\n            const id = records.modules.byIdentifier[identifier];\n            if (id === undefined) continue;\n            if (usedIds.has(id)) continue;\n            usedIds.add(id);\n            module.id = id;\n          }\n        }\n\n        if (Array.isArray(records.modules.usedIds)) {\n          compilation.usedModuleIds = new Set(records.modules.usedIds);\n        }\n      });\n      /**\n       * @param {Module} module the module\n       * @returns {string} the (portable) identifier\n       */\n\n      const getModuleIdentifier = module => {\n        if (portableIds) {\n          return identifierUtils.makePathsRelative(compiler.context, module.identifier(), compilation.cache);\n        }\n\n        return module.identifier();\n      };\n      /**\n       * @param {Chunk} chunk the chunk\n       * @returns {string[]} sources of the chunk\n       */\n\n\n      const getChunkSources = chunk => {\n        /** @type {string[]} */\n        const sources = [];\n\n        for (const chunkGroup of chunk.groupsIterable) {\n          const index = chunkGroup.chunks.indexOf(chunk);\n\n          for (const origin of chunkGroup.origins) {\n            if (origin.module) {\n              if (origin.request) {\n                sources.push(`${index} ${getModuleIdentifier(origin.module)} ${origin.request}`);\n              } else if (typeof origin.loc === \"string\") {\n                sources.push(`${index} ${getModuleIdentifier(origin.module)} ${origin.loc}`);\n              } else if (origin.loc && typeof origin.loc === \"object\" && origin.loc.start) {\n                sources.push(`${index} ${getModuleIdentifier(origin.module)} ${JSON.stringify(origin.loc.start)}`);\n              }\n            }\n          }\n        }\n\n        return sources;\n      };\n\n      compilation.hooks.recordChunks.tap(\"RecordIdsPlugin\",\n      /**\n       * @param {Chunk[]} chunks the chunks array\n       * @param {Records} records the records object\n       * @returns {void}\n       */\n      (chunks, records) => {\n        if (!records.chunks) records.chunks = {};\n        if (!records.chunks.byName) records.chunks.byName = {};\n        if (!records.chunks.bySource) records.chunks.bySource = {};\n        /** @type {Set<number>} */\n\n        const usedIds = new Set();\n\n        for (const chunk of chunks) {\n          if (typeof chunk.id !== \"number\") continue;\n          const name = chunk.name;\n          if (name) records.chunks.byName[name] = chunk.id;\n          const sources = getChunkSources(chunk);\n\n          for (const source of sources) {\n            records.chunks.bySource[source] = chunk.id;\n          }\n\n          usedIds.add(chunk.id);\n        }\n\n        records.chunks.usedIds = Array.from(usedIds).sort();\n      });\n      compilation.hooks.reviveChunks.tap(\"RecordIdsPlugin\",\n      /**\n       * @param {Chunk[]} chunks the chunks array\n       * @param {Records} records the records object\n       * @returns {void}\n       */\n      (chunks, records) => {\n        if (!records.chunks) return;\n        /** @type {Set<number>} */\n\n        const usedIds = new Set();\n\n        if (records.chunks.byName) {\n          for (const chunk of chunks) {\n            if (chunk.id !== null) continue;\n            if (!chunk.name) continue;\n            const id = records.chunks.byName[chunk.name];\n            if (id === undefined) continue;\n            if (usedIds.has(id)) continue;\n            usedIds.add(id);\n            chunk.id = id;\n          }\n        }\n\n        if (records.chunks.bySource) {\n          for (const chunk of chunks) {\n            const sources = getChunkSources(chunk);\n\n            for (const source of sources) {\n              const id = records.chunks.bySource[source];\n              if (id === undefined) continue;\n              if (usedIds.has(id)) continue;\n              usedIds.add(id);\n              chunk.id = id;\n              break;\n            }\n          }\n        }\n\n        if (Array.isArray(records.chunks.usedIds)) {\n          compilation.usedChunkIds = new Set(records.chunks.usedIds);\n        }\n      });\n    });\n  }\n\n}\n\nmodule.exports = RecordIdsPlugin;","map":{"version":3,"sources":["E:/Users/cnki/source/repos/ab29693295/MeetAdmin/node_modules/webpack/lib/RecordIdsPlugin.js"],"names":["identifierUtils","require","RecordIdsPlugin","constructor","options","apply","compiler","portableIds","hooks","compilation","tap","recordModules","modules","records","byIdentifier","usedIds","module","id","identifier","makePathsRelative","context","cache","reviveModules","Set","undefined","has","add","Array","isArray","usedModuleIds","getModuleIdentifier","getChunkSources","chunk","sources","chunkGroup","groupsIterable","index","chunks","indexOf","origin","origins","request","push","loc","start","JSON","stringify","recordChunks","byName","bySource","name","source","from","sort","reviveChunks","usedChunkIds","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst identifierUtils = require(\"./util/identifier\");\n\n/** @typedef {import(\"./Compiler\")} Compiler */\n/** @typedef {import(\"./Chunk\")} Chunk */\n/** @typedef {import(\"./Module\")} Module */\n\n/**\n * @typedef {Object} RecordsChunks\n * @property {Record<string, number>=} byName\n * @property {Record<string, number>=} bySource\n * @property {number[]=} usedIds\n */\n\n/**\n * @typedef {Object} RecordsModules\n * @property {Record<string, number>=} byIdentifier\n * @property {Record<string, number>=} bySource\n * @property {Record<number, number>=} usedIds\n */\n\n/**\n * @typedef {Object} Records\n * @property {RecordsChunks=} chunks\n * @property {RecordsModules=} modules\n */\n\nclass RecordIdsPlugin {\n\t/**\n\t * @param {Object} options Options object\n\t * @param {boolean=} options.portableIds true, when ids need to be portable\n\t */\n\tconstructor(options) {\n\t\tthis.options = options || {};\n\t}\n\n\t/**\n\t * @param {Compiler} compiler the Compiler\n\t * @returns {void}\n\t */\n\tapply(compiler) {\n\t\tconst portableIds = this.options.portableIds;\n\t\tcompiler.hooks.compilation.tap(\"RecordIdsPlugin\", compilation => {\n\t\t\tcompilation.hooks.recordModules.tap(\n\t\t\t\t\"RecordIdsPlugin\",\n\t\t\t\t/**\n\t\t\t\t * @param {Module[]} modules the modules array\n\t\t\t\t * @param {Records} records the records object\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\t(modules, records) => {\n\t\t\t\t\tif (!records.modules) records.modules = {};\n\t\t\t\t\tif (!records.modules.byIdentifier) records.modules.byIdentifier = {};\n\t\t\t\t\tif (!records.modules.usedIds) records.modules.usedIds = {};\n\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\tif (typeof module.id !== \"number\") continue;\n\t\t\t\t\t\tconst identifier = portableIds\n\t\t\t\t\t\t\t? identifierUtils.makePathsRelative(\n\t\t\t\t\t\t\t\t\tcompiler.context,\n\t\t\t\t\t\t\t\t\tmodule.identifier(),\n\t\t\t\t\t\t\t\t\tcompilation.cache\n\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t: module.identifier();\n\t\t\t\t\t\trecords.modules.byIdentifier[identifier] = module.id;\n\t\t\t\t\t\trecords.modules.usedIds[module.id] = module.id;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t\tcompilation.hooks.reviveModules.tap(\n\t\t\t\t\"RecordIdsPlugin\",\n\t\t\t\t/**\n\t\t\t\t * @param {Module[]} modules the modules array\n\t\t\t\t * @param {Records} records the records object\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\t(modules, records) => {\n\t\t\t\t\tif (!records.modules) return;\n\t\t\t\t\tif (records.modules.byIdentifier) {\n\t\t\t\t\t\t/** @type {Set<number>} */\n\t\t\t\t\t\tconst usedIds = new Set();\n\t\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\t\tif (module.id !== null) continue;\n\t\t\t\t\t\t\tconst identifier = portableIds\n\t\t\t\t\t\t\t\t? identifierUtils.makePathsRelative(\n\t\t\t\t\t\t\t\t\t\tcompiler.context,\n\t\t\t\t\t\t\t\t\t\tmodule.identifier(),\n\t\t\t\t\t\t\t\t\t\tcompilation.cache\n\t\t\t\t\t\t\t\t  )\n\t\t\t\t\t\t\t\t: module.identifier();\n\t\t\t\t\t\t\tconst id = records.modules.byIdentifier[identifier];\n\t\t\t\t\t\t\tif (id === undefined) continue;\n\t\t\t\t\t\t\tif (usedIds.has(id)) continue;\n\t\t\t\t\t\t\tusedIds.add(id);\n\t\t\t\t\t\t\tmodule.id = id;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Array.isArray(records.modules.usedIds)) {\n\t\t\t\t\t\tcompilation.usedModuleIds = new Set(records.modules.usedIds);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\n\t\t\t/**\n\t\t\t * @param {Module} module the module\n\t\t\t * @returns {string} the (portable) identifier\n\t\t\t */\n\t\t\tconst getModuleIdentifier = module => {\n\t\t\t\tif (portableIds) {\n\t\t\t\t\treturn identifierUtils.makePathsRelative(\n\t\t\t\t\t\tcompiler.context,\n\t\t\t\t\t\tmodule.identifier(),\n\t\t\t\t\t\tcompilation.cache\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn module.identifier();\n\t\t\t};\n\n\t\t\t/**\n\t\t\t * @param {Chunk} chunk the chunk\n\t\t\t * @returns {string[]} sources of the chunk\n\t\t\t */\n\t\t\tconst getChunkSources = chunk => {\n\t\t\t\t/** @type {string[]} */\n\t\t\t\tconst sources = [];\n\t\t\t\tfor (const chunkGroup of chunk.groupsIterable) {\n\t\t\t\t\tconst index = chunkGroup.chunks.indexOf(chunk);\n\t\t\t\t\tfor (const origin of chunkGroup.origins) {\n\t\t\t\t\t\tif (origin.module) {\n\t\t\t\t\t\t\tif (origin.request) {\n\t\t\t\t\t\t\t\tsources.push(\n\t\t\t\t\t\t\t\t\t`${index} ${getModuleIdentifier(origin.module)} ${\n\t\t\t\t\t\t\t\t\t\torigin.request\n\t\t\t\t\t\t\t\t\t}`\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else if (typeof origin.loc === \"string\") {\n\t\t\t\t\t\t\t\tsources.push(\n\t\t\t\t\t\t\t\t\t`${index} ${getModuleIdentifier(origin.module)} ${origin.loc}`\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\torigin.loc &&\n\t\t\t\t\t\t\t\ttypeof origin.loc === \"object\" &&\n\t\t\t\t\t\t\t\torigin.loc.start\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tsources.push(\n\t\t\t\t\t\t\t\t\t`${index} ${getModuleIdentifier(\n\t\t\t\t\t\t\t\t\t\torigin.module\n\t\t\t\t\t\t\t\t\t)} ${JSON.stringify(origin.loc.start)}`\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn sources;\n\t\t\t};\n\n\t\t\tcompilation.hooks.recordChunks.tap(\n\t\t\t\t\"RecordIdsPlugin\",\n\t\t\t\t/**\n\t\t\t\t * @param {Chunk[]} chunks the chunks array\n\t\t\t\t * @param {Records} records the records object\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\t(chunks, records) => {\n\t\t\t\t\tif (!records.chunks) records.chunks = {};\n\t\t\t\t\tif (!records.chunks.byName) records.chunks.byName = {};\n\t\t\t\t\tif (!records.chunks.bySource) records.chunks.bySource = {};\n\t\t\t\t\t/** @type {Set<number>} */\n\t\t\t\t\tconst usedIds = new Set();\n\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\tif (typeof chunk.id !== \"number\") continue;\n\t\t\t\t\t\tconst name = chunk.name;\n\t\t\t\t\t\tif (name) records.chunks.byName[name] = chunk.id;\n\t\t\t\t\t\tconst sources = getChunkSources(chunk);\n\t\t\t\t\t\tfor (const source of sources) {\n\t\t\t\t\t\t\trecords.chunks.bySource[source] = chunk.id;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tusedIds.add(chunk.id);\n\t\t\t\t\t}\n\t\t\t\t\trecords.chunks.usedIds = Array.from(usedIds).sort();\n\t\t\t\t}\n\t\t\t);\n\t\t\tcompilation.hooks.reviveChunks.tap(\n\t\t\t\t\"RecordIdsPlugin\",\n\t\t\t\t/**\n\t\t\t\t * @param {Chunk[]} chunks the chunks array\n\t\t\t\t * @param {Records} records the records object\n\t\t\t\t * @returns {void}\n\t\t\t\t */\n\t\t\t\t(chunks, records) => {\n\t\t\t\t\tif (!records.chunks) return;\n\t\t\t\t\t/** @type {Set<number>} */\n\t\t\t\t\tconst usedIds = new Set();\n\t\t\t\t\tif (records.chunks.byName) {\n\t\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\t\tif (chunk.id !== null) continue;\n\t\t\t\t\t\t\tif (!chunk.name) continue;\n\t\t\t\t\t\t\tconst id = records.chunks.byName[chunk.name];\n\t\t\t\t\t\t\tif (id === undefined) continue;\n\t\t\t\t\t\t\tif (usedIds.has(id)) continue;\n\t\t\t\t\t\t\tusedIds.add(id);\n\t\t\t\t\t\t\tchunk.id = id;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (records.chunks.bySource) {\n\t\t\t\t\t\tfor (const chunk of chunks) {\n\t\t\t\t\t\t\tconst sources = getChunkSources(chunk);\n\t\t\t\t\t\t\tfor (const source of sources) {\n\t\t\t\t\t\t\t\tconst id = records.chunks.bySource[source];\n\t\t\t\t\t\t\t\tif (id === undefined) continue;\n\t\t\t\t\t\t\t\tif (usedIds.has(id)) continue;\n\t\t\t\t\t\t\t\tusedIds.add(id);\n\t\t\t\t\t\t\t\tchunk.id = id;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (Array.isArray(records.chunks.usedIds)) {\n\t\t\t\t\t\tcompilation.usedChunkIds = new Set(records.chunks.usedIds);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n}\nmodule.exports = RecordIdsPlugin;\n"]},"metadata":{},"sourceType":"script"}