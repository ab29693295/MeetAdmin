{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst mm = require(\"micromatch\");\n\nconst HarmonyExportImportedSpecifierDependency = require(\"../dependencies/HarmonyExportImportedSpecifierDependency\");\n\nconst HarmonyImportSideEffectDependency = require(\"../dependencies/HarmonyImportSideEffectDependency\");\n\nconst HarmonyImportSpecifierDependency = require(\"../dependencies/HarmonyImportSpecifierDependency\");\n/** @typedef {import(\"../Module\")} Module */\n\n/** @typedef {import(\"../Dependency\")} Dependency */\n\n/**\n * @typedef {Object} ExportInModule\n * @property {Module} module the module\n * @property {string} exportName the name of the export\n */\n\n\nclass SideEffectsFlagPlugin {\n  apply(compiler) {\n    compiler.hooks.normalModuleFactory.tap(\"SideEffectsFlagPlugin\", nmf => {\n      nmf.hooks.module.tap(\"SideEffectsFlagPlugin\", (module, data) => {\n        const resolveData = data.resourceResolveData;\n\n        if (resolveData && resolveData.descriptionFileData && resolveData.relativePath) {\n          const sideEffects = resolveData.descriptionFileData.sideEffects;\n          const hasSideEffects = SideEffectsFlagPlugin.moduleHasSideEffects(resolveData.relativePath, sideEffects);\n\n          if (!hasSideEffects) {\n            module.factoryMeta.sideEffectFree = true;\n          }\n        }\n\n        return module;\n      });\n      nmf.hooks.module.tap(\"SideEffectsFlagPlugin\", (module, data) => {\n        if (data.settings.sideEffects === false) {\n          module.factoryMeta.sideEffectFree = true;\n        } else if (data.settings.sideEffects === true) {\n          module.factoryMeta.sideEffectFree = false;\n        }\n      });\n    });\n    compiler.hooks.compilation.tap(\"SideEffectsFlagPlugin\", compilation => {\n      compilation.hooks.optimizeDependencies.tap(\"SideEffectsFlagPlugin\", modules => {\n        /** @type {Map<Module, Map<string, ExportInModule>>} */\n        const reexportMaps = new Map(); // Capture reexports of sideEffectFree modules\n\n        for (const module of modules) {\n          /** @type {Dependency[]} */\n          const removeDependencies = [];\n\n          for (const dep of module.dependencies) {\n            if (dep instanceof HarmonyImportSideEffectDependency) {\n              if (dep.module && dep.module.factoryMeta.sideEffectFree) {\n                removeDependencies.push(dep);\n              }\n            } else if (dep instanceof HarmonyExportImportedSpecifierDependency) {\n              if (module.factoryMeta.sideEffectFree) {\n                const mode = dep.getMode(true);\n\n                if (mode.type === \"safe-reexport\") {\n                  let map = reexportMaps.get(module);\n\n                  if (!map) {\n                    reexportMaps.set(module, map = new Map());\n                  }\n\n                  for (const pair of mode.map) {\n                    map.set(pair[0], {\n                      module: mode.module,\n                      exportName: pair[1]\n                    });\n                  }\n                }\n              }\n            }\n          }\n        } // Flatten reexports\n\n\n        for (const map of reexportMaps.values()) {\n          for (const pair of map) {\n            let mapping = pair[1];\n\n            while (mapping) {\n              const innerMap = reexportMaps.get(mapping.module);\n              if (!innerMap) break;\n              const newMapping = innerMap.get(mapping.exportName);\n\n              if (newMapping) {\n                map.set(pair[0], newMapping);\n              }\n\n              mapping = newMapping;\n            }\n          }\n        } // Update imports along the reexports from sideEffectFree modules\n\n\n        for (const pair of reexportMaps) {\n          const module = pair[0];\n          const map = pair[1];\n          let newReasons = undefined;\n\n          for (let i = 0; i < module.reasons.length; i++) {\n            const reason = module.reasons[i];\n            const dep = reason.dependency;\n\n            if (dep instanceof HarmonyExportImportedSpecifierDependency || dep instanceof HarmonyImportSpecifierDependency && !dep.namespaceObjectAsContext) {\n              const mapping = map.get(dep._id);\n\n              if (mapping) {\n                dep.redirectedModule = mapping.module;\n                dep.redirectedId = mapping.exportName;\n                mapping.module.addReason(reason.module, dep, reason.explanation ? reason.explanation + \" (skipped side-effect-free modules)\" : \"(skipped side-effect-free modules)\"); // removing the currect reason, by not adding it to the newReasons array\n                // lazily create the newReasons array\n\n                if (newReasons === undefined) {\n                  newReasons = i === 0 ? [] : module.reasons.slice(0, i);\n                }\n\n                continue;\n              }\n            }\n\n            if (newReasons !== undefined) newReasons.push(reason);\n          }\n\n          if (newReasons !== undefined) {\n            module.reasons = newReasons;\n          }\n        }\n      });\n    });\n  }\n\n  static moduleHasSideEffects(moduleName, flagValue) {\n    switch (typeof flagValue) {\n      case \"undefined\":\n        return true;\n\n      case \"boolean\":\n        return flagValue;\n\n      case \"string\":\n        if (process.platform === \"win32\") {\n          flagValue = flagValue.replace(/\\\\/g, \"/\");\n        }\n\n        return mm.isMatch(moduleName, flagValue, {\n          matchBase: true\n        });\n\n      case \"object\":\n        return flagValue.some(glob => SideEffectsFlagPlugin.moduleHasSideEffects(moduleName, glob));\n    }\n  }\n\n}\n\nmodule.exports = SideEffectsFlagPlugin;","map":{"version":3,"sources":["E:/Users/cnki/source/repos/ab29693295/MeetAdmin/node_modules/webpack/lib/optimize/SideEffectsFlagPlugin.js"],"names":["mm","require","HarmonyExportImportedSpecifierDependency","HarmonyImportSideEffectDependency","HarmonyImportSpecifierDependency","SideEffectsFlagPlugin","apply","compiler","hooks","normalModuleFactory","tap","nmf","module","data","resolveData","resourceResolveData","descriptionFileData","relativePath","sideEffects","hasSideEffects","moduleHasSideEffects","factoryMeta","sideEffectFree","settings","compilation","optimizeDependencies","modules","reexportMaps","Map","removeDependencies","dep","dependencies","push","mode","getMode","type","map","get","set","pair","exportName","values","mapping","innerMap","newMapping","newReasons","undefined","i","reasons","length","reason","dependency","namespaceObjectAsContext","_id","redirectedModule","redirectedId","addReason","explanation","slice","moduleName","flagValue","process","platform","replace","isMatch","matchBase","some","glob","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\nconst mm = require(\"micromatch\");\nconst HarmonyExportImportedSpecifierDependency = require(\"../dependencies/HarmonyExportImportedSpecifierDependency\");\nconst HarmonyImportSideEffectDependency = require(\"../dependencies/HarmonyImportSideEffectDependency\");\nconst HarmonyImportSpecifierDependency = require(\"../dependencies/HarmonyImportSpecifierDependency\");\n\n/** @typedef {import(\"../Module\")} Module */\n/** @typedef {import(\"../Dependency\")} Dependency */\n\n/**\n * @typedef {Object} ExportInModule\n * @property {Module} module the module\n * @property {string} exportName the name of the export\n */\n\nclass SideEffectsFlagPlugin {\n\tapply(compiler) {\n\t\tcompiler.hooks.normalModuleFactory.tap(\"SideEffectsFlagPlugin\", nmf => {\n\t\t\tnmf.hooks.module.tap(\"SideEffectsFlagPlugin\", (module, data) => {\n\t\t\t\tconst resolveData = data.resourceResolveData;\n\t\t\t\tif (\n\t\t\t\t\tresolveData &&\n\t\t\t\t\tresolveData.descriptionFileData &&\n\t\t\t\t\tresolveData.relativePath\n\t\t\t\t) {\n\t\t\t\t\tconst sideEffects = resolveData.descriptionFileData.sideEffects;\n\t\t\t\t\tconst hasSideEffects = SideEffectsFlagPlugin.moduleHasSideEffects(\n\t\t\t\t\t\tresolveData.relativePath,\n\t\t\t\t\t\tsideEffects\n\t\t\t\t\t);\n\t\t\t\t\tif (!hasSideEffects) {\n\t\t\t\t\t\tmodule.factoryMeta.sideEffectFree = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn module;\n\t\t\t});\n\t\t\tnmf.hooks.module.tap(\"SideEffectsFlagPlugin\", (module, data) => {\n\t\t\t\tif (data.settings.sideEffects === false) {\n\t\t\t\t\tmodule.factoryMeta.sideEffectFree = true;\n\t\t\t\t} else if (data.settings.sideEffects === true) {\n\t\t\t\t\tmodule.factoryMeta.sideEffectFree = false;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\tcompiler.hooks.compilation.tap(\"SideEffectsFlagPlugin\", compilation => {\n\t\t\tcompilation.hooks.optimizeDependencies.tap(\n\t\t\t\t\"SideEffectsFlagPlugin\",\n\t\t\t\tmodules => {\n\t\t\t\t\t/** @type {Map<Module, Map<string, ExportInModule>>} */\n\t\t\t\t\tconst reexportMaps = new Map();\n\n\t\t\t\t\t// Capture reexports of sideEffectFree modules\n\t\t\t\t\tfor (const module of modules) {\n\t\t\t\t\t\t/** @type {Dependency[]} */\n\t\t\t\t\t\tconst removeDependencies = [];\n\t\t\t\t\t\tfor (const dep of module.dependencies) {\n\t\t\t\t\t\t\tif (dep instanceof HarmonyImportSideEffectDependency) {\n\t\t\t\t\t\t\t\tif (dep.module && dep.module.factoryMeta.sideEffectFree) {\n\t\t\t\t\t\t\t\t\tremoveDependencies.push(dep);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t\tdep instanceof HarmonyExportImportedSpecifierDependency\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tif (module.factoryMeta.sideEffectFree) {\n\t\t\t\t\t\t\t\t\tconst mode = dep.getMode(true);\n\t\t\t\t\t\t\t\t\tif (mode.type === \"safe-reexport\") {\n\t\t\t\t\t\t\t\t\t\tlet map = reexportMaps.get(module);\n\t\t\t\t\t\t\t\t\t\tif (!map) {\n\t\t\t\t\t\t\t\t\t\t\treexportMaps.set(module, (map = new Map()));\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tfor (const pair of mode.map) {\n\t\t\t\t\t\t\t\t\t\t\tmap.set(pair[0], {\n\t\t\t\t\t\t\t\t\t\t\t\tmodule: mode.module,\n\t\t\t\t\t\t\t\t\t\t\t\texportName: pair[1]\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Flatten reexports\n\t\t\t\t\tfor (const map of reexportMaps.values()) {\n\t\t\t\t\t\tfor (const pair of map) {\n\t\t\t\t\t\t\tlet mapping = pair[1];\n\t\t\t\t\t\t\twhile (mapping) {\n\t\t\t\t\t\t\t\tconst innerMap = reexportMaps.get(mapping.module);\n\t\t\t\t\t\t\t\tif (!innerMap) break;\n\t\t\t\t\t\t\t\tconst newMapping = innerMap.get(mapping.exportName);\n\t\t\t\t\t\t\t\tif (newMapping) {\n\t\t\t\t\t\t\t\t\tmap.set(pair[0], newMapping);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tmapping = newMapping;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Update imports along the reexports from sideEffectFree modules\n\t\t\t\t\tfor (const pair of reexportMaps) {\n\t\t\t\t\t\tconst module = pair[0];\n\t\t\t\t\t\tconst map = pair[1];\n\t\t\t\t\t\tlet newReasons = undefined;\n\t\t\t\t\t\tfor (let i = 0; i < module.reasons.length; i++) {\n\t\t\t\t\t\t\tconst reason = module.reasons[i];\n\t\t\t\t\t\t\tconst dep = reason.dependency;\n\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\tdep instanceof HarmonyExportImportedSpecifierDependency ||\n\t\t\t\t\t\t\t\t(dep instanceof HarmonyImportSpecifierDependency &&\n\t\t\t\t\t\t\t\t\t!dep.namespaceObjectAsContext)\n\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\tconst mapping = map.get(dep._id);\n\t\t\t\t\t\t\t\tif (mapping) {\n\t\t\t\t\t\t\t\t\tdep.redirectedModule = mapping.module;\n\t\t\t\t\t\t\t\t\tdep.redirectedId = mapping.exportName;\n\t\t\t\t\t\t\t\t\tmapping.module.addReason(\n\t\t\t\t\t\t\t\t\t\treason.module,\n\t\t\t\t\t\t\t\t\t\tdep,\n\t\t\t\t\t\t\t\t\t\treason.explanation\n\t\t\t\t\t\t\t\t\t\t\t? reason.explanation +\n\t\t\t\t\t\t\t\t\t\t\t\t\t\" (skipped side-effect-free modules)\"\n\t\t\t\t\t\t\t\t\t\t\t: \"(skipped side-effect-free modules)\"\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t// removing the currect reason, by not adding it to the newReasons array\n\t\t\t\t\t\t\t\t\t// lazily create the newReasons array\n\t\t\t\t\t\t\t\t\tif (newReasons === undefined) {\n\t\t\t\t\t\t\t\t\t\tnewReasons = i === 0 ? [] : module.reasons.slice(0, i);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (newReasons !== undefined) newReasons.push(reason);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (newReasons !== undefined) {\n\t\t\t\t\t\t\tmodule.reasons = newReasons;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t});\n\t}\n\n\tstatic moduleHasSideEffects(moduleName, flagValue) {\n\t\tswitch (typeof flagValue) {\n\t\t\tcase \"undefined\":\n\t\t\t\treturn true;\n\t\t\tcase \"boolean\":\n\t\t\t\treturn flagValue;\n\t\t\tcase \"string\":\n\t\t\t\tif (process.platform === \"win32\") {\n\t\t\t\t\tflagValue = flagValue.replace(/\\\\/g, \"/\");\n\t\t\t\t}\n\t\t\t\treturn mm.isMatch(moduleName, flagValue, {\n\t\t\t\t\tmatchBase: true\n\t\t\t\t});\n\t\t\tcase \"object\":\n\t\t\t\treturn flagValue.some(glob =>\n\t\t\t\t\tSideEffectsFlagPlugin.moduleHasSideEffects(moduleName, glob)\n\t\t\t\t);\n\t\t}\n\t}\n}\nmodule.exports = SideEffectsFlagPlugin;\n"]},"metadata":{},"sourceType":"script"}