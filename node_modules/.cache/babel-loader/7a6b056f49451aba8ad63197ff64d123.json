{"ast":null,"code":"'use strict';\n\nconst BB = require('bluebird');\n\nconst contentPath = require('./content/path');\n\nconst figgyPudding = require('figgy-pudding');\n\nconst finished = BB.promisify(require('mississippi').finished);\n\nconst fixOwner = require('./util/fix-owner');\n\nconst fs = require('graceful-fs');\n\nconst glob = BB.promisify(require('glob'));\n\nconst index = require('./entry-index');\n\nconst path = require('path');\n\nconst rimraf = BB.promisify(require('rimraf'));\n\nconst ssri = require('ssri');\n\nBB.promisifyAll(fs);\nconst VerifyOpts = figgyPudding({\n  concurrency: {\n    default: 20\n  },\n  filter: {},\n  log: {\n    default: {\n      silly() {}\n\n    }\n  }\n});\nmodule.exports = verify;\n\nfunction verify(cache, opts) {\n  opts = VerifyOpts(opts);\n  opts.log.silly('verify', 'verifying cache at', cache);\n  return BB.reduce([markStartTime, fixPerms, garbageCollect, rebuildIndex, cleanTmp, writeVerifile, markEndTime], (stats, step, i) => {\n    const label = step.name || `step #${i}`;\n    const start = new Date();\n    return BB.resolve(step(cache, opts)).then(s => {\n      s && Object.keys(s).forEach(k => {\n        stats[k] = s[k];\n      });\n      const end = new Date();\n\n      if (!stats.runTime) {\n        stats.runTime = {};\n      }\n\n      stats.runTime[label] = end - start;\n      return stats;\n    });\n  }, {}).tap(stats => {\n    stats.runTime.total = stats.endTime - stats.startTime;\n    opts.log.silly('verify', 'verification finished for', cache, 'in', `${stats.runTime.total}ms`);\n  });\n}\n\nfunction markStartTime(cache, opts) {\n  return {\n    startTime: new Date()\n  };\n}\n\nfunction markEndTime(cache, opts) {\n  return {\n    endTime: new Date()\n  };\n}\n\nfunction fixPerms(cache, opts) {\n  opts.log.silly('verify', 'fixing cache permissions');\n  return fixOwner.mkdirfix(cache, cache).then(() => {\n    // TODO - fix file permissions too\n    return fixOwner.chownr(cache, cache);\n  }).then(() => null);\n} // Implements a naive mark-and-sweep tracing garbage collector.\n//\n// The algorithm is basically as follows:\n// 1. Read (and filter) all index entries (\"pointers\")\n// 2. Mark each integrity value as \"live\"\n// 3. Read entire filesystem tree in `content-vX/` dir\n// 4. If content is live, verify its checksum and delete it if it fails\n// 5. If content is not marked as live, rimraf it.\n//\n\n\nfunction garbageCollect(cache, opts) {\n  opts.log.silly('verify', 'garbage collecting content');\n  const indexStream = index.lsStream(cache);\n  const liveContent = new Set();\n  indexStream.on('data', entry => {\n    if (opts.filter && !opts.filter(entry)) {\n      return;\n    }\n\n    liveContent.add(entry.integrity.toString());\n  });\n  return finished(indexStream).then(() => {\n    const contentDir = contentPath._contentDir(cache);\n\n    return glob(path.join(contentDir, '**'), {\n      follow: false,\n      nodir: true,\n      nosort: true\n    }).then(files => {\n      return BB.resolve({\n        verifiedContent: 0,\n        reclaimedCount: 0,\n        reclaimedSize: 0,\n        badContentCount: 0,\n        keptSize: 0\n      }).tap(stats => BB.map(files, f => {\n        const split = f.split(/[/\\\\]/);\n        const digest = split.slice(split.length - 3).join('');\n        const algo = split[split.length - 4];\n        const integrity = ssri.fromHex(digest, algo);\n\n        if (liveContent.has(integrity.toString())) {\n          return verifyContent(f, integrity).then(info => {\n            if (!info.valid) {\n              stats.reclaimedCount++;\n              stats.badContentCount++;\n              stats.reclaimedSize += info.size;\n            } else {\n              stats.verifiedContent++;\n              stats.keptSize += info.size;\n            }\n\n            return stats;\n          });\n        } else {\n          // No entries refer to this content. We can delete.\n          stats.reclaimedCount++;\n          return fs.statAsync(f).then(s => {\n            return rimraf(f).then(() => {\n              stats.reclaimedSize += s.size;\n              return stats;\n            });\n          });\n        }\n      }, {\n        concurrency: opts.concurrency\n      }));\n    });\n  });\n}\n\nfunction verifyContent(filepath, sri) {\n  return fs.statAsync(filepath).then(stat => {\n    const contentInfo = {\n      size: stat.size,\n      valid: true\n    };\n    return ssri.checkStream(fs.createReadStream(filepath), sri).catch(err => {\n      if (err.code !== 'EINTEGRITY') {\n        throw err;\n      }\n\n      return rimraf(filepath).then(() => {\n        contentInfo.valid = false;\n      });\n    }).then(() => contentInfo);\n  }).catch({\n    code: 'ENOENT'\n  }, () => ({\n    size: 0,\n    valid: false\n  }));\n}\n\nfunction rebuildIndex(cache, opts) {\n  opts.log.silly('verify', 'rebuilding index');\n  return index.ls(cache).then(entries => {\n    const stats = {\n      missingContent: 0,\n      rejectedEntries: 0,\n      totalEntries: 0\n    };\n    const buckets = {};\n\n    for (let k in entries) {\n      if (entries.hasOwnProperty(k)) {\n        const hashed = index._hashKey(k);\n\n        const entry = entries[k];\n        const excluded = opts.filter && !opts.filter(entry);\n        excluded && stats.rejectedEntries++;\n\n        if (buckets[hashed] && !excluded) {\n          buckets[hashed].push(entry);\n        } else if (buckets[hashed] && excluded) {// skip\n        } else if (excluded) {\n          buckets[hashed] = [];\n          buckets[hashed]._path = index._bucketPath(cache, k);\n        } else {\n          buckets[hashed] = [entry];\n          buckets[hashed]._path = index._bucketPath(cache, k);\n        }\n      }\n    }\n\n    return BB.map(Object.keys(buckets), key => {\n      return rebuildBucket(cache, buckets[key], stats, opts);\n    }, {\n      concurrency: opts.concurrency\n    }).then(() => stats);\n  });\n}\n\nfunction rebuildBucket(cache, bucket, stats, opts) {\n  return fs.truncateAsync(bucket._path).then(() => {\n    // This needs to be serialized because cacache explicitly\n    // lets very racy bucket conflicts clobber each other.\n    return BB.mapSeries(bucket, entry => {\n      const content = contentPath(cache, entry.integrity);\n      return fs.statAsync(content).then(() => {\n        return index.insert(cache, entry.key, entry.integrity, {\n          metadata: entry.metadata,\n          size: entry.size\n        }).then(() => {\n          stats.totalEntries++;\n        });\n      }).catch({\n        code: 'ENOENT'\n      }, () => {\n        stats.rejectedEntries++;\n        stats.missingContent++;\n      });\n    });\n  });\n}\n\nfunction cleanTmp(cache, opts) {\n  opts.log.silly('verify', 'cleaning tmp directory');\n  return rimraf(path.join(cache, 'tmp'));\n}\n\nfunction writeVerifile(cache, opts) {\n  const verifile = path.join(cache, '_lastverified');\n  opts.log.silly('verify', 'writing verifile to ' + verifile);\n\n  try {\n    return fs.writeFileAsync(verifile, '' + +new Date());\n  } finally {\n    fixOwner.chownr.sync(cache, verifile);\n  }\n}\n\nmodule.exports.lastRun = lastRun;\n\nfunction lastRun(cache) {\n  return fs.readFileAsync(path.join(cache, '_lastverified'), 'utf8').then(data => new Date(+data));\n}","map":{"version":3,"sources":["E:/Users/cnki/source/repos/ab29693295/MeetAdmin/node_modules/webpack/node_modules/cacache/lib/verify.js"],"names":["BB","require","contentPath","figgyPudding","finished","promisify","fixOwner","fs","glob","index","path","rimraf","ssri","promisifyAll","VerifyOpts","concurrency","default","filter","log","silly","module","exports","verify","cache","opts","reduce","markStartTime","fixPerms","garbageCollect","rebuildIndex","cleanTmp","writeVerifile","markEndTime","stats","step","i","label","name","start","Date","resolve","then","s","Object","keys","forEach","k","end","runTime","tap","total","endTime","startTime","mkdirfix","chownr","indexStream","lsStream","liveContent","Set","on","entry","add","integrity","toString","contentDir","_contentDir","join","follow","nodir","nosort","files","verifiedContent","reclaimedCount","reclaimedSize","badContentCount","keptSize","map","f","split","digest","slice","length","algo","fromHex","has","verifyContent","info","valid","size","statAsync","filepath","sri","stat","contentInfo","checkStream","createReadStream","catch","err","code","ls","entries","missingContent","rejectedEntries","totalEntries","buckets","hasOwnProperty","hashed","_hashKey","excluded","push","_path","_bucketPath","key","rebuildBucket","bucket","truncateAsync","mapSeries","content","insert","metadata","verifile","writeFileAsync","sync","lastRun","readFileAsync","data"],"mappings":"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","sourcesContent":["'use strict'\n\nconst BB = require('bluebird')\n\nconst contentPath = require('./content/path')\nconst figgyPudding = require('figgy-pudding')\nconst finished = BB.promisify(require('mississippi').finished)\nconst fixOwner = require('./util/fix-owner')\nconst fs = require('graceful-fs')\nconst glob = BB.promisify(require('glob'))\nconst index = require('./entry-index')\nconst path = require('path')\nconst rimraf = BB.promisify(require('rimraf'))\nconst ssri = require('ssri')\n\nBB.promisifyAll(fs)\n\nconst VerifyOpts = figgyPudding({\n  concurrency: {\n    default: 20\n  },\n  filter: {},\n  log: {\n    default: { silly () {} }\n  }\n})\n\nmodule.exports = verify\nfunction verify (cache, opts) {\n  opts = VerifyOpts(opts)\n  opts.log.silly('verify', 'verifying cache at', cache)\n  return BB.reduce([\n    markStartTime,\n    fixPerms,\n    garbageCollect,\n    rebuildIndex,\n    cleanTmp,\n    writeVerifile,\n    markEndTime\n  ], (stats, step, i) => {\n    const label = step.name || `step #${i}`\n    const start = new Date()\n    return BB.resolve(step(cache, opts)).then(s => {\n      s && Object.keys(s).forEach(k => {\n        stats[k] = s[k]\n      })\n      const end = new Date()\n      if (!stats.runTime) { stats.runTime = {} }\n      stats.runTime[label] = end - start\n      return stats\n    })\n  }, {}).tap(stats => {\n    stats.runTime.total = stats.endTime - stats.startTime\n    opts.log.silly('verify', 'verification finished for', cache, 'in', `${stats.runTime.total}ms`)\n  })\n}\n\nfunction markStartTime (cache, opts) {\n  return { startTime: new Date() }\n}\n\nfunction markEndTime (cache, opts) {\n  return { endTime: new Date() }\n}\n\nfunction fixPerms (cache, opts) {\n  opts.log.silly('verify', 'fixing cache permissions')\n  return fixOwner.mkdirfix(cache, cache).then(() => {\n    // TODO - fix file permissions too\n    return fixOwner.chownr(cache, cache)\n  }).then(() => null)\n}\n\n// Implements a naive mark-and-sweep tracing garbage collector.\n//\n// The algorithm is basically as follows:\n// 1. Read (and filter) all index entries (\"pointers\")\n// 2. Mark each integrity value as \"live\"\n// 3. Read entire filesystem tree in `content-vX/` dir\n// 4. If content is live, verify its checksum and delete it if it fails\n// 5. If content is not marked as live, rimraf it.\n//\nfunction garbageCollect (cache, opts) {\n  opts.log.silly('verify', 'garbage collecting content')\n  const indexStream = index.lsStream(cache)\n  const liveContent = new Set()\n  indexStream.on('data', entry => {\n    if (opts.filter && !opts.filter(entry)) { return }\n    liveContent.add(entry.integrity.toString())\n  })\n  return finished(indexStream).then(() => {\n    const contentDir = contentPath._contentDir(cache)\n    return glob(path.join(contentDir, '**'), {\n      follow: false,\n      nodir: true,\n      nosort: true\n    }).then(files => {\n      return BB.resolve({\n        verifiedContent: 0,\n        reclaimedCount: 0,\n        reclaimedSize: 0,\n        badContentCount: 0,\n        keptSize: 0\n      }).tap((stats) => BB.map(files, (f) => {\n        const split = f.split(/[/\\\\]/)\n        const digest = split.slice(split.length - 3).join('')\n        const algo = split[split.length - 4]\n        const integrity = ssri.fromHex(digest, algo)\n        if (liveContent.has(integrity.toString())) {\n          return verifyContent(f, integrity).then(info => {\n            if (!info.valid) {\n              stats.reclaimedCount++\n              stats.badContentCount++\n              stats.reclaimedSize += info.size\n            } else {\n              stats.verifiedContent++\n              stats.keptSize += info.size\n            }\n            return stats\n          })\n        } else {\n          // No entries refer to this content. We can delete.\n          stats.reclaimedCount++\n          return fs.statAsync(f).then(s => {\n            return rimraf(f).then(() => {\n              stats.reclaimedSize += s.size\n              return stats\n            })\n          })\n        }\n      }, { concurrency: opts.concurrency }))\n    })\n  })\n}\n\nfunction verifyContent (filepath, sri) {\n  return fs.statAsync(filepath).then(stat => {\n    const contentInfo = {\n      size: stat.size,\n      valid: true\n    }\n    return ssri.checkStream(\n      fs.createReadStream(filepath),\n      sri\n    ).catch(err => {\n      if (err.code !== 'EINTEGRITY') { throw err }\n      return rimraf(filepath).then(() => {\n        contentInfo.valid = false\n      })\n    }).then(() => contentInfo)\n  }).catch({ code: 'ENOENT' }, () => ({ size: 0, valid: false }))\n}\n\nfunction rebuildIndex (cache, opts) {\n  opts.log.silly('verify', 'rebuilding index')\n  return index.ls(cache).then(entries => {\n    const stats = {\n      missingContent: 0,\n      rejectedEntries: 0,\n      totalEntries: 0\n    }\n    const buckets = {}\n    for (let k in entries) {\n      if (entries.hasOwnProperty(k)) {\n        const hashed = index._hashKey(k)\n        const entry = entries[k]\n        const excluded = opts.filter && !opts.filter(entry)\n        excluded && stats.rejectedEntries++\n        if (buckets[hashed] && !excluded) {\n          buckets[hashed].push(entry)\n        } else if (buckets[hashed] && excluded) {\n          // skip\n        } else if (excluded) {\n          buckets[hashed] = []\n          buckets[hashed]._path = index._bucketPath(cache, k)\n        } else {\n          buckets[hashed] = [entry]\n          buckets[hashed]._path = index._bucketPath(cache, k)\n        }\n      }\n    }\n    return BB.map(Object.keys(buckets), key => {\n      return rebuildBucket(cache, buckets[key], stats, opts)\n    }, { concurrency: opts.concurrency }).then(() => stats)\n  })\n}\n\nfunction rebuildBucket (cache, bucket, stats, opts) {\n  return fs.truncateAsync(bucket._path).then(() => {\n    // This needs to be serialized because cacache explicitly\n    // lets very racy bucket conflicts clobber each other.\n    return BB.mapSeries(bucket, entry => {\n      const content = contentPath(cache, entry.integrity)\n      return fs.statAsync(content).then(() => {\n        return index.insert(cache, entry.key, entry.integrity, {\n          metadata: entry.metadata,\n          size: entry.size\n        }).then(() => { stats.totalEntries++ })\n      }).catch({ code: 'ENOENT' }, () => {\n        stats.rejectedEntries++\n        stats.missingContent++\n      })\n    })\n  })\n}\n\nfunction cleanTmp (cache, opts) {\n  opts.log.silly('verify', 'cleaning tmp directory')\n  return rimraf(path.join(cache, 'tmp'))\n}\n\nfunction writeVerifile (cache, opts) {\n  const verifile = path.join(cache, '_lastverified')\n  opts.log.silly('verify', 'writing verifile to ' + verifile)\n  try {\n    return fs.writeFileAsync(verifile, '' + (+(new Date())))\n  } finally {\n    fixOwner.chownr.sync(cache, verifile)\n  }\n}\n\nmodule.exports.lastRun = lastRun\nfunction lastRun (cache) {\n  return fs.readFileAsync(\n    path.join(cache, '_lastverified'), 'utf8'\n  ).then(data => new Date(+data))\n}\n"]},"metadata":{},"sourceType":"script"}