{"ast":null,"code":"/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\"; // Syntax: https://developer.mozilla.org/en/SpiderMonkey/Parser_API\n\nconst acorn = require(\"acorn\");\n\nconst {\n  Tapable,\n  SyncBailHook,\n  HookMap\n} = require(\"tapable\");\n\nconst util = require(\"util\");\n\nconst vm = require(\"vm\");\n\nconst BasicEvaluatedExpression = require(\"./BasicEvaluatedExpression\");\n\nconst StackedSetMap = require(\"./util/StackedSetMap\");\n\nconst acornParser = acorn.Parser;\n\nconst joinRanges = (startRange, endRange) => {\n  if (!endRange) return startRange;\n  if (!startRange) return endRange;\n  return [startRange[0], endRange[1]];\n};\n\nconst defaultParserOptions = {\n  ranges: true,\n  locations: true,\n  ecmaVersion: 11,\n  sourceType: \"module\",\n  onComment: null\n}; // regexp to match at least one \"magic comment\"\n\nconst webpackCommentRegExp = new RegExp(/(^|\\W)webpack[A-Z]{1,}[A-Za-z]{1,}:/);\nconst EMPTY_COMMENT_OPTIONS = {\n  options: null,\n  errors: null\n};\n\nclass Parser extends Tapable {\n  constructor(options, sourceType = \"auto\") {\n    super();\n    this.hooks = {\n      evaluateTypeof: new HookMap(() => new SyncBailHook([\"expression\"])),\n      evaluate: new HookMap(() => new SyncBailHook([\"expression\"])),\n      evaluateIdentifier: new HookMap(() => new SyncBailHook([\"expression\"])),\n      evaluateDefinedIdentifier: new HookMap(() => new SyncBailHook([\"expression\"])),\n      evaluateCallExpressionMember: new HookMap(() => new SyncBailHook([\"expression\", \"param\"])),\n      statement: new SyncBailHook([\"statement\"]),\n      statementIf: new SyncBailHook([\"statement\"]),\n      label: new HookMap(() => new SyncBailHook([\"statement\"])),\n      import: new SyncBailHook([\"statement\", \"source\"]),\n      importSpecifier: new SyncBailHook([\"statement\", \"source\", \"exportName\", \"identifierName\"]),\n      export: new SyncBailHook([\"statement\"]),\n      exportImport: new SyncBailHook([\"statement\", \"source\"]),\n      exportDeclaration: new SyncBailHook([\"statement\", \"declaration\"]),\n      exportExpression: new SyncBailHook([\"statement\", \"declaration\"]),\n      exportSpecifier: new SyncBailHook([\"statement\", \"identifierName\", \"exportName\", \"index\"]),\n      exportImportSpecifier: new SyncBailHook([\"statement\", \"source\", \"identifierName\", \"exportName\", \"index\"]),\n      varDeclaration: new HookMap(() => new SyncBailHook([\"declaration\"])),\n      varDeclarationLet: new HookMap(() => new SyncBailHook([\"declaration\"])),\n      varDeclarationConst: new HookMap(() => new SyncBailHook([\"declaration\"])),\n      varDeclarationVar: new HookMap(() => new SyncBailHook([\"declaration\"])),\n      canRename: new HookMap(() => new SyncBailHook([\"initExpression\"])),\n      rename: new HookMap(() => new SyncBailHook([\"initExpression\"])),\n      assigned: new HookMap(() => new SyncBailHook([\"expression\"])),\n      assign: new HookMap(() => new SyncBailHook([\"expression\"])),\n      typeof: new HookMap(() => new SyncBailHook([\"expression\"])),\n      importCall: new SyncBailHook([\"expression\"]),\n      call: new HookMap(() => new SyncBailHook([\"expression\"])),\n      callAnyMember: new HookMap(() => new SyncBailHook([\"expression\"])),\n      new: new HookMap(() => new SyncBailHook([\"expression\"])),\n      expression: new HookMap(() => new SyncBailHook([\"expression\"])),\n      expressionAnyMember: new HookMap(() => new SyncBailHook([\"expression\"])),\n      expressionConditionalOperator: new SyncBailHook([\"expression\"]),\n      expressionLogicalOperator: new SyncBailHook([\"expression\"]),\n      program: new SyncBailHook([\"ast\", \"comments\"])\n    };\n    const HOOK_MAP_COMPAT_CONFIG = {\n      evaluateTypeof: /^evaluate typeof (.+)$/,\n      evaluateIdentifier: /^evaluate Identifier (.+)$/,\n      evaluateDefinedIdentifier: /^evaluate defined Identifier (.+)$/,\n      evaluateCallExpressionMember: /^evaluate CallExpression .(.+)$/,\n      evaluate: /^evaluate (.+)$/,\n      label: /^label (.+)$/,\n      varDeclarationLet: /^var-let (.+)$/,\n      varDeclarationConst: /^var-const (.+)$/,\n      varDeclarationVar: /^var-var (.+)$/,\n      varDeclaration: /^var (.+)$/,\n      canRename: /^can-rename (.+)$/,\n      rename: /^rename (.+)$/,\n      typeof: /^typeof (.+)$/,\n      assigned: /^assigned (.+)$/,\n      assign: /^assign (.+)$/,\n      callAnyMember: /^call (.+)\\.\\*$/,\n      call: /^call (.+)$/,\n      new: /^new (.+)$/,\n      expressionConditionalOperator: /^expression \\?:$/,\n      expressionAnyMember: /^expression (.+)\\.\\*$/,\n      expression: /^expression (.+)$/\n    };\n\n    this._pluginCompat.tap(\"Parser\", options => {\n      for (const name of Object.keys(HOOK_MAP_COMPAT_CONFIG)) {\n        const regexp = HOOK_MAP_COMPAT_CONFIG[name];\n        const match = regexp.exec(options.name);\n\n        if (match) {\n          if (match[1]) {\n            this.hooks[name].tap(match[1], options.fn.name || \"unnamed compat plugin\", options.fn.bind(this));\n          } else {\n            this.hooks[name].tap(options.fn.name || \"unnamed compat plugin\", options.fn.bind(this));\n          }\n\n          return true;\n        }\n      }\n    });\n\n    this.options = options;\n    this.sourceType = sourceType;\n    this.scope = undefined;\n    this.state = undefined;\n    this.comments = undefined;\n    this.initializeEvaluating();\n  }\n\n  initializeEvaluating() {\n    this.hooks.evaluate.for(\"Literal\").tap(\"Parser\", expr => {\n      switch (typeof expr.value) {\n        case \"number\":\n          return new BasicEvaluatedExpression().setNumber(expr.value).setRange(expr.range);\n\n        case \"string\":\n          return new BasicEvaluatedExpression().setString(expr.value).setRange(expr.range);\n\n        case \"boolean\":\n          return new BasicEvaluatedExpression().setBoolean(expr.value).setRange(expr.range);\n      }\n\n      if (expr.value === null) {\n        return new BasicEvaluatedExpression().setNull().setRange(expr.range);\n      }\n\n      if (expr.value instanceof RegExp) {\n        return new BasicEvaluatedExpression().setRegExp(expr.value).setRange(expr.range);\n      }\n    });\n    this.hooks.evaluate.for(\"LogicalExpression\").tap(\"Parser\", expr => {\n      let left;\n      let leftAsBool;\n      let right;\n\n      if (expr.operator === \"&&\") {\n        left = this.evaluateExpression(expr.left);\n        leftAsBool = left && left.asBool();\n        if (leftAsBool === false) return left.setRange(expr.range);\n        if (leftAsBool !== true) return;\n        right = this.evaluateExpression(expr.right);\n        return right.setRange(expr.range);\n      } else if (expr.operator === \"||\") {\n        left = this.evaluateExpression(expr.left);\n        leftAsBool = left && left.asBool();\n        if (leftAsBool === true) return left.setRange(expr.range);\n        if (leftAsBool !== false) return;\n        right = this.evaluateExpression(expr.right);\n        return right.setRange(expr.range);\n      }\n    });\n    this.hooks.evaluate.for(\"BinaryExpression\").tap(\"Parser\", expr => {\n      let left;\n      let right;\n      let res;\n\n      if (expr.operator === \"+\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        res = new BasicEvaluatedExpression();\n\n        if (left.isString()) {\n          if (right.isString()) {\n            res.setString(left.string + right.string);\n          } else if (right.isNumber()) {\n            res.setString(left.string + right.number);\n          } else if (right.isWrapped() && right.prefix && right.prefix.isString()) {\n            // \"left\" + (\"prefix\" + inner + \"postfix\")\n            // => (\"leftprefix\" + inner + \"postfix\")\n            res.setWrapped(new BasicEvaluatedExpression().setString(left.string + right.prefix.string).setRange(joinRanges(left.range, right.prefix.range)), right.postfix, right.wrappedInnerExpressions);\n          } else if (right.isWrapped()) {\n            // \"left\" + ([null] + inner + \"postfix\")\n            // => (\"left\" + inner + \"postfix\")\n            res.setWrapped(left, right.postfix, right.wrappedInnerExpressions);\n          } else {\n            // \"left\" + expr\n            // => (\"left\" + expr + \"\")\n            res.setWrapped(left, null, [right]);\n          }\n        } else if (left.isNumber()) {\n          if (right.isString()) {\n            res.setString(left.number + right.string);\n          } else if (right.isNumber()) {\n            res.setNumber(left.number + right.number);\n          } else {\n            return;\n          }\n        } else if (left.isWrapped()) {\n          if (left.postfix && left.postfix.isString() && right.isString()) {\n            // (\"prefix\" + inner + \"postfix\") + \"right\"\n            // => (\"prefix\" + inner + \"postfixright\")\n            res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(left.postfix.string + right.string).setRange(joinRanges(left.postfix.range, right.range)), left.wrappedInnerExpressions);\n          } else if (left.postfix && left.postfix.isString() && right.isNumber()) {\n            // (\"prefix\" + inner + \"postfix\") + 123\n            // => (\"prefix\" + inner + \"postfix123\")\n            res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(left.postfix.string + right.number).setRange(joinRanges(left.postfix.range, right.range)), left.wrappedInnerExpressions);\n          } else if (right.isString()) {\n            // (\"prefix\" + inner + [null]) + \"right\"\n            // => (\"prefix\" + inner + \"right\")\n            res.setWrapped(left.prefix, right, left.wrappedInnerExpressions);\n          } else if (right.isNumber()) {\n            // (\"prefix\" + inner + [null]) + 123\n            // => (\"prefix\" + inner + \"123\")\n            res.setWrapped(left.prefix, new BasicEvaluatedExpression().setString(right.number + \"\").setRange(right.range), left.wrappedInnerExpressions);\n          } else if (right.isWrapped()) {\n            // (\"prefix1\" + inner1 + \"postfix1\") + (\"prefix2\" + inner2 + \"postfix2\")\n            // (\"prefix1\" + inner1 + \"postfix1\" + \"prefix2\" + inner2 + \"postfix2\")\n            res.setWrapped(left.prefix, right.postfix, left.wrappedInnerExpressions && right.wrappedInnerExpressions && left.wrappedInnerExpressions.concat(left.postfix ? [left.postfix] : []).concat(right.prefix ? [right.prefix] : []).concat(right.wrappedInnerExpressions));\n          } else {\n            // (\"prefix\" + inner + postfix) + expr\n            // => (\"prefix\" + inner + postfix + expr + [null])\n            res.setWrapped(left.prefix, null, left.wrappedInnerExpressions && left.wrappedInnerExpressions.concat(left.postfix ? [left.postfix, right] : [right]));\n          }\n        } else {\n          if (right.isString()) {\n            // left + \"right\"\n            // => ([null] + left + \"right\")\n            res.setWrapped(null, right, [left]);\n          } else if (right.isWrapped()) {\n            // left + (prefix + inner + \"postfix\")\n            // => ([null] + left + prefix + inner + \"postfix\")\n            res.setWrapped(null, right.postfix, right.wrappedInnerExpressions && (right.prefix ? [left, right.prefix] : [left]).concat(right.wrappedInnerExpressions));\n          } else {\n            return;\n          }\n        }\n\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \"-\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        if (!left.isNumber() || !right.isNumber()) return;\n        res = new BasicEvaluatedExpression();\n        res.setNumber(left.number - right.number);\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \"*\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        if (!left.isNumber() || !right.isNumber()) return;\n        res = new BasicEvaluatedExpression();\n        res.setNumber(left.number * right.number);\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \"/\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        if (!left.isNumber() || !right.isNumber()) return;\n        res = new BasicEvaluatedExpression();\n        res.setNumber(left.number / right.number);\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \"**\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        if (!left.isNumber() || !right.isNumber()) return;\n        res = new BasicEvaluatedExpression();\n        res.setNumber(Math.pow(left.number, right.number));\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \"==\" || expr.operator === \"===\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        res = new BasicEvaluatedExpression();\n        res.setRange(expr.range);\n\n        if (left.isString() && right.isString()) {\n          return res.setBoolean(left.string === right.string);\n        } else if (left.isNumber() && right.isNumber()) {\n          return res.setBoolean(left.number === right.number);\n        } else if (left.isBoolean() && right.isBoolean()) {\n          return res.setBoolean(left.bool === right.bool);\n        }\n      } else if (expr.operator === \"!=\" || expr.operator === \"!==\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        res = new BasicEvaluatedExpression();\n        res.setRange(expr.range);\n\n        if (left.isString() && right.isString()) {\n          return res.setBoolean(left.string !== right.string);\n        } else if (left.isNumber() && right.isNumber()) {\n          return res.setBoolean(left.number !== right.number);\n        } else if (left.isBoolean() && right.isBoolean()) {\n          return res.setBoolean(left.bool !== right.bool);\n        }\n      } else if (expr.operator === \"&\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        if (!left.isNumber() || !right.isNumber()) return;\n        res = new BasicEvaluatedExpression();\n        res.setNumber(left.number & right.number);\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \"|\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        if (!left.isNumber() || !right.isNumber()) return;\n        res = new BasicEvaluatedExpression();\n        res.setNumber(left.number | right.number);\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \"^\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        if (!left.isNumber() || !right.isNumber()) return;\n        res = new BasicEvaluatedExpression();\n        res.setNumber(left.number ^ right.number);\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \">>>\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        if (!left.isNumber() || !right.isNumber()) return;\n        res = new BasicEvaluatedExpression();\n        res.setNumber(left.number >>> right.number);\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \">>\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        if (!left.isNumber() || !right.isNumber()) return;\n        res = new BasicEvaluatedExpression();\n        res.setNumber(left.number >> right.number);\n        res.setRange(expr.range);\n        return res;\n      } else if (expr.operator === \"<<\") {\n        left = this.evaluateExpression(expr.left);\n        right = this.evaluateExpression(expr.right);\n        if (!left || !right) return;\n        if (!left.isNumber() || !right.isNumber()) return;\n        res = new BasicEvaluatedExpression();\n        res.setNumber(left.number << right.number);\n        res.setRange(expr.range);\n        return res;\n      }\n    });\n    this.hooks.evaluate.for(\"UnaryExpression\").tap(\"Parser\", expr => {\n      if (expr.operator === \"typeof\") {\n        let res;\n        let name;\n\n        if (expr.argument.type === \"Identifier\") {\n          name = this.scope.renames.get(expr.argument.name) || expr.argument.name;\n\n          if (!this.scope.definitions.has(name)) {\n            const hook = this.hooks.evaluateTypeof.get(name);\n\n            if (hook !== undefined) {\n              res = hook.call(expr);\n              if (res !== undefined) return res;\n            }\n          }\n        }\n\n        if (expr.argument.type === \"MemberExpression\") {\n          const exprName = this.getNameForExpression(expr.argument);\n\n          if (exprName && exprName.free) {\n            const hook = this.hooks.evaluateTypeof.get(exprName.name);\n\n            if (hook !== undefined) {\n              res = hook.call(expr);\n              if (res !== undefined) return res;\n            }\n          }\n        }\n\n        if (expr.argument.type === \"FunctionExpression\") {\n          return new BasicEvaluatedExpression().setString(\"function\").setRange(expr.range);\n        }\n\n        const arg = this.evaluateExpression(expr.argument);\n\n        if (arg.isString() || arg.isWrapped()) {\n          return new BasicEvaluatedExpression().setString(\"string\").setRange(expr.range);\n        }\n\n        if (arg.isNumber()) {\n          return new BasicEvaluatedExpression().setString(\"number\").setRange(expr.range);\n        }\n\n        if (arg.isBoolean()) {\n          return new BasicEvaluatedExpression().setString(\"boolean\").setRange(expr.range);\n        }\n\n        if (arg.isArray() || arg.isConstArray() || arg.isRegExp()) {\n          return new BasicEvaluatedExpression().setString(\"object\").setRange(expr.range);\n        }\n      } else if (expr.operator === \"!\") {\n        const argument = this.evaluateExpression(expr.argument);\n        if (!argument) return;\n\n        if (argument.isBoolean()) {\n          return new BasicEvaluatedExpression().setBoolean(!argument.bool).setRange(expr.range);\n        }\n\n        if (argument.isTruthy()) {\n          return new BasicEvaluatedExpression().setBoolean(false).setRange(expr.range);\n        }\n\n        if (argument.isFalsy()) {\n          return new BasicEvaluatedExpression().setBoolean(true).setRange(expr.range);\n        }\n\n        if (argument.isString()) {\n          return new BasicEvaluatedExpression().setBoolean(!argument.string).setRange(expr.range);\n        }\n\n        if (argument.isNumber()) {\n          return new BasicEvaluatedExpression().setBoolean(!argument.number).setRange(expr.range);\n        }\n      } else if (expr.operator === \"~\") {\n        const argument = this.evaluateExpression(expr.argument);\n        if (!argument) return;\n        if (!argument.isNumber()) return;\n        const res = new BasicEvaluatedExpression();\n        res.setNumber(~argument.number);\n        res.setRange(expr.range);\n        return res;\n      }\n    });\n    this.hooks.evaluateTypeof.for(\"undefined\").tap(\"Parser\", expr => {\n      return new BasicEvaluatedExpression().setString(\"undefined\").setRange(expr.range);\n    });\n    this.hooks.evaluate.for(\"Identifier\").tap(\"Parser\", expr => {\n      const name = this.scope.renames.get(expr.name) || expr.name;\n\n      if (!this.scope.definitions.has(expr.name)) {\n        const hook = this.hooks.evaluateIdentifier.get(name);\n\n        if (hook !== undefined) {\n          const result = hook.call(expr);\n          if (result) return result;\n        }\n\n        return new BasicEvaluatedExpression().setIdentifier(name).setRange(expr.range);\n      } else {\n        const hook = this.hooks.evaluateDefinedIdentifier.get(name);\n\n        if (hook !== undefined) {\n          return hook.call(expr);\n        }\n      }\n    });\n    this.hooks.evaluate.for(\"ThisExpression\").tap(\"Parser\", expr => {\n      const name = this.scope.renames.get(\"this\");\n\n      if (name) {\n        const hook = this.hooks.evaluateIdentifier.get(name);\n\n        if (hook !== undefined) {\n          const result = hook.call(expr);\n          if (result) return result;\n        }\n\n        return new BasicEvaluatedExpression().setIdentifier(name).setRange(expr.range);\n      }\n    });\n    this.hooks.evaluate.for(\"MemberExpression\").tap(\"Parser\", expression => {\n      let exprName = this.getNameForExpression(expression);\n\n      if (exprName) {\n        if (exprName.free) {\n          const hook = this.hooks.evaluateIdentifier.get(exprName.name);\n\n          if (hook !== undefined) {\n            const result = hook.call(expression);\n            if (result) return result;\n          }\n\n          return new BasicEvaluatedExpression().setIdentifier(exprName.name).setRange(expression.range);\n        } else {\n          const hook = this.hooks.evaluateDefinedIdentifier.get(exprName.name);\n\n          if (hook !== undefined) {\n            return hook.call(expression);\n          }\n        }\n      }\n    });\n    this.hooks.evaluate.for(\"CallExpression\").tap(\"Parser\", expr => {\n      if (expr.callee.type !== \"MemberExpression\") return;\n      if (expr.callee.property.type !== (expr.callee.computed ? \"Literal\" : \"Identifier\")) return;\n      const param = this.evaluateExpression(expr.callee.object);\n      if (!param) return;\n      const property = expr.callee.property.name || expr.callee.property.value;\n      const hook = this.hooks.evaluateCallExpressionMember.get(property);\n\n      if (hook !== undefined) {\n        return hook.call(expr, param);\n      }\n    });\n    this.hooks.evaluateCallExpressionMember.for(\"replace\").tap(\"Parser\", (expr, param) => {\n      if (!param.isString()) return;\n      if (expr.arguments.length !== 2) return;\n      let arg1 = this.evaluateExpression(expr.arguments[0]);\n      let arg2 = this.evaluateExpression(expr.arguments[1]);\n      if (!arg1.isString() && !arg1.isRegExp()) return;\n      arg1 = arg1.regExp || arg1.string;\n      if (!arg2.isString()) return;\n      arg2 = arg2.string;\n      return new BasicEvaluatedExpression().setString(param.string.replace(arg1, arg2)).setRange(expr.range);\n    });\n    [\"substr\", \"substring\"].forEach(fn => {\n      this.hooks.evaluateCallExpressionMember.for(fn).tap(\"Parser\", (expr, param) => {\n        if (!param.isString()) return;\n        let arg1;\n        let result,\n            str = param.string;\n\n        switch (expr.arguments.length) {\n          case 1:\n            arg1 = this.evaluateExpression(expr.arguments[0]);\n            if (!arg1.isNumber()) return;\n            result = str[fn](arg1.number);\n            break;\n\n          case 2:\n            {\n              arg1 = this.evaluateExpression(expr.arguments[0]);\n              const arg2 = this.evaluateExpression(expr.arguments[1]);\n              if (!arg1.isNumber()) return;\n              if (!arg2.isNumber()) return;\n              result = str[fn](arg1.number, arg2.number);\n              break;\n            }\n\n          default:\n            return;\n        }\n\n        return new BasicEvaluatedExpression().setString(result).setRange(expr.range);\n      });\n    });\n    /**\n     * @param {string} kind \"cooked\" | \"raw\"\n     * @param {TODO} templateLiteralExpr TemplateLiteral expr\n     * @returns {{quasis: BasicEvaluatedExpression[], parts: BasicEvaluatedExpression[]}} Simplified template\n     */\n\n    const getSimplifiedTemplateResult = (kind, templateLiteralExpr) => {\n      const quasis = [];\n      const parts = [];\n\n      for (let i = 0; i < templateLiteralExpr.quasis.length; i++) {\n        const quasiExpr = templateLiteralExpr.quasis[i];\n        const quasi = quasiExpr.value[kind];\n\n        if (i > 0) {\n          const prevExpr = parts[parts.length - 1];\n          const expr = this.evaluateExpression(templateLiteralExpr.expressions[i - 1]);\n          const exprAsString = expr.asString();\n\n          if (typeof exprAsString === \"string\") {\n            // We can merge quasi + expr + quasi when expr\n            // is a const string\n            prevExpr.setString(prevExpr.string + exprAsString + quasi);\n            prevExpr.setRange([prevExpr.range[0], quasiExpr.range[1]]); // We unset the expression as it doesn't match to a single expression\n\n            prevExpr.setExpression(undefined);\n            continue;\n          }\n\n          parts.push(expr);\n        }\n\n        const part = new BasicEvaluatedExpression().setString(quasi).setRange(quasiExpr.range).setExpression(quasiExpr);\n        quasis.push(part);\n        parts.push(part);\n      }\n\n      return {\n        quasis,\n        parts\n      };\n    };\n\n    this.hooks.evaluate.for(\"TemplateLiteral\").tap(\"Parser\", node => {\n      const {\n        quasis,\n        parts\n      } = getSimplifiedTemplateResult(\"cooked\", node);\n\n      if (parts.length === 1) {\n        return parts[0].setRange(node.range);\n      }\n\n      return new BasicEvaluatedExpression().setTemplateString(quasis, parts, \"cooked\").setRange(node.range);\n    });\n    this.hooks.evaluate.for(\"TaggedTemplateExpression\").tap(\"Parser\", node => {\n      if (this.evaluateExpression(node.tag).identifier !== \"String.raw\") return;\n      const {\n        quasis,\n        parts\n      } = getSimplifiedTemplateResult(\"raw\", node.quasi);\n\n      if (parts.length === 1) {\n        return parts[0].setRange(node.range);\n      }\n\n      return new BasicEvaluatedExpression().setTemplateString(quasis, parts, \"raw\").setRange(node.range);\n    });\n    this.hooks.evaluateCallExpressionMember.for(\"concat\").tap(\"Parser\", (expr, param) => {\n      if (!param.isString() && !param.isWrapped()) return;\n      let stringSuffix = null;\n      let hasUnknownParams = false;\n\n      for (let i = expr.arguments.length - 1; i >= 0; i--) {\n        const argExpr = this.evaluateExpression(expr.arguments[i]);\n\n        if (!argExpr.isString() && !argExpr.isNumber()) {\n          hasUnknownParams = true;\n          break;\n        }\n\n        const value = argExpr.isString() ? argExpr.string : \"\" + argExpr.number;\n        const newString = value + (stringSuffix ? stringSuffix.string : \"\");\n        const newRange = [argExpr.range[0], (stringSuffix || argExpr).range[1]];\n        stringSuffix = new BasicEvaluatedExpression().setString(newString).setRange(newRange);\n      }\n\n      if (hasUnknownParams) {\n        const prefix = param.isString() ? param : param.prefix;\n        return new BasicEvaluatedExpression().setWrapped(prefix, stringSuffix).setRange(expr.range);\n      } else if (param.isWrapped()) {\n        const postfix = stringSuffix || param.postfix;\n        return new BasicEvaluatedExpression().setWrapped(param.prefix, postfix).setRange(expr.range);\n      } else {\n        const newString = param.string + (stringSuffix ? stringSuffix.string : \"\");\n        return new BasicEvaluatedExpression().setString(newString).setRange(expr.range);\n      }\n    });\n    this.hooks.evaluateCallExpressionMember.for(\"split\").tap(\"Parser\", (expr, param) => {\n      if (!param.isString()) return;\n      if (expr.arguments.length !== 1) return;\n      let result;\n      const arg = this.evaluateExpression(expr.arguments[0]);\n\n      if (arg.isString()) {\n        result = param.string.split(arg.string);\n      } else if (arg.isRegExp()) {\n        result = param.string.split(arg.regExp);\n      } else {\n        return;\n      }\n\n      return new BasicEvaluatedExpression().setArray(result).setRange(expr.range);\n    });\n    this.hooks.evaluate.for(\"ConditionalExpression\").tap(\"Parser\", expr => {\n      const condition = this.evaluateExpression(expr.test);\n      const conditionValue = condition.asBool();\n      let res;\n\n      if (conditionValue === undefined) {\n        const consequent = this.evaluateExpression(expr.consequent);\n        const alternate = this.evaluateExpression(expr.alternate);\n        if (!consequent || !alternate) return;\n        res = new BasicEvaluatedExpression();\n\n        if (consequent.isConditional()) {\n          res.setOptions(consequent.options);\n        } else {\n          res.setOptions([consequent]);\n        }\n\n        if (alternate.isConditional()) {\n          res.addOptions(alternate.options);\n        } else {\n          res.addOptions([alternate]);\n        }\n      } else {\n        res = this.evaluateExpression(conditionValue ? expr.consequent : expr.alternate);\n      }\n\n      res.setRange(expr.range);\n      return res;\n    });\n    this.hooks.evaluate.for(\"ArrayExpression\").tap(\"Parser\", expr => {\n      const items = expr.elements.map(element => {\n        return element !== null && this.evaluateExpression(element);\n      });\n      if (!items.every(Boolean)) return;\n      return new BasicEvaluatedExpression().setItems(items).setRange(expr.range);\n    });\n  }\n\n  getRenameIdentifier(expr) {\n    const result = this.evaluateExpression(expr);\n\n    if (result && result.isIdentifier()) {\n      return result.identifier;\n    }\n  }\n\n  walkClass(classy) {\n    if (classy.superClass) this.walkExpression(classy.superClass);\n\n    if (classy.body && classy.body.type === \"ClassBody\") {\n      const wasTopLevel = this.scope.topLevelScope;\n      this.scope.topLevelScope = false;\n\n      for (const methodDefinition of classy.body.body) {\n        if (methodDefinition.type === \"MethodDefinition\") {\n          this.walkMethodDefinition(methodDefinition);\n        }\n      }\n\n      this.scope.topLevelScope = wasTopLevel;\n    }\n  }\n\n  walkMethodDefinition(methodDefinition) {\n    if (methodDefinition.computed && methodDefinition.key) {\n      this.walkExpression(methodDefinition.key);\n    }\n\n    if (methodDefinition.value) {\n      this.walkExpression(methodDefinition.value);\n    }\n  } // Prewalking iterates the scope for variable declarations\n\n\n  prewalkStatements(statements) {\n    for (let index = 0, len = statements.length; index < len; index++) {\n      const statement = statements[index];\n      this.prewalkStatement(statement);\n    }\n  } // Block-Prewalking iterates the scope for block variable declarations\n\n\n  blockPrewalkStatements(statements) {\n    for (let index = 0, len = statements.length; index < len; index++) {\n      const statement = statements[index];\n      this.blockPrewalkStatement(statement);\n    }\n  } // Walking iterates the statements and expressions and processes them\n\n\n  walkStatements(statements) {\n    for (let index = 0, len = statements.length; index < len; index++) {\n      const statement = statements[index];\n      this.walkStatement(statement);\n    }\n  }\n\n  prewalkStatement(statement) {\n    switch (statement.type) {\n      case \"BlockStatement\":\n        this.prewalkBlockStatement(statement);\n        break;\n\n      case \"DoWhileStatement\":\n        this.prewalkDoWhileStatement(statement);\n        break;\n\n      case \"ExportAllDeclaration\":\n        this.prewalkExportAllDeclaration(statement);\n        break;\n\n      case \"ExportDefaultDeclaration\":\n        this.prewalkExportDefaultDeclaration(statement);\n        break;\n\n      case \"ExportNamedDeclaration\":\n        this.prewalkExportNamedDeclaration(statement);\n        break;\n\n      case \"ForInStatement\":\n        this.prewalkForInStatement(statement);\n        break;\n\n      case \"ForOfStatement\":\n        this.prewalkForOfStatement(statement);\n        break;\n\n      case \"ForStatement\":\n        this.prewalkForStatement(statement);\n        break;\n\n      case \"FunctionDeclaration\":\n        this.prewalkFunctionDeclaration(statement);\n        break;\n\n      case \"IfStatement\":\n        this.prewalkIfStatement(statement);\n        break;\n\n      case \"ImportDeclaration\":\n        this.prewalkImportDeclaration(statement);\n        break;\n\n      case \"LabeledStatement\":\n        this.prewalkLabeledStatement(statement);\n        break;\n\n      case \"SwitchStatement\":\n        this.prewalkSwitchStatement(statement);\n        break;\n\n      case \"TryStatement\":\n        this.prewalkTryStatement(statement);\n        break;\n\n      case \"VariableDeclaration\":\n        this.prewalkVariableDeclaration(statement);\n        break;\n\n      case \"WhileStatement\":\n        this.prewalkWhileStatement(statement);\n        break;\n\n      case \"WithStatement\":\n        this.prewalkWithStatement(statement);\n        break;\n    }\n  }\n\n  blockPrewalkStatement(statement) {\n    switch (statement.type) {\n      case \"VariableDeclaration\":\n        this.blockPrewalkVariableDeclaration(statement);\n        break;\n\n      case \"ExportDefaultDeclaration\":\n        this.blockPrewalkExportDefaultDeclaration(statement);\n        break;\n\n      case \"ExportNamedDeclaration\":\n        this.blockPrewalkExportNamedDeclaration(statement);\n        break;\n\n      case \"ClassDeclaration\":\n        this.blockPrewalkClassDeclaration(statement);\n        break;\n    }\n  }\n\n  walkStatement(statement) {\n    if (this.hooks.statement.call(statement) !== undefined) return;\n\n    switch (statement.type) {\n      case \"BlockStatement\":\n        this.walkBlockStatement(statement);\n        break;\n\n      case \"ClassDeclaration\":\n        this.walkClassDeclaration(statement);\n        break;\n\n      case \"DoWhileStatement\":\n        this.walkDoWhileStatement(statement);\n        break;\n\n      case \"ExportDefaultDeclaration\":\n        this.walkExportDefaultDeclaration(statement);\n        break;\n\n      case \"ExportNamedDeclaration\":\n        this.walkExportNamedDeclaration(statement);\n        break;\n\n      case \"ExpressionStatement\":\n        this.walkExpressionStatement(statement);\n        break;\n\n      case \"ForInStatement\":\n        this.walkForInStatement(statement);\n        break;\n\n      case \"ForOfStatement\":\n        this.walkForOfStatement(statement);\n        break;\n\n      case \"ForStatement\":\n        this.walkForStatement(statement);\n        break;\n\n      case \"FunctionDeclaration\":\n        this.walkFunctionDeclaration(statement);\n        break;\n\n      case \"IfStatement\":\n        this.walkIfStatement(statement);\n        break;\n\n      case \"LabeledStatement\":\n        this.walkLabeledStatement(statement);\n        break;\n\n      case \"ReturnStatement\":\n        this.walkReturnStatement(statement);\n        break;\n\n      case \"SwitchStatement\":\n        this.walkSwitchStatement(statement);\n        break;\n\n      case \"ThrowStatement\":\n        this.walkThrowStatement(statement);\n        break;\n\n      case \"TryStatement\":\n        this.walkTryStatement(statement);\n        break;\n\n      case \"VariableDeclaration\":\n        this.walkVariableDeclaration(statement);\n        break;\n\n      case \"WhileStatement\":\n        this.walkWhileStatement(statement);\n        break;\n\n      case \"WithStatement\":\n        this.walkWithStatement(statement);\n        break;\n    }\n  } // Real Statements\n\n\n  prewalkBlockStatement(statement) {\n    this.prewalkStatements(statement.body);\n  }\n\n  walkBlockStatement(statement) {\n    this.inBlockScope(() => {\n      const body = statement.body;\n      this.blockPrewalkStatements(body);\n      this.walkStatements(body);\n    });\n  }\n\n  walkExpressionStatement(statement) {\n    this.walkExpression(statement.expression);\n  }\n\n  prewalkIfStatement(statement) {\n    this.prewalkStatement(statement.consequent);\n\n    if (statement.alternate) {\n      this.prewalkStatement(statement.alternate);\n    }\n  }\n\n  walkIfStatement(statement) {\n    const result = this.hooks.statementIf.call(statement);\n\n    if (result === undefined) {\n      this.walkExpression(statement.test);\n      this.walkStatement(statement.consequent);\n\n      if (statement.alternate) {\n        this.walkStatement(statement.alternate);\n      }\n    } else {\n      if (result) {\n        this.walkStatement(statement.consequent);\n      } else if (statement.alternate) {\n        this.walkStatement(statement.alternate);\n      }\n    }\n  }\n\n  prewalkLabeledStatement(statement) {\n    this.prewalkStatement(statement.body);\n  }\n\n  walkLabeledStatement(statement) {\n    const hook = this.hooks.label.get(statement.label.name);\n\n    if (hook !== undefined) {\n      const result = hook.call(statement);\n      if (result === true) return;\n    }\n\n    this.walkStatement(statement.body);\n  }\n\n  prewalkWithStatement(statement) {\n    this.prewalkStatement(statement.body);\n  }\n\n  walkWithStatement(statement) {\n    this.walkExpression(statement.object);\n    this.walkStatement(statement.body);\n  }\n\n  prewalkSwitchStatement(statement) {\n    this.prewalkSwitchCases(statement.cases);\n  }\n\n  walkSwitchStatement(statement) {\n    this.walkExpression(statement.discriminant);\n    this.walkSwitchCases(statement.cases);\n  }\n\n  walkTerminatingStatement(statement) {\n    if (statement.argument) this.walkExpression(statement.argument);\n  }\n\n  walkReturnStatement(statement) {\n    this.walkTerminatingStatement(statement);\n  }\n\n  walkThrowStatement(statement) {\n    this.walkTerminatingStatement(statement);\n  }\n\n  prewalkTryStatement(statement) {\n    this.prewalkStatement(statement.block);\n  }\n\n  walkTryStatement(statement) {\n    if (this.scope.inTry) {\n      this.walkStatement(statement.block);\n    } else {\n      this.scope.inTry = true;\n      this.walkStatement(statement.block);\n      this.scope.inTry = false;\n    }\n\n    if (statement.handler) this.walkCatchClause(statement.handler);\n    if (statement.finalizer) this.walkStatement(statement.finalizer);\n  }\n\n  prewalkWhileStatement(statement) {\n    this.prewalkStatement(statement.body);\n  }\n\n  walkWhileStatement(statement) {\n    this.walkExpression(statement.test);\n    this.walkStatement(statement.body);\n  }\n\n  prewalkDoWhileStatement(statement) {\n    this.prewalkStatement(statement.body);\n  }\n\n  walkDoWhileStatement(statement) {\n    this.walkStatement(statement.body);\n    this.walkExpression(statement.test);\n  }\n\n  prewalkForStatement(statement) {\n    if (statement.init) {\n      if (statement.init.type === \"VariableDeclaration\") {\n        this.prewalkStatement(statement.init);\n      }\n    }\n\n    this.prewalkStatement(statement.body);\n  }\n\n  walkForStatement(statement) {\n    this.inBlockScope(() => {\n      if (statement.init) {\n        if (statement.init.type === \"VariableDeclaration\") {\n          this.blockPrewalkVariableDeclaration(statement.init);\n          this.walkStatement(statement.init);\n        } else {\n          this.walkExpression(statement.init);\n        }\n      }\n\n      if (statement.test) {\n        this.walkExpression(statement.test);\n      }\n\n      if (statement.update) {\n        this.walkExpression(statement.update);\n      }\n\n      const body = statement.body;\n\n      if (body.type === \"BlockStatement\") {\n        // no need to add additional scope\n        this.blockPrewalkStatements(body.body);\n        this.walkStatements(body.body);\n      } else {\n        this.walkStatement(body);\n      }\n    });\n  }\n\n  prewalkForInStatement(statement) {\n    if (statement.left.type === \"VariableDeclaration\") {\n      this.prewalkVariableDeclaration(statement.left);\n    }\n\n    this.prewalkStatement(statement.body);\n  }\n\n  walkForInStatement(statement) {\n    this.inBlockScope(() => {\n      if (statement.left.type === \"VariableDeclaration\") {\n        this.blockPrewalkVariableDeclaration(statement.left);\n        this.walkVariableDeclaration(statement.left);\n      } else {\n        this.walkPattern(statement.left);\n      }\n\n      this.walkExpression(statement.right);\n      const body = statement.body;\n\n      if (body.type === \"BlockStatement\") {\n        // no need to add additional scope\n        this.blockPrewalkStatements(body.body);\n        this.walkStatements(body.body);\n      } else {\n        this.walkStatement(body);\n      }\n    });\n  }\n\n  prewalkForOfStatement(statement) {\n    if (statement.left.type === \"VariableDeclaration\") {\n      this.prewalkVariableDeclaration(statement.left);\n    }\n\n    this.prewalkStatement(statement.body);\n  }\n\n  walkForOfStatement(statement) {\n    this.inBlockScope(() => {\n      if (statement.left.type === \"VariableDeclaration\") {\n        this.blockPrewalkVariableDeclaration(statement.left);\n        this.walkVariableDeclaration(statement.left);\n      } else {\n        this.walkPattern(statement.left);\n      }\n\n      this.walkExpression(statement.right);\n      const body = statement.body;\n\n      if (body.type === \"BlockStatement\") {\n        // no need to add additional scope\n        this.blockPrewalkStatements(body.body);\n        this.walkStatements(body.body);\n      } else {\n        this.walkStatement(body);\n      }\n    });\n  } // Declarations\n\n\n  prewalkFunctionDeclaration(statement) {\n    if (statement.id) {\n      this.scope.renames.set(statement.id.name, null);\n      this.scope.definitions.add(statement.id.name);\n    }\n  }\n\n  walkFunctionDeclaration(statement) {\n    const wasTopLevel = this.scope.topLevelScope;\n    this.scope.topLevelScope = false;\n    this.inFunctionScope(true, statement.params, () => {\n      for (const param of statement.params) {\n        this.walkPattern(param);\n      }\n\n      if (statement.body.type === \"BlockStatement\") {\n        this.detectMode(statement.body.body);\n        this.prewalkStatement(statement.body);\n        this.walkStatement(statement.body);\n      } else {\n        this.walkExpression(statement.body);\n      }\n    });\n    this.scope.topLevelScope = wasTopLevel;\n  }\n\n  prewalkImportDeclaration(statement) {\n    const source = statement.source.value;\n    this.hooks.import.call(statement, source);\n\n    for (const specifier of statement.specifiers) {\n      const name = specifier.local.name;\n      this.scope.renames.set(name, null);\n      this.scope.definitions.add(name);\n\n      switch (specifier.type) {\n        case \"ImportDefaultSpecifier\":\n          this.hooks.importSpecifier.call(statement, source, \"default\", name);\n          break;\n\n        case \"ImportSpecifier\":\n          this.hooks.importSpecifier.call(statement, source, specifier.imported.name, name);\n          break;\n\n        case \"ImportNamespaceSpecifier\":\n          this.hooks.importSpecifier.call(statement, source, null, name);\n          break;\n      }\n    }\n  }\n\n  enterDeclaration(declaration, onIdent) {\n    switch (declaration.type) {\n      case \"VariableDeclaration\":\n        for (const declarator of declaration.declarations) {\n          switch (declarator.type) {\n            case \"VariableDeclarator\":\n              {\n                this.enterPattern(declarator.id, onIdent);\n                break;\n              }\n          }\n        }\n\n        break;\n\n      case \"FunctionDeclaration\":\n        this.enterPattern(declaration.id, onIdent);\n        break;\n\n      case \"ClassDeclaration\":\n        this.enterPattern(declaration.id, onIdent);\n        break;\n    }\n  }\n\n  blockPrewalkExportNamedDeclaration(statement) {\n    if (statement.declaration) {\n      this.blockPrewalkStatement(statement.declaration);\n    }\n  }\n\n  prewalkExportNamedDeclaration(statement) {\n    let source;\n\n    if (statement.source) {\n      source = statement.source.value;\n      this.hooks.exportImport.call(statement, source);\n    } else {\n      this.hooks.export.call(statement);\n    }\n\n    if (statement.declaration) {\n      if (!this.hooks.exportDeclaration.call(statement, statement.declaration)) {\n        this.prewalkStatement(statement.declaration);\n        let index = 0;\n        this.enterDeclaration(statement.declaration, def => {\n          this.hooks.exportSpecifier.call(statement, def, def, index++);\n        });\n      }\n    }\n\n    if (statement.specifiers) {\n      for (let specifierIndex = 0; specifierIndex < statement.specifiers.length; specifierIndex++) {\n        const specifier = statement.specifiers[specifierIndex];\n\n        switch (specifier.type) {\n          case \"ExportSpecifier\":\n            {\n              const name = specifier.exported.name;\n\n              if (source) {\n                this.hooks.exportImportSpecifier.call(statement, source, specifier.local.name, name, specifierIndex);\n              } else {\n                this.hooks.exportSpecifier.call(statement, specifier.local.name, name, specifierIndex);\n              }\n\n              break;\n            }\n        }\n      }\n    }\n  }\n\n  walkExportNamedDeclaration(statement) {\n    if (statement.declaration) {\n      this.walkStatement(statement.declaration);\n    }\n  }\n\n  blockPrewalkExportDefaultDeclaration(statement) {\n    if (statement.declaration.type === \"ClassDeclaration\") {\n      this.blockPrewalkClassDeclaration(statement.declaration);\n    }\n  }\n\n  prewalkExportDefaultDeclaration(statement) {\n    this.prewalkStatement(statement.declaration);\n\n    if (statement.declaration.id && statement.declaration.type !== \"FunctionExpression\" && statement.declaration.type !== \"ClassExpression\") {\n      this.hooks.exportSpecifier.call(statement, statement.declaration.id.name, \"default\");\n    }\n  }\n\n  walkExportDefaultDeclaration(statement) {\n    this.hooks.export.call(statement);\n\n    if (statement.declaration.id && statement.declaration.type !== \"FunctionExpression\" && statement.declaration.type !== \"ClassExpression\") {\n      if (!this.hooks.exportDeclaration.call(statement, statement.declaration)) {\n        this.walkStatement(statement.declaration);\n      }\n    } else {\n      // Acorn parses `export default function() {}` as `FunctionDeclaration` and\n      // `export default class {}` as `ClassDeclaration`, both with `id = null`.\n      // These nodes must be treated as expressions.\n      if (statement.declaration.type === \"FunctionDeclaration\") {\n        this.walkFunctionDeclaration(statement.declaration);\n      } else if (statement.declaration.type === \"ClassDeclaration\") {\n        this.walkClassDeclaration(statement.declaration);\n      } else {\n        this.walkExpression(statement.declaration);\n      }\n\n      if (!this.hooks.exportExpression.call(statement, statement.declaration)) {\n        this.hooks.exportSpecifier.call(statement, statement.declaration, \"default\");\n      }\n    }\n  }\n\n  prewalkExportAllDeclaration(statement) {\n    const source = statement.source.value;\n    this.hooks.exportImport.call(statement, source);\n    this.hooks.exportImportSpecifier.call(statement, source, null, null, 0);\n  }\n\n  prewalkVariableDeclaration(statement) {\n    if (statement.kind !== \"var\") return;\n\n    this._prewalkVariableDeclaration(statement, this.hooks.varDeclarationVar);\n  }\n\n  blockPrewalkVariableDeclaration(statement) {\n    if (statement.kind === \"var\") return;\n    const hookMap = statement.kind === \"const\" ? this.hooks.varDeclarationConst : this.hooks.varDeclarationLet;\n\n    this._prewalkVariableDeclaration(statement, hookMap);\n  }\n\n  _prewalkVariableDeclaration(statement, hookMap) {\n    for (const declarator of statement.declarations) {\n      switch (declarator.type) {\n        case \"VariableDeclarator\":\n          {\n            this.enterPattern(declarator.id, (name, decl) => {\n              let hook = hookMap.get(name);\n\n              if (hook === undefined || !hook.call(decl)) {\n                hook = this.hooks.varDeclaration.get(name);\n\n                if (hook === undefined || !hook.call(decl)) {\n                  this.scope.renames.set(name, null);\n                  this.scope.definitions.add(name);\n                }\n              }\n            });\n            break;\n          }\n      }\n    }\n  }\n\n  walkVariableDeclaration(statement) {\n    for (const declarator of statement.declarations) {\n      switch (declarator.type) {\n        case \"VariableDeclarator\":\n          {\n            const renameIdentifier = declarator.init && this.getRenameIdentifier(declarator.init);\n\n            if (renameIdentifier && declarator.id.type === \"Identifier\") {\n              const hook = this.hooks.canRename.get(renameIdentifier);\n\n              if (hook !== undefined && hook.call(declarator.init)) {\n                // renaming with \"var a = b;\"\n                const hook = this.hooks.rename.get(renameIdentifier);\n\n                if (hook === undefined || !hook.call(declarator.init)) {\n                  this.scope.renames.set(declarator.id.name, this.scope.renames.get(renameIdentifier) || renameIdentifier);\n                  this.scope.definitions.delete(declarator.id.name);\n                }\n\n                break;\n              }\n            }\n\n            this.walkPattern(declarator.id);\n            if (declarator.init) this.walkExpression(declarator.init);\n            break;\n          }\n      }\n    }\n  }\n\n  blockPrewalkClassDeclaration(statement) {\n    if (statement.id) {\n      this.scope.renames.set(statement.id.name, null);\n      this.scope.definitions.add(statement.id.name);\n    }\n  }\n\n  walkClassDeclaration(statement) {\n    this.walkClass(statement);\n  }\n\n  prewalkSwitchCases(switchCases) {\n    for (let index = 0, len = switchCases.length; index < len; index++) {\n      const switchCase = switchCases[index];\n      this.prewalkStatements(switchCase.consequent);\n    }\n  }\n\n  walkSwitchCases(switchCases) {\n    for (let index = 0, len = switchCases.length; index < len; index++) {\n      const switchCase = switchCases[index];\n\n      if (switchCase.test) {\n        this.walkExpression(switchCase.test);\n      }\n\n      this.walkStatements(switchCase.consequent);\n    }\n  }\n\n  walkCatchClause(catchClause) {\n    this.inBlockScope(() => {\n      // Error binding is optional in catch clause since ECMAScript 2019\n      if (catchClause.param !== null) {\n        this.enterPattern(catchClause.param, ident => {\n          this.scope.renames.set(ident, null);\n          this.scope.definitions.add(ident);\n        });\n        this.walkPattern(catchClause.param);\n      }\n\n      this.prewalkStatement(catchClause.body);\n      this.walkStatement(catchClause.body);\n    });\n  }\n\n  walkPattern(pattern) {\n    switch (pattern.type) {\n      case \"ArrayPattern\":\n        this.walkArrayPattern(pattern);\n        break;\n\n      case \"AssignmentPattern\":\n        this.walkAssignmentPattern(pattern);\n        break;\n\n      case \"MemberExpression\":\n        this.walkMemberExpression(pattern);\n        break;\n\n      case \"ObjectPattern\":\n        this.walkObjectPattern(pattern);\n        break;\n\n      case \"RestElement\":\n        this.walkRestElement(pattern);\n        break;\n    }\n  }\n\n  walkAssignmentPattern(pattern) {\n    this.walkExpression(pattern.right);\n    this.walkPattern(pattern.left);\n  }\n\n  walkObjectPattern(pattern) {\n    for (let i = 0, len = pattern.properties.length; i < len; i++) {\n      const prop = pattern.properties[i];\n\n      if (prop) {\n        if (prop.computed) this.walkExpression(prop.key);\n        if (prop.value) this.walkPattern(prop.value);\n      }\n    }\n  }\n\n  walkArrayPattern(pattern) {\n    for (let i = 0, len = pattern.elements.length; i < len; i++) {\n      const element = pattern.elements[i];\n      if (element) this.walkPattern(element);\n    }\n  }\n\n  walkRestElement(pattern) {\n    this.walkPattern(pattern.argument);\n  }\n\n  walkExpressions(expressions) {\n    for (const expression of expressions) {\n      if (expression) {\n        this.walkExpression(expression);\n      }\n    }\n  }\n\n  walkExpression(expression) {\n    switch (expression.type) {\n      case \"ArrayExpression\":\n        this.walkArrayExpression(expression);\n        break;\n\n      case \"ArrowFunctionExpression\":\n        this.walkArrowFunctionExpression(expression);\n        break;\n\n      case \"AssignmentExpression\":\n        this.walkAssignmentExpression(expression);\n        break;\n\n      case \"AwaitExpression\":\n        this.walkAwaitExpression(expression);\n        break;\n\n      case \"BinaryExpression\":\n        this.walkBinaryExpression(expression);\n        break;\n\n      case \"CallExpression\":\n        this.walkCallExpression(expression);\n        break;\n\n      case \"ClassExpression\":\n        this.walkClassExpression(expression);\n        break;\n\n      case \"ConditionalExpression\":\n        this.walkConditionalExpression(expression);\n        break;\n\n      case \"FunctionExpression\":\n        this.walkFunctionExpression(expression);\n        break;\n\n      case \"Identifier\":\n        this.walkIdentifier(expression);\n        break;\n\n      case \"LogicalExpression\":\n        this.walkLogicalExpression(expression);\n        break;\n\n      case \"MemberExpression\":\n        this.walkMemberExpression(expression);\n        break;\n\n      case \"NewExpression\":\n        this.walkNewExpression(expression);\n        break;\n\n      case \"ObjectExpression\":\n        this.walkObjectExpression(expression);\n        break;\n\n      case \"SequenceExpression\":\n        this.walkSequenceExpression(expression);\n        break;\n\n      case \"SpreadElement\":\n        this.walkSpreadElement(expression);\n        break;\n\n      case \"TaggedTemplateExpression\":\n        this.walkTaggedTemplateExpression(expression);\n        break;\n\n      case \"TemplateLiteral\":\n        this.walkTemplateLiteral(expression);\n        break;\n\n      case \"ThisExpression\":\n        this.walkThisExpression(expression);\n        break;\n\n      case \"UnaryExpression\":\n        this.walkUnaryExpression(expression);\n        break;\n\n      case \"UpdateExpression\":\n        this.walkUpdateExpression(expression);\n        break;\n\n      case \"YieldExpression\":\n        this.walkYieldExpression(expression);\n        break;\n    }\n  }\n\n  walkAwaitExpression(expression) {\n    this.walkExpression(expression.argument);\n  }\n\n  walkArrayExpression(expression) {\n    if (expression.elements) {\n      this.walkExpressions(expression.elements);\n    }\n  }\n\n  walkSpreadElement(expression) {\n    if (expression.argument) {\n      this.walkExpression(expression.argument);\n    }\n  }\n\n  walkObjectExpression(expression) {\n    for (let propIndex = 0, len = expression.properties.length; propIndex < len; propIndex++) {\n      const prop = expression.properties[propIndex];\n\n      if (prop.type === \"SpreadElement\") {\n        this.walkExpression(prop.argument);\n        continue;\n      }\n\n      if (prop.computed) {\n        this.walkExpression(prop.key);\n      }\n\n      if (prop.shorthand) {\n        this.scope.inShorthand = true;\n      }\n\n      this.walkExpression(prop.value);\n\n      if (prop.shorthand) {\n        this.scope.inShorthand = false;\n      }\n    }\n  }\n\n  walkFunctionExpression(expression) {\n    const wasTopLevel = this.scope.topLevelScope;\n    this.scope.topLevelScope = false;\n    const scopeParams = expression.params; // Add function name in scope for recursive calls\n\n    if (expression.id) {\n      scopeParams.push(expression.id.name);\n    }\n\n    this.inFunctionScope(true, scopeParams, () => {\n      for (const param of expression.params) {\n        this.walkPattern(param);\n      }\n\n      if (expression.body.type === \"BlockStatement\") {\n        this.detectMode(expression.body.body);\n        this.prewalkStatement(expression.body);\n        this.walkStatement(expression.body);\n      } else {\n        this.walkExpression(expression.body);\n      }\n    });\n    this.scope.topLevelScope = wasTopLevel;\n  }\n\n  walkArrowFunctionExpression(expression) {\n    this.inFunctionScope(false, expression.params, () => {\n      for (const param of expression.params) {\n        this.walkPattern(param);\n      }\n\n      if (expression.body.type === \"BlockStatement\") {\n        this.detectMode(expression.body.body);\n        this.prewalkStatement(expression.body);\n        this.walkStatement(expression.body);\n      } else {\n        this.walkExpression(expression.body);\n      }\n    });\n  }\n\n  walkSequenceExpression(expression) {\n    if (expression.expressions) this.walkExpressions(expression.expressions);\n  }\n\n  walkUpdateExpression(expression) {\n    this.walkExpression(expression.argument);\n  }\n\n  walkUnaryExpression(expression) {\n    if (expression.operator === \"typeof\") {\n      const exprName = this.getNameForExpression(expression.argument);\n\n      if (exprName && exprName.free) {\n        const hook = this.hooks.typeof.get(exprName.name);\n\n        if (hook !== undefined) {\n          const result = hook.call(expression);\n          if (result === true) return;\n        }\n      }\n    }\n\n    this.walkExpression(expression.argument);\n  }\n\n  walkLeftRightExpression(expression) {\n    this.walkExpression(expression.left);\n    this.walkExpression(expression.right);\n  }\n\n  walkBinaryExpression(expression) {\n    this.walkLeftRightExpression(expression);\n  }\n\n  walkLogicalExpression(expression) {\n    const result = this.hooks.expressionLogicalOperator.call(expression);\n\n    if (result === undefined) {\n      this.walkLeftRightExpression(expression);\n    } else {\n      if (result) {\n        this.walkExpression(expression.right);\n      }\n    }\n  }\n\n  walkAssignmentExpression(expression) {\n    const renameIdentifier = this.getRenameIdentifier(expression.right);\n\n    if (expression.left.type === \"Identifier\" && renameIdentifier) {\n      const hook = this.hooks.canRename.get(renameIdentifier);\n\n      if (hook !== undefined && hook.call(expression.right)) {\n        // renaming \"a = b;\"\n        const hook = this.hooks.rename.get(renameIdentifier);\n\n        if (hook === undefined || !hook.call(expression.right)) {\n          this.scope.renames.set(expression.left.name, renameIdentifier);\n          this.scope.definitions.delete(expression.left.name);\n        }\n\n        return;\n      }\n    }\n\n    if (expression.left.type === \"Identifier\") {\n      const assignedHook = this.hooks.assigned.get(expression.left.name);\n\n      if (assignedHook === undefined || !assignedHook.call(expression)) {\n        this.walkExpression(expression.right);\n      }\n\n      this.scope.renames.set(expression.left.name, null);\n      const assignHook = this.hooks.assign.get(expression.left.name);\n\n      if (assignHook === undefined || !assignHook.call(expression)) {\n        this.walkExpression(expression.left);\n      }\n\n      return;\n    }\n\n    this.walkExpression(expression.right);\n    this.walkPattern(expression.left);\n    this.enterPattern(expression.left, (name, decl) => {\n      this.scope.renames.set(name, null);\n    });\n  }\n\n  walkConditionalExpression(expression) {\n    const result = this.hooks.expressionConditionalOperator.call(expression);\n\n    if (result === undefined) {\n      this.walkExpression(expression.test);\n      this.walkExpression(expression.consequent);\n\n      if (expression.alternate) {\n        this.walkExpression(expression.alternate);\n      }\n    } else {\n      if (result) {\n        this.walkExpression(expression.consequent);\n      } else if (expression.alternate) {\n        this.walkExpression(expression.alternate);\n      }\n    }\n  }\n\n  walkNewExpression(expression) {\n    const callee = this.evaluateExpression(expression.callee);\n\n    if (callee.isIdentifier()) {\n      const hook = this.hooks.new.get(callee.identifier);\n\n      if (hook !== undefined) {\n        const result = hook.call(expression);\n\n        if (result === true) {\n          return;\n        }\n      }\n    }\n\n    this.walkExpression(expression.callee);\n\n    if (expression.arguments) {\n      this.walkExpressions(expression.arguments);\n    }\n  }\n\n  walkYieldExpression(expression) {\n    if (expression.argument) {\n      this.walkExpression(expression.argument);\n    }\n  }\n\n  walkTemplateLiteral(expression) {\n    if (expression.expressions) {\n      this.walkExpressions(expression.expressions);\n    }\n  }\n\n  walkTaggedTemplateExpression(expression) {\n    if (expression.tag) {\n      this.walkExpression(expression.tag);\n    }\n\n    if (expression.quasi && expression.quasi.expressions) {\n      this.walkExpressions(expression.quasi.expressions);\n    }\n  }\n\n  walkClassExpression(expression) {\n    this.walkClass(expression);\n  }\n\n  _walkIIFE(functionExpression, options, currentThis) {\n    const renameArgOrThis = argOrThis => {\n      const renameIdentifier = this.getRenameIdentifier(argOrThis);\n\n      if (renameIdentifier) {\n        const hook = this.hooks.canRename.get(renameIdentifier);\n\n        if (hook !== undefined && hook.call(argOrThis)) {\n          const hook = this.hooks.rename.get(renameIdentifier);\n\n          if (hook === undefined || !hook.call(argOrThis)) {\n            return renameIdentifier;\n          }\n        }\n      }\n\n      this.walkExpression(argOrThis);\n    };\n\n    const params = functionExpression.params;\n    const renameThis = currentThis ? renameArgOrThis(currentThis) : null;\n    const args = options.map(renameArgOrThis);\n    const wasTopLevel = this.scope.topLevelScope;\n    this.scope.topLevelScope = false;\n    const scopeParams = params.filter((identifier, idx) => !args[idx]); // Add function name in scope for recursive calls\n\n    if (functionExpression.id) {\n      scopeParams.push(functionExpression.id.name);\n    }\n\n    this.inFunctionScope(true, scopeParams, () => {\n      if (renameThis) {\n        this.scope.renames.set(\"this\", renameThis);\n      }\n\n      for (let i = 0; i < args.length; i++) {\n        const param = args[i];\n        if (!param) continue;\n        if (!params[i] || params[i].type !== \"Identifier\") continue;\n        this.scope.renames.set(params[i].name, param);\n      }\n\n      if (functionExpression.body.type === \"BlockStatement\") {\n        this.detectMode(functionExpression.body.body);\n        this.prewalkStatement(functionExpression.body);\n        this.walkStatement(functionExpression.body);\n      } else {\n        this.walkExpression(functionExpression.body);\n      }\n    });\n    this.scope.topLevelScope = wasTopLevel;\n  }\n\n  walkCallExpression(expression) {\n    if (expression.callee.type === \"MemberExpression\" && expression.callee.object.type === \"FunctionExpression\" && !expression.callee.computed && (expression.callee.property.name === \"call\" || expression.callee.property.name === \"bind\") && expression.arguments.length > 0) {\n      // (function(…) { }.call/bind(?, …))\n      this._walkIIFE(expression.callee.object, expression.arguments.slice(1), expression.arguments[0]);\n    } else if (expression.callee.type === \"FunctionExpression\") {\n      // (function(…) { }(…))\n      this._walkIIFE(expression.callee, expression.arguments, null);\n    } else if (expression.callee.type === \"Import\") {\n      let result = this.hooks.importCall.call(expression);\n      if (result === true) return;\n      if (expression.arguments) this.walkExpressions(expression.arguments);\n    } else {\n      const callee = this.evaluateExpression(expression.callee);\n\n      if (callee.isIdentifier()) {\n        const callHook = this.hooks.call.get(callee.identifier);\n\n        if (callHook !== undefined) {\n          let result = callHook.call(expression);\n          if (result === true) return;\n        }\n\n        let identifier = callee.identifier.replace(/\\.[^.]+$/, \"\");\n\n        if (identifier !== callee.identifier) {\n          const callAnyHook = this.hooks.callAnyMember.get(identifier);\n\n          if (callAnyHook !== undefined) {\n            let result = callAnyHook.call(expression);\n            if (result === true) return;\n          }\n        }\n      }\n\n      if (expression.callee) this.walkExpression(expression.callee);\n      if (expression.arguments) this.walkExpressions(expression.arguments);\n    }\n  }\n\n  walkMemberExpression(expression) {\n    const exprName = this.getNameForExpression(expression);\n\n    if (exprName && exprName.free) {\n      const expressionHook = this.hooks.expression.get(exprName.name);\n\n      if (expressionHook !== undefined) {\n        const result = expressionHook.call(expression);\n        if (result === true) return;\n      }\n\n      const expressionAnyMemberHook = this.hooks.expressionAnyMember.get(exprName.nameGeneral);\n\n      if (expressionAnyMemberHook !== undefined) {\n        const result = expressionAnyMemberHook.call(expression);\n        if (result === true) return;\n      }\n    }\n\n    this.walkExpression(expression.object);\n    if (expression.computed === true) this.walkExpression(expression.property);\n  }\n\n  walkThisExpression(expression) {\n    const expressionHook = this.hooks.expression.get(\"this\");\n\n    if (expressionHook !== undefined) {\n      expressionHook.call(expression);\n    }\n  }\n\n  walkIdentifier(expression) {\n    if (!this.scope.definitions.has(expression.name)) {\n      const hook = this.hooks.expression.get(this.scope.renames.get(expression.name) || expression.name);\n\n      if (hook !== undefined) {\n        const result = hook.call(expression);\n        if (result === true) return;\n      }\n    }\n  }\n  /**\n   * @deprecated\n   * @param {any} params scope params\n   * @param {function(): void} fn inner function\n   * @returns {void}\n   */\n\n\n  inScope(params, fn) {\n    const oldScope = this.scope;\n    this.scope = {\n      topLevelScope: oldScope.topLevelScope,\n      inTry: false,\n      inShorthand: false,\n      isStrict: oldScope.isStrict,\n      isAsmJs: oldScope.isAsmJs,\n      definitions: oldScope.definitions.createChild(),\n      renames: oldScope.renames.createChild()\n    };\n    this.scope.renames.set(\"this\", null);\n    this.enterPatterns(params, ident => {\n      this.scope.renames.set(ident, null);\n      this.scope.definitions.add(ident);\n    });\n    fn();\n    this.scope = oldScope;\n  }\n\n  inFunctionScope(hasThis, params, fn) {\n    const oldScope = this.scope;\n    this.scope = {\n      topLevelScope: oldScope.topLevelScope,\n      inTry: false,\n      inShorthand: false,\n      isStrict: oldScope.isStrict,\n      isAsmJs: oldScope.isAsmJs,\n      definitions: oldScope.definitions.createChild(),\n      renames: oldScope.renames.createChild()\n    };\n\n    if (hasThis) {\n      this.scope.renames.set(\"this\", null);\n    }\n\n    this.enterPatterns(params, ident => {\n      this.scope.renames.set(ident, null);\n      this.scope.definitions.add(ident);\n    });\n    fn();\n    this.scope = oldScope;\n  }\n\n  inBlockScope(fn) {\n    const oldScope = this.scope;\n    this.scope = {\n      topLevelScope: oldScope.topLevelScope,\n      inTry: oldScope.inTry,\n      inShorthand: false,\n      isStrict: oldScope.isStrict,\n      isAsmJs: oldScope.isAsmJs,\n      definitions: oldScope.definitions.createChild(),\n      renames: oldScope.renames.createChild()\n    };\n    fn();\n    this.scope = oldScope;\n  } // TODO webpack 5: remove this methods\n  // only for backward-compat\n\n\n  detectStrictMode(statements) {\n    this.detectMode(statements);\n  }\n\n  detectMode(statements) {\n    const isLiteral = statements.length >= 1 && statements[0].type === \"ExpressionStatement\" && statements[0].expression.type === \"Literal\";\n\n    if (isLiteral && statements[0].expression.value === \"use strict\") {\n      this.scope.isStrict = true;\n    }\n\n    if (isLiteral && statements[0].expression.value === \"use asm\") {\n      this.scope.isAsmJs = true;\n    }\n  }\n\n  enterPatterns(patterns, onIdent) {\n    for (const pattern of patterns) {\n      if (typeof pattern !== \"string\") {\n        this.enterPattern(pattern, onIdent);\n      } else if (pattern) {\n        onIdent(pattern);\n      }\n    }\n  }\n\n  enterPattern(pattern, onIdent) {\n    if (!pattern) return;\n\n    switch (pattern.type) {\n      case \"ArrayPattern\":\n        this.enterArrayPattern(pattern, onIdent);\n        break;\n\n      case \"AssignmentPattern\":\n        this.enterAssignmentPattern(pattern, onIdent);\n        break;\n\n      case \"Identifier\":\n        this.enterIdentifier(pattern, onIdent);\n        break;\n\n      case \"ObjectPattern\":\n        this.enterObjectPattern(pattern, onIdent);\n        break;\n\n      case \"RestElement\":\n        this.enterRestElement(pattern, onIdent);\n        break;\n\n      case \"Property\":\n        this.enterPattern(pattern.value, onIdent);\n        break;\n    }\n  }\n\n  enterIdentifier(pattern, onIdent) {\n    onIdent(pattern.name, pattern);\n  }\n\n  enterObjectPattern(pattern, onIdent) {\n    for (let propIndex = 0, len = pattern.properties.length; propIndex < len; propIndex++) {\n      const prop = pattern.properties[propIndex];\n      this.enterPattern(prop, onIdent);\n    }\n  }\n\n  enterArrayPattern(pattern, onIdent) {\n    for (let elementIndex = 0, len = pattern.elements.length; elementIndex < len; elementIndex++) {\n      const element = pattern.elements[elementIndex];\n      this.enterPattern(element, onIdent);\n    }\n  }\n\n  enterRestElement(pattern, onIdent) {\n    this.enterPattern(pattern.argument, onIdent);\n  }\n\n  enterAssignmentPattern(pattern, onIdent) {\n    this.enterPattern(pattern.left, onIdent);\n  }\n\n  evaluateExpression(expression) {\n    try {\n      const hook = this.hooks.evaluate.get(expression.type);\n\n      if (hook !== undefined) {\n        const result = hook.call(expression);\n\n        if (result !== undefined) {\n          if (result) {\n            result.setExpression(expression);\n          }\n\n          return result;\n        }\n      }\n    } catch (e) {\n      console.warn(e); // ignore error\n    }\n\n    return new BasicEvaluatedExpression().setRange(expression.range).setExpression(expression);\n  }\n\n  parseString(expression) {\n    switch (expression.type) {\n      case \"BinaryExpression\":\n        if (expression.operator === \"+\") {\n          return this.parseString(expression.left) + this.parseString(expression.right);\n        }\n\n        break;\n\n      case \"Literal\":\n        return expression.value + \"\";\n    }\n\n    throw new Error(expression.type + \" is not supported as parameter for require\");\n  }\n\n  parseCalculatedString(expression) {\n    switch (expression.type) {\n      case \"BinaryExpression\":\n        if (expression.operator === \"+\") {\n          const left = this.parseCalculatedString(expression.left);\n          const right = this.parseCalculatedString(expression.right);\n\n          if (left.code) {\n            return {\n              range: left.range,\n              value: left.value,\n              code: true,\n              conditional: false\n            };\n          } else if (right.code) {\n            return {\n              range: [left.range[0], right.range ? right.range[1] : left.range[1]],\n              value: left.value + right.value,\n              code: true,\n              conditional: false\n            };\n          } else {\n            return {\n              range: [left.range[0], right.range[1]],\n              value: left.value + right.value,\n              code: false,\n              conditional: false\n            };\n          }\n        }\n\n        break;\n\n      case \"ConditionalExpression\":\n        {\n          const consequent = this.parseCalculatedString(expression.consequent);\n          const alternate = this.parseCalculatedString(expression.alternate);\n          const items = [];\n\n          if (consequent.conditional) {\n            items.push(...consequent.conditional);\n          } else if (!consequent.code) {\n            items.push(consequent);\n          } else {\n            break;\n          }\n\n          if (alternate.conditional) {\n            items.push(...alternate.conditional);\n          } else if (!alternate.code) {\n            items.push(alternate);\n          } else {\n            break;\n          }\n\n          return {\n            range: undefined,\n            value: \"\",\n            code: true,\n            conditional: items\n          };\n        }\n\n      case \"Literal\":\n        return {\n          range: expression.range,\n          value: expression.value + \"\",\n          code: false,\n          conditional: false\n        };\n    }\n\n    return {\n      range: undefined,\n      value: \"\",\n      code: true,\n      conditional: false\n    };\n  }\n\n  parse(source, initialState) {\n    let ast;\n    let comments;\n\n    if (typeof source === \"object\" && source !== null) {\n      ast = source;\n      comments = source.comments;\n    } else {\n      comments = [];\n      ast = Parser.parse(source, {\n        sourceType: this.sourceType,\n        onComment: comments\n      });\n    }\n\n    const oldScope = this.scope;\n    const oldState = this.state;\n    const oldComments = this.comments;\n    this.scope = {\n      topLevelScope: true,\n      inTry: false,\n      inShorthand: false,\n      isStrict: false,\n      isAsmJs: false,\n      definitions: new StackedSetMap(),\n      renames: new StackedSetMap()\n    };\n    const state = this.state = initialState || {};\n    this.comments = comments;\n\n    if (this.hooks.program.call(ast, comments) === undefined) {\n      this.detectMode(ast.body);\n      this.prewalkStatements(ast.body);\n      this.blockPrewalkStatements(ast.body);\n      this.walkStatements(ast.body);\n    }\n\n    this.scope = oldScope;\n    this.state = oldState;\n    this.comments = oldComments;\n    return state;\n  }\n\n  evaluate(source) {\n    const ast = Parser.parse(\"(\" + source + \")\", {\n      sourceType: this.sourceType,\n      locations: false\n    }); // TODO(https://github.com/acornjs/acorn/issues/741)\n    // @ts-ignore\n\n    if (ast.body.length !== 1 || ast.body[0].type !== \"ExpressionStatement\") {\n      throw new Error(\"evaluate: Source is not a expression\");\n    } // TODO(https://github.com/acornjs/acorn/issues/741)\n    // @ts-ignore\n\n\n    return this.evaluateExpression(ast.body[0].expression);\n  }\n\n  getComments(range) {\n    return this.comments.filter(comment => comment.range[0] >= range[0] && comment.range[1] <= range[1]);\n  }\n\n  parseCommentOptions(range) {\n    const comments = this.getComments(range);\n\n    if (comments.length === 0) {\n      return EMPTY_COMMENT_OPTIONS;\n    }\n\n    let options = {};\n    let errors = [];\n\n    for (const comment of comments) {\n      const {\n        value\n      } = comment;\n\n      if (value && webpackCommentRegExp.test(value)) {\n        // try compile only if webpack options comment is present\n        try {\n          const val = vm.runInNewContext(`(function(){return {${value}};})()`);\n          Object.assign(options, val);\n        } catch (e) {\n          e.comment = comment;\n          errors.push(e);\n        }\n      }\n    }\n\n    return {\n      options,\n      errors\n    };\n  }\n\n  getNameForExpression(expression) {\n    let expr = expression;\n    const exprName = [];\n\n    while (expr.type === \"MemberExpression\" && expr.property.type === (expr.computed ? \"Literal\" : \"Identifier\")) {\n      exprName.push(expr.computed ? expr.property.value : expr.property.name);\n      expr = expr.object;\n    }\n\n    let free;\n\n    if (expr.type === \"Identifier\") {\n      free = !this.scope.definitions.has(expr.name);\n      exprName.push(this.scope.renames.get(expr.name) || expr.name);\n    } else if (expr.type === \"ThisExpression\" && this.scope.renames.get(\"this\")) {\n      free = true;\n      exprName.push(this.scope.renames.get(\"this\"));\n    } else if (expr.type === \"ThisExpression\") {\n      free = this.scope.topLevelScope;\n      exprName.push(\"this\");\n    } else {\n      return null;\n    }\n\n    let prefix = \"\";\n\n    for (let i = exprName.length - 1; i >= 2; i--) {\n      prefix += exprName[i] + \".\";\n    }\n\n    if (exprName.length > 1) {\n      prefix += exprName[1];\n    }\n\n    const name = prefix ? prefix + \".\" + exprName[0] : exprName[0];\n    const nameGeneral = prefix;\n    return {\n      name,\n      nameGeneral,\n      free\n    };\n  }\n\n  static parse(code, options) {\n    const type = options ? options.sourceType : \"module\";\n    const parserOptions = Object.assign(Object.create(null), defaultParserOptions, options);\n\n    if (type === \"auto\") {\n      parserOptions.sourceType = \"module\";\n    } else if (parserOptions.sourceType === \"script\") {\n      parserOptions.allowReturnOutsideFunction = true;\n    }\n\n    let ast;\n    let error;\n    let threw = false;\n\n    try {\n      ast = acornParser.parse(code, parserOptions);\n    } catch (e) {\n      error = e;\n      threw = true;\n    }\n\n    if (threw && type === \"auto\") {\n      parserOptions.sourceType = \"script\";\n      parserOptions.allowReturnOutsideFunction = true;\n\n      if (Array.isArray(parserOptions.onComment)) {\n        parserOptions.onComment.length = 0;\n      }\n\n      try {\n        ast = acornParser.parse(code, parserOptions);\n        threw = false;\n      } catch (e) {\n        threw = true;\n      }\n    }\n\n    if (threw) {\n      throw error;\n    }\n\n    return ast;\n  }\n\n} // TODO remove in webpack 5\n\n\nObject.defineProperty(Parser.prototype, \"getCommentOptions\", {\n  configurable: false,\n  value: util.deprecate(\n  /**\n   * @deprecated\n   * @param {TODO} range Range\n   * @returns {void}\n   * @this {Parser}\n   */\n  function (range) {\n    return this.parseCommentOptions(range).options;\n  }, \"Parser.getCommentOptions: Use Parser.parseCommentOptions(range) instead\")\n});\nmodule.exports = Parser;","map":{"version":3,"sources":["E:/Users/cnki/source/repos/ab29693295/MeetAdmin/node_modules/webpack/lib/Parser.js"],"names":["acorn","require","Tapable","SyncBailHook","HookMap","util","vm","BasicEvaluatedExpression","StackedSetMap","acornParser","Parser","joinRanges","startRange","endRange","defaultParserOptions","ranges","locations","ecmaVersion","sourceType","onComment","webpackCommentRegExp","RegExp","EMPTY_COMMENT_OPTIONS","options","errors","constructor","hooks","evaluateTypeof","evaluate","evaluateIdentifier","evaluateDefinedIdentifier","evaluateCallExpressionMember","statement","statementIf","label","import","importSpecifier","export","exportImport","exportDeclaration","exportExpression","exportSpecifier","exportImportSpecifier","varDeclaration","varDeclarationLet","varDeclarationConst","varDeclarationVar","canRename","rename","assigned","assign","typeof","importCall","call","callAnyMember","new","expression","expressionAnyMember","expressionConditionalOperator","expressionLogicalOperator","program","HOOK_MAP_COMPAT_CONFIG","_pluginCompat","tap","name","Object","keys","regexp","match","exec","fn","bind","scope","undefined","state","comments","initializeEvaluating","for","expr","value","setNumber","setRange","range","setString","setBoolean","setNull","setRegExp","left","leftAsBool","right","operator","evaluateExpression","asBool","res","isString","string","isNumber","number","isWrapped","prefix","setWrapped","postfix","wrappedInnerExpressions","concat","Math","pow","isBoolean","bool","argument","type","renames","get","definitions","has","hook","exprName","getNameForExpression","free","arg","isArray","isConstArray","isRegExp","isTruthy","isFalsy","result","setIdentifier","callee","property","computed","param","object","arguments","length","arg1","arg2","regExp","replace","forEach","str","getSimplifiedTemplateResult","kind","templateLiteralExpr","quasis","parts","i","quasiExpr","quasi","prevExpr","expressions","exprAsString","asString","setExpression","push","part","node","setTemplateString","tag","identifier","stringSuffix","hasUnknownParams","argExpr","newString","newRange","split","setArray","condition","test","conditionValue","consequent","alternate","isConditional","setOptions","addOptions","items","elements","map","element","every","Boolean","setItems","getRenameIdentifier","isIdentifier","walkClass","classy","superClass","walkExpression","body","wasTopLevel","topLevelScope","methodDefinition","walkMethodDefinition","key","prewalkStatements","statements","index","len","prewalkStatement","blockPrewalkStatements","blockPrewalkStatement","walkStatements","walkStatement","prewalkBlockStatement","prewalkDoWhileStatement","prewalkExportAllDeclaration","prewalkExportDefaultDeclaration","prewalkExportNamedDeclaration","prewalkForInStatement","prewalkForOfStatement","prewalkForStatement","prewalkFunctionDeclaration","prewalkIfStatement","prewalkImportDeclaration","prewalkLabeledStatement","prewalkSwitchStatement","prewalkTryStatement","prewalkVariableDeclaration","prewalkWhileStatement","prewalkWithStatement","blockPrewalkVariableDeclaration","blockPrewalkExportDefaultDeclaration","blockPrewalkExportNamedDeclaration","blockPrewalkClassDeclaration","walkBlockStatement","walkClassDeclaration","walkDoWhileStatement","walkExportDefaultDeclaration","walkExportNamedDeclaration","walkExpressionStatement","walkForInStatement","walkForOfStatement","walkForStatement","walkFunctionDeclaration","walkIfStatement","walkLabeledStatement","walkReturnStatement","walkSwitchStatement","walkThrowStatement","walkTryStatement","walkVariableDeclaration","walkWhileStatement","walkWithStatement","inBlockScope","prewalkSwitchCases","cases","discriminant","walkSwitchCases","walkTerminatingStatement","block","inTry","handler","walkCatchClause","finalizer","init","update","walkPattern","id","set","add","inFunctionScope","params","detectMode","source","specifier","specifiers","local","imported","enterDeclaration","declaration","onIdent","declarator","declarations","enterPattern","def","specifierIndex","exported","_prewalkVariableDeclaration","hookMap","decl","renameIdentifier","delete","switchCases","switchCase","catchClause","ident","pattern","walkArrayPattern","walkAssignmentPattern","walkMemberExpression","walkObjectPattern","walkRestElement","properties","prop","walkExpressions","walkArrayExpression","walkArrowFunctionExpression","walkAssignmentExpression","walkAwaitExpression","walkBinaryExpression","walkCallExpression","walkClassExpression","walkConditionalExpression","walkFunctionExpression","walkIdentifier","walkLogicalExpression","walkNewExpression","walkObjectExpression","walkSequenceExpression","walkSpreadElement","walkTaggedTemplateExpression","walkTemplateLiteral","walkThisExpression","walkUnaryExpression","walkUpdateExpression","walkYieldExpression","propIndex","shorthand","inShorthand","scopeParams","walkLeftRightExpression","assignedHook","assignHook","_walkIIFE","functionExpression","currentThis","renameArgOrThis","argOrThis","renameThis","args","filter","idx","slice","callHook","callAnyHook","expressionHook","expressionAnyMemberHook","nameGeneral","inScope","oldScope","isStrict","isAsmJs","createChild","enterPatterns","hasThis","detectStrictMode","isLiteral","patterns","enterArrayPattern","enterAssignmentPattern","enterIdentifier","enterObjectPattern","enterRestElement","elementIndex","e","console","warn","parseString","Error","parseCalculatedString","code","conditional","parse","initialState","ast","oldState","oldComments","getComments","comment","parseCommentOptions","val","runInNewContext","parserOptions","create","allowReturnOutsideFunction","error","threw","Array","defineProperty","prototype","configurable","deprecate","module","exports"],"mappings":"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","sourcesContent":["/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\"use strict\";\n\n// Syntax: https://developer.mozilla.org/en/SpiderMonkey/Parser_API\n\nconst acorn = require(\"acorn\");\nconst { Tapable, SyncBailHook, HookMap } = require(\"tapable\");\nconst util = require(\"util\");\nconst vm = require(\"vm\");\nconst BasicEvaluatedExpression = require(\"./BasicEvaluatedExpression\");\nconst StackedSetMap = require(\"./util/StackedSetMap\");\n\nconst acornParser = acorn.Parser;\n\nconst joinRanges = (startRange, endRange) => {\n\tif (!endRange) return startRange;\n\tif (!startRange) return endRange;\n\treturn [startRange[0], endRange[1]];\n};\n\nconst defaultParserOptions = {\n\tranges: true,\n\tlocations: true,\n\tecmaVersion: 11,\n\tsourceType: \"module\",\n\tonComment: null\n};\n\n// regexp to match at least one \"magic comment\"\nconst webpackCommentRegExp = new RegExp(/(^|\\W)webpack[A-Z]{1,}[A-Za-z]{1,}:/);\n\nconst EMPTY_COMMENT_OPTIONS = {\n\toptions: null,\n\terrors: null\n};\n\nclass Parser extends Tapable {\n\tconstructor(options, sourceType = \"auto\") {\n\t\tsuper();\n\t\tthis.hooks = {\n\t\t\tevaluateTypeof: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\tevaluate: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\tevaluateIdentifier: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\tevaluateDefinedIdentifier: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\"])\n\t\t\t),\n\t\t\tevaluateCallExpressionMember: new HookMap(\n\t\t\t\t() => new SyncBailHook([\"expression\", \"param\"])\n\t\t\t),\n\t\t\tstatement: new SyncBailHook([\"statement\"]),\n\t\t\tstatementIf: new SyncBailHook([\"statement\"]),\n\t\t\tlabel: new HookMap(() => new SyncBailHook([\"statement\"])),\n\t\t\timport: new SyncBailHook([\"statement\", \"source\"]),\n\t\t\timportSpecifier: new SyncBailHook([\n\t\t\t\t\"statement\",\n\t\t\t\t\"source\",\n\t\t\t\t\"exportName\",\n\t\t\t\t\"identifierName\"\n\t\t\t]),\n\t\t\texport: new SyncBailHook([\"statement\"]),\n\t\t\texportImport: new SyncBailHook([\"statement\", \"source\"]),\n\t\t\texportDeclaration: new SyncBailHook([\"statement\", \"declaration\"]),\n\t\t\texportExpression: new SyncBailHook([\"statement\", \"declaration\"]),\n\t\t\texportSpecifier: new SyncBailHook([\n\t\t\t\t\"statement\",\n\t\t\t\t\"identifierName\",\n\t\t\t\t\"exportName\",\n\t\t\t\t\"index\"\n\t\t\t]),\n\t\t\texportImportSpecifier: new SyncBailHook([\n\t\t\t\t\"statement\",\n\t\t\t\t\"source\",\n\t\t\t\t\"identifierName\",\n\t\t\t\t\"exportName\",\n\t\t\t\t\"index\"\n\t\t\t]),\n\t\t\tvarDeclaration: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\t\t\tvarDeclarationLet: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\t\t\tvarDeclarationConst: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\t\t\tvarDeclarationVar: new HookMap(() => new SyncBailHook([\"declaration\"])),\n\t\t\tcanRename: new HookMap(() => new SyncBailHook([\"initExpression\"])),\n\t\t\trename: new HookMap(() => new SyncBailHook([\"initExpression\"])),\n\t\t\tassigned: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\tassign: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\ttypeof: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\timportCall: new SyncBailHook([\"expression\"]),\n\t\t\tcall: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\tcallAnyMember: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\tnew: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\texpression: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\texpressionAnyMember: new HookMap(() => new SyncBailHook([\"expression\"])),\n\t\t\texpressionConditionalOperator: new SyncBailHook([\"expression\"]),\n\t\t\texpressionLogicalOperator: new SyncBailHook([\"expression\"]),\n\t\t\tprogram: new SyncBailHook([\"ast\", \"comments\"])\n\t\t};\n\t\tconst HOOK_MAP_COMPAT_CONFIG = {\n\t\t\tevaluateTypeof: /^evaluate typeof (.+)$/,\n\t\t\tevaluateIdentifier: /^evaluate Identifier (.+)$/,\n\t\t\tevaluateDefinedIdentifier: /^evaluate defined Identifier (.+)$/,\n\t\t\tevaluateCallExpressionMember: /^evaluate CallExpression .(.+)$/,\n\t\t\tevaluate: /^evaluate (.+)$/,\n\t\t\tlabel: /^label (.+)$/,\n\t\t\tvarDeclarationLet: /^var-let (.+)$/,\n\t\t\tvarDeclarationConst: /^var-const (.+)$/,\n\t\t\tvarDeclarationVar: /^var-var (.+)$/,\n\t\t\tvarDeclaration: /^var (.+)$/,\n\t\t\tcanRename: /^can-rename (.+)$/,\n\t\t\trename: /^rename (.+)$/,\n\t\t\ttypeof: /^typeof (.+)$/,\n\t\t\tassigned: /^assigned (.+)$/,\n\t\t\tassign: /^assign (.+)$/,\n\t\t\tcallAnyMember: /^call (.+)\\.\\*$/,\n\t\t\tcall: /^call (.+)$/,\n\t\t\tnew: /^new (.+)$/,\n\t\t\texpressionConditionalOperator: /^expression \\?:$/,\n\t\t\texpressionAnyMember: /^expression (.+)\\.\\*$/,\n\t\t\texpression: /^expression (.+)$/\n\t\t};\n\t\tthis._pluginCompat.tap(\"Parser\", options => {\n\t\t\tfor (const name of Object.keys(HOOK_MAP_COMPAT_CONFIG)) {\n\t\t\t\tconst regexp = HOOK_MAP_COMPAT_CONFIG[name];\n\t\t\t\tconst match = regexp.exec(options.name);\n\t\t\t\tif (match) {\n\t\t\t\t\tif (match[1]) {\n\t\t\t\t\t\tthis.hooks[name].tap(\n\t\t\t\t\t\t\tmatch[1],\n\t\t\t\t\t\t\toptions.fn.name || \"unnamed compat plugin\",\n\t\t\t\t\t\t\toptions.fn.bind(this)\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.hooks[name].tap(\n\t\t\t\t\t\t\toptions.fn.name || \"unnamed compat plugin\",\n\t\t\t\t\t\t\toptions.fn.bind(this)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tthis.options = options;\n\t\tthis.sourceType = sourceType;\n\t\tthis.scope = undefined;\n\t\tthis.state = undefined;\n\t\tthis.comments = undefined;\n\t\tthis.initializeEvaluating();\n\t}\n\n\tinitializeEvaluating() {\n\t\tthis.hooks.evaluate.for(\"Literal\").tap(\"Parser\", expr => {\n\t\t\tswitch (typeof expr.value) {\n\t\t\t\tcase \"number\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setNumber(expr.value)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\tcase \"string\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(expr.value)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\tcase \"boolean\":\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(expr.value)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t}\n\t\t\tif (expr.value === null) {\n\t\t\t\treturn new BasicEvaluatedExpression().setNull().setRange(expr.range);\n\t\t\t}\n\t\t\tif (expr.value instanceof RegExp) {\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setRegExp(expr.value)\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluate.for(\"LogicalExpression\").tap(\"Parser\", expr => {\n\t\t\tlet left;\n\t\t\tlet leftAsBool;\n\t\t\tlet right;\n\t\t\tif (expr.operator === \"&&\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tleftAsBool = left && left.asBool();\n\t\t\t\tif (leftAsBool === false) return left.setRange(expr.range);\n\t\t\t\tif (leftAsBool !== true) return;\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\treturn right.setRange(expr.range);\n\t\t\t} else if (expr.operator === \"||\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tleftAsBool = left && left.asBool();\n\t\t\t\tif (leftAsBool === true) return left.setRange(expr.range);\n\t\t\t\tif (leftAsBool !== false) return;\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\treturn right.setRange(expr.range);\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluate.for(\"BinaryExpression\").tap(\"Parser\", expr => {\n\t\t\tlet left;\n\t\t\tlet right;\n\t\t\tlet res;\n\t\t\tif (expr.operator === \"+\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tif (left.isString()) {\n\t\t\t\t\tif (right.isString()) {\n\t\t\t\t\t\tres.setString(left.string + right.string);\n\t\t\t\t\t} else if (right.isNumber()) {\n\t\t\t\t\t\tres.setString(left.string + right.number);\n\t\t\t\t\t} else if (\n\t\t\t\t\t\tright.isWrapped() &&\n\t\t\t\t\t\tright.prefix &&\n\t\t\t\t\t\tright.prefix.isString()\n\t\t\t\t\t) {\n\t\t\t\t\t\t// \"left\" + (\"prefix\" + inner + \"postfix\")\n\t\t\t\t\t\t// => (\"leftprefix\" + inner + \"postfix\")\n\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t.setString(left.string + right.prefix.string)\n\t\t\t\t\t\t\t\t.setRange(joinRanges(left.range, right.prefix.range)),\n\t\t\t\t\t\t\tright.postfix,\n\t\t\t\t\t\t\tright.wrappedInnerExpressions\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (right.isWrapped()) {\n\t\t\t\t\t\t// \"left\" + ([null] + inner + \"postfix\")\n\t\t\t\t\t\t// => (\"left\" + inner + \"postfix\")\n\t\t\t\t\t\tres.setWrapped(left, right.postfix, right.wrappedInnerExpressions);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// \"left\" + expr\n\t\t\t\t\t\t// => (\"left\" + expr + \"\")\n\t\t\t\t\t\tres.setWrapped(left, null, [right]);\n\t\t\t\t\t}\n\t\t\t\t} else if (left.isNumber()) {\n\t\t\t\t\tif (right.isString()) {\n\t\t\t\t\t\tres.setString(left.number + right.string);\n\t\t\t\t\t} else if (right.isNumber()) {\n\t\t\t\t\t\tres.setNumber(left.number + right.number);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t} else if (left.isWrapped()) {\n\t\t\t\t\tif (left.postfix && left.postfix.isString() && right.isString()) {\n\t\t\t\t\t\t// (\"prefix\" + inner + \"postfix\") + \"right\"\n\t\t\t\t\t\t// => (\"prefix\" + inner + \"postfixright\")\n\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t.setString(left.postfix.string + right.string)\n\t\t\t\t\t\t\t\t.setRange(joinRanges(left.postfix.range, right.range)),\n\t\t\t\t\t\t\tleft.wrappedInnerExpressions\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (\n\t\t\t\t\t\tleft.postfix &&\n\t\t\t\t\t\tleft.postfix.isString() &&\n\t\t\t\t\t\tright.isNumber()\n\t\t\t\t\t) {\n\t\t\t\t\t\t// (\"prefix\" + inner + \"postfix\") + 123\n\t\t\t\t\t\t// => (\"prefix\" + inner + \"postfix123\")\n\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t.setString(left.postfix.string + right.number)\n\t\t\t\t\t\t\t\t.setRange(joinRanges(left.postfix.range, right.range)),\n\t\t\t\t\t\t\tleft.wrappedInnerExpressions\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (right.isString()) {\n\t\t\t\t\t\t// (\"prefix\" + inner + [null]) + \"right\"\n\t\t\t\t\t\t// => (\"prefix\" + inner + \"right\")\n\t\t\t\t\t\tres.setWrapped(left.prefix, right, left.wrappedInnerExpressions);\n\t\t\t\t\t} else if (right.isNumber()) {\n\t\t\t\t\t\t// (\"prefix\" + inner + [null]) + 123\n\t\t\t\t\t\t// => (\"prefix\" + inner + \"123\")\n\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\tnew BasicEvaluatedExpression()\n\t\t\t\t\t\t\t\t.setString(right.number + \"\")\n\t\t\t\t\t\t\t\t.setRange(right.range),\n\t\t\t\t\t\t\tleft.wrappedInnerExpressions\n\t\t\t\t\t\t);\n\t\t\t\t\t} else if (right.isWrapped()) {\n\t\t\t\t\t\t// (\"prefix1\" + inner1 + \"postfix1\") + (\"prefix2\" + inner2 + \"postfix2\")\n\t\t\t\t\t\t// (\"prefix1\" + inner1 + \"postfix1\" + \"prefix2\" + inner2 + \"postfix2\")\n\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\tright.postfix,\n\t\t\t\t\t\t\tleft.wrappedInnerExpressions &&\n\t\t\t\t\t\t\t\tright.wrappedInnerExpressions &&\n\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions\n\t\t\t\t\t\t\t\t\t.concat(left.postfix ? [left.postfix] : [])\n\t\t\t\t\t\t\t\t\t.concat(right.prefix ? [right.prefix] : [])\n\t\t\t\t\t\t\t\t\t.concat(right.wrappedInnerExpressions)\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// (\"prefix\" + inner + postfix) + expr\n\t\t\t\t\t\t// => (\"prefix\" + inner + postfix + expr + [null])\n\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\tleft.prefix,\n\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\tleft.wrappedInnerExpressions &&\n\t\t\t\t\t\t\t\tleft.wrappedInnerExpressions.concat(\n\t\t\t\t\t\t\t\t\tleft.postfix ? [left.postfix, right] : [right]\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (right.isString()) {\n\t\t\t\t\t\t// left + \"right\"\n\t\t\t\t\t\t// => ([null] + left + \"right\")\n\t\t\t\t\t\tres.setWrapped(null, right, [left]);\n\t\t\t\t\t} else if (right.isWrapped()) {\n\t\t\t\t\t\t// left + (prefix + inner + \"postfix\")\n\t\t\t\t\t\t// => ([null] + left + prefix + inner + \"postfix\")\n\t\t\t\t\t\tres.setWrapped(\n\t\t\t\t\t\t\tnull,\n\t\t\t\t\t\t\tright.postfix,\n\t\t\t\t\t\t\tright.wrappedInnerExpressions &&\n\t\t\t\t\t\t\t\t(right.prefix ? [left, right.prefix] : [left]).concat(\n\t\t\t\t\t\t\t\t\tright.wrappedInnerExpressions\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \"-\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number - right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \"*\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number * right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \"/\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number / right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \"**\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(Math.pow(left.number, right.number));\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \"==\" || expr.operator === \"===\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\tif (left.isString() && right.isString()) {\n\t\t\t\t\treturn res.setBoolean(left.string === right.string);\n\t\t\t\t} else if (left.isNumber() && right.isNumber()) {\n\t\t\t\t\treturn res.setBoolean(left.number === right.number);\n\t\t\t\t} else if (left.isBoolean() && right.isBoolean()) {\n\t\t\t\t\treturn res.setBoolean(left.bool === right.bool);\n\t\t\t\t}\n\t\t\t} else if (expr.operator === \"!=\" || expr.operator === \"!==\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\tif (left.isString() && right.isString()) {\n\t\t\t\t\treturn res.setBoolean(left.string !== right.string);\n\t\t\t\t} else if (left.isNumber() && right.isNumber()) {\n\t\t\t\t\treturn res.setBoolean(left.number !== right.number);\n\t\t\t\t} else if (left.isBoolean() && right.isBoolean()) {\n\t\t\t\t\treturn res.setBoolean(left.bool !== right.bool);\n\t\t\t\t}\n\t\t\t} else if (expr.operator === \"&\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number & right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \"|\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number | right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \"^\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number ^ right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \">>>\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number >>> right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \">>\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number >> right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t} else if (expr.operator === \"<<\") {\n\t\t\t\tleft = this.evaluateExpression(expr.left);\n\t\t\t\tright = this.evaluateExpression(expr.right);\n\t\t\t\tif (!left || !right) return;\n\t\t\t\tif (!left.isNumber() || !right.isNumber()) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(left.number << right.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluate.for(\"UnaryExpression\").tap(\"Parser\", expr => {\n\t\t\tif (expr.operator === \"typeof\") {\n\t\t\t\tlet res;\n\t\t\t\tlet name;\n\t\t\t\tif (expr.argument.type === \"Identifier\") {\n\t\t\t\t\tname =\n\t\t\t\t\t\tthis.scope.renames.get(expr.argument.name) || expr.argument.name;\n\t\t\t\t\tif (!this.scope.definitions.has(name)) {\n\t\t\t\t\t\tconst hook = this.hooks.evaluateTypeof.get(name);\n\t\t\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\t\t\tres = hook.call(expr);\n\t\t\t\t\t\t\tif (res !== undefined) return res;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (expr.argument.type === \"MemberExpression\") {\n\t\t\t\t\tconst exprName = this.getNameForExpression(expr.argument);\n\t\t\t\t\tif (exprName && exprName.free) {\n\t\t\t\t\t\tconst hook = this.hooks.evaluateTypeof.get(exprName.name);\n\t\t\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\t\t\tres = hook.call(expr);\n\t\t\t\t\t\t\tif (res !== undefined) return res;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (expr.argument.type === \"FunctionExpression\") {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(\"function\")\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t\tconst arg = this.evaluateExpression(expr.argument);\n\t\t\t\tif (arg.isString() || arg.isWrapped()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(\"string\")\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t\tif (arg.isNumber()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(\"number\")\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t\tif (arg.isBoolean()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(\"boolean\")\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t\tif (arg.isArray() || arg.isConstArray() || arg.isRegExp()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(\"object\")\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t} else if (expr.operator === \"!\") {\n\t\t\t\tconst argument = this.evaluateExpression(expr.argument);\n\t\t\t\tif (!argument) return;\n\t\t\t\tif (argument.isBoolean()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(!argument.bool)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t\tif (argument.isTruthy()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(false)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t\tif (argument.isFalsy()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(true)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t\tif (argument.isString()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(!argument.string)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t\tif (argument.isNumber()) {\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setBoolean(!argument.number)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t} else if (expr.operator === \"~\") {\n\t\t\t\tconst argument = this.evaluateExpression(expr.argument);\n\t\t\t\tif (!argument) return;\n\t\t\t\tif (!argument.isNumber()) return;\n\t\t\t\tconst res = new BasicEvaluatedExpression();\n\t\t\t\tres.setNumber(~argument.number);\n\t\t\t\tres.setRange(expr.range);\n\t\t\t\treturn res;\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluateTypeof.for(\"undefined\").tap(\"Parser\", expr => {\n\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t.setString(\"undefined\")\n\t\t\t\t.setRange(expr.range);\n\t\t});\n\t\tthis.hooks.evaluate.for(\"Identifier\").tap(\"Parser\", expr => {\n\t\t\tconst name = this.scope.renames.get(expr.name) || expr.name;\n\t\t\tif (!this.scope.definitions.has(expr.name)) {\n\t\t\t\tconst hook = this.hooks.evaluateIdentifier.get(name);\n\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\tconst result = hook.call(expr);\n\t\t\t\t\tif (result) return result;\n\t\t\t\t}\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setIdentifier(name)\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t} else {\n\t\t\t\tconst hook = this.hooks.evaluateDefinedIdentifier.get(name);\n\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\treturn hook.call(expr);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluate.for(\"ThisExpression\").tap(\"Parser\", expr => {\n\t\t\tconst name = this.scope.renames.get(\"this\");\n\t\t\tif (name) {\n\t\t\t\tconst hook = this.hooks.evaluateIdentifier.get(name);\n\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\tconst result = hook.call(expr);\n\t\t\t\t\tif (result) return result;\n\t\t\t\t}\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setIdentifier(name)\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluate.for(\"MemberExpression\").tap(\"Parser\", expression => {\n\t\t\tlet exprName = this.getNameForExpression(expression);\n\t\t\tif (exprName) {\n\t\t\t\tif (exprName.free) {\n\t\t\t\t\tconst hook = this.hooks.evaluateIdentifier.get(exprName.name);\n\t\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\t\tconst result = hook.call(expression);\n\t\t\t\t\t\tif (result) return result;\n\t\t\t\t\t}\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setIdentifier(exprName.name)\n\t\t\t\t\t\t.setRange(expression.range);\n\t\t\t\t} else {\n\t\t\t\t\tconst hook = this.hooks.evaluateDefinedIdentifier.get(exprName.name);\n\t\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\t\treturn hook.call(expression);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluate.for(\"CallExpression\").tap(\"Parser\", expr => {\n\t\t\tif (expr.callee.type !== \"MemberExpression\") return;\n\t\t\tif (\n\t\t\t\texpr.callee.property.type !==\n\t\t\t\t(expr.callee.computed ? \"Literal\" : \"Identifier\")\n\t\t\t)\n\t\t\t\treturn;\n\t\t\tconst param = this.evaluateExpression(expr.callee.object);\n\t\t\tif (!param) return;\n\t\t\tconst property = expr.callee.property.name || expr.callee.property.value;\n\t\t\tconst hook = this.hooks.evaluateCallExpressionMember.get(property);\n\t\t\tif (hook !== undefined) {\n\t\t\t\treturn hook.call(expr, param);\n\t\t\t}\n\t\t});\n\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t.for(\"replace\")\n\t\t\t.tap(\"Parser\", (expr, param) => {\n\t\t\t\tif (!param.isString()) return;\n\t\t\t\tif (expr.arguments.length !== 2) return;\n\t\t\t\tlet arg1 = this.evaluateExpression(expr.arguments[0]);\n\t\t\t\tlet arg2 = this.evaluateExpression(expr.arguments[1]);\n\t\t\t\tif (!arg1.isString() && !arg1.isRegExp()) return;\n\t\t\t\targ1 = arg1.regExp || arg1.string;\n\t\t\t\tif (!arg2.isString()) return;\n\t\t\t\targ2 = arg2.string;\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setString(param.string.replace(arg1, arg2))\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t});\n\t\t[\"substr\", \"substring\"].forEach(fn => {\n\t\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t\t.for(fn)\n\t\t\t\t.tap(\"Parser\", (expr, param) => {\n\t\t\t\t\tif (!param.isString()) return;\n\t\t\t\t\tlet arg1;\n\t\t\t\t\tlet result,\n\t\t\t\t\t\tstr = param.string;\n\t\t\t\t\tswitch (expr.arguments.length) {\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\targ1 = this.evaluateExpression(expr.arguments[0]);\n\t\t\t\t\t\t\tif (!arg1.isNumber()) return;\n\t\t\t\t\t\t\tresult = str[fn](arg1.number);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 2: {\n\t\t\t\t\t\t\targ1 = this.evaluateExpression(expr.arguments[0]);\n\t\t\t\t\t\t\tconst arg2 = this.evaluateExpression(expr.arguments[1]);\n\t\t\t\t\t\t\tif (!arg1.isNumber()) return;\n\t\t\t\t\t\t\tif (!arg2.isNumber()) return;\n\t\t\t\t\t\t\tresult = str[fn](arg1.number, arg2.number);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(result)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t});\n\t\t});\n\n\t\t/**\n\t\t * @param {string} kind \"cooked\" | \"raw\"\n\t\t * @param {TODO} templateLiteralExpr TemplateLiteral expr\n\t\t * @returns {{quasis: BasicEvaluatedExpression[], parts: BasicEvaluatedExpression[]}} Simplified template\n\t\t */\n\t\tconst getSimplifiedTemplateResult = (kind, templateLiteralExpr) => {\n\t\t\tconst quasis = [];\n\t\t\tconst parts = [];\n\n\t\t\tfor (let i = 0; i < templateLiteralExpr.quasis.length; i++) {\n\t\t\t\tconst quasiExpr = templateLiteralExpr.quasis[i];\n\t\t\t\tconst quasi = quasiExpr.value[kind];\n\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tconst prevExpr = parts[parts.length - 1];\n\t\t\t\t\tconst expr = this.evaluateExpression(\n\t\t\t\t\t\ttemplateLiteralExpr.expressions[i - 1]\n\t\t\t\t\t);\n\t\t\t\t\tconst exprAsString = expr.asString();\n\t\t\t\t\tif (typeof exprAsString === \"string\") {\n\t\t\t\t\t\t// We can merge quasi + expr + quasi when expr\n\t\t\t\t\t\t// is a const string\n\n\t\t\t\t\t\tprevExpr.setString(prevExpr.string + exprAsString + quasi);\n\t\t\t\t\t\tprevExpr.setRange([prevExpr.range[0], quasiExpr.range[1]]);\n\t\t\t\t\t\t// We unset the expression as it doesn't match to a single expression\n\t\t\t\t\t\tprevExpr.setExpression(undefined);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tparts.push(expr);\n\t\t\t\t}\n\n\t\t\t\tconst part = new BasicEvaluatedExpression()\n\t\t\t\t\t.setString(quasi)\n\t\t\t\t\t.setRange(quasiExpr.range)\n\t\t\t\t\t.setExpression(quasiExpr);\n\t\t\t\tquasis.push(part);\n\t\t\t\tparts.push(part);\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tquasis,\n\t\t\t\tparts\n\t\t\t};\n\t\t};\n\n\t\tthis.hooks.evaluate.for(\"TemplateLiteral\").tap(\"Parser\", node => {\n\t\t\tconst { quasis, parts } = getSimplifiedTemplateResult(\"cooked\", node);\n\t\t\tif (parts.length === 1) {\n\t\t\t\treturn parts[0].setRange(node.range);\n\t\t\t}\n\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t.setTemplateString(quasis, parts, \"cooked\")\n\t\t\t\t.setRange(node.range);\n\t\t});\n\t\tthis.hooks.evaluate.for(\"TaggedTemplateExpression\").tap(\"Parser\", node => {\n\t\t\tif (this.evaluateExpression(node.tag).identifier !== \"String.raw\") return;\n\t\t\tconst { quasis, parts } = getSimplifiedTemplateResult(\"raw\", node.quasi);\n\t\t\tif (parts.length === 1) {\n\t\t\t\treturn parts[0].setRange(node.range);\n\t\t\t}\n\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t.setTemplateString(quasis, parts, \"raw\")\n\t\t\t\t.setRange(node.range);\n\t\t});\n\n\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t.for(\"concat\")\n\t\t\t.tap(\"Parser\", (expr, param) => {\n\t\t\t\tif (!param.isString() && !param.isWrapped()) return;\n\n\t\t\t\tlet stringSuffix = null;\n\t\t\t\tlet hasUnknownParams = false;\n\t\t\t\tfor (let i = expr.arguments.length - 1; i >= 0; i--) {\n\t\t\t\t\tconst argExpr = this.evaluateExpression(expr.arguments[i]);\n\t\t\t\t\tif (!argExpr.isString() && !argExpr.isNumber()) {\n\t\t\t\t\t\thasUnknownParams = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst value = argExpr.isString()\n\t\t\t\t\t\t? argExpr.string\n\t\t\t\t\t\t: \"\" + argExpr.number;\n\n\t\t\t\t\tconst newString = value + (stringSuffix ? stringSuffix.string : \"\");\n\t\t\t\t\tconst newRange = [\n\t\t\t\t\t\targExpr.range[0],\n\t\t\t\t\t\t(stringSuffix || argExpr).range[1]\n\t\t\t\t\t];\n\t\t\t\t\tstringSuffix = new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(newString)\n\t\t\t\t\t\t.setRange(newRange);\n\t\t\t\t}\n\n\t\t\t\tif (hasUnknownParams) {\n\t\t\t\t\tconst prefix = param.isString() ? param : param.prefix;\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setWrapped(prefix, stringSuffix)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t} else if (param.isWrapped()) {\n\t\t\t\t\tconst postfix = stringSuffix || param.postfix;\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setWrapped(param.prefix, postfix)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t} else {\n\t\t\t\t\tconst newString =\n\t\t\t\t\t\tparam.string + (stringSuffix ? stringSuffix.string : \"\");\n\t\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t\t.setString(newString)\n\t\t\t\t\t\t.setRange(expr.range);\n\t\t\t\t}\n\t\t\t});\n\t\tthis.hooks.evaluateCallExpressionMember\n\t\t\t.for(\"split\")\n\t\t\t.tap(\"Parser\", (expr, param) => {\n\t\t\t\tif (!param.isString()) return;\n\t\t\t\tif (expr.arguments.length !== 1) return;\n\t\t\t\tlet result;\n\t\t\t\tconst arg = this.evaluateExpression(expr.arguments[0]);\n\t\t\t\tif (arg.isString()) {\n\t\t\t\t\tresult = param.string.split(arg.string);\n\t\t\t\t} else if (arg.isRegExp()) {\n\t\t\t\t\tresult = param.string.split(arg.regExp);\n\t\t\t\t} else {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t\t.setArray(result)\n\t\t\t\t\t.setRange(expr.range);\n\t\t\t});\n\t\tthis.hooks.evaluate.for(\"ConditionalExpression\").tap(\"Parser\", expr => {\n\t\t\tconst condition = this.evaluateExpression(expr.test);\n\t\t\tconst conditionValue = condition.asBool();\n\t\t\tlet res;\n\t\t\tif (conditionValue === undefined) {\n\t\t\t\tconst consequent = this.evaluateExpression(expr.consequent);\n\t\t\t\tconst alternate = this.evaluateExpression(expr.alternate);\n\t\t\t\tif (!consequent || !alternate) return;\n\t\t\t\tres = new BasicEvaluatedExpression();\n\t\t\t\tif (consequent.isConditional()) {\n\t\t\t\t\tres.setOptions(consequent.options);\n\t\t\t\t} else {\n\t\t\t\t\tres.setOptions([consequent]);\n\t\t\t\t}\n\t\t\t\tif (alternate.isConditional()) {\n\t\t\t\t\tres.addOptions(alternate.options);\n\t\t\t\t} else {\n\t\t\t\t\tres.addOptions([alternate]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tres = this.evaluateExpression(\n\t\t\t\t\tconditionValue ? expr.consequent : expr.alternate\n\t\t\t\t);\n\t\t\t}\n\t\t\tres.setRange(expr.range);\n\t\t\treturn res;\n\t\t});\n\t\tthis.hooks.evaluate.for(\"ArrayExpression\").tap(\"Parser\", expr => {\n\t\t\tconst items = expr.elements.map(element => {\n\t\t\t\treturn element !== null && this.evaluateExpression(element);\n\t\t\t});\n\t\t\tif (!items.every(Boolean)) return;\n\t\t\treturn new BasicEvaluatedExpression()\n\t\t\t\t.setItems(items)\n\t\t\t\t.setRange(expr.range);\n\t\t});\n\t}\n\n\tgetRenameIdentifier(expr) {\n\t\tconst result = this.evaluateExpression(expr);\n\t\tif (result && result.isIdentifier()) {\n\t\t\treturn result.identifier;\n\t\t}\n\t}\n\n\twalkClass(classy) {\n\t\tif (classy.superClass) this.walkExpression(classy.superClass);\n\t\tif (classy.body && classy.body.type === \"ClassBody\") {\n\t\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\t\tthis.scope.topLevelScope = false;\n\t\t\tfor (const methodDefinition of classy.body.body) {\n\t\t\t\tif (methodDefinition.type === \"MethodDefinition\") {\n\t\t\t\t\tthis.walkMethodDefinition(methodDefinition);\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.scope.topLevelScope = wasTopLevel;\n\t\t}\n\t}\n\n\twalkMethodDefinition(methodDefinition) {\n\t\tif (methodDefinition.computed && methodDefinition.key) {\n\t\t\tthis.walkExpression(methodDefinition.key);\n\t\t}\n\t\tif (methodDefinition.value) {\n\t\t\tthis.walkExpression(methodDefinition.value);\n\t\t}\n\t}\n\n\t// Prewalking iterates the scope for variable declarations\n\tprewalkStatements(statements) {\n\t\tfor (let index = 0, len = statements.length; index < len; index++) {\n\t\t\tconst statement = statements[index];\n\t\t\tthis.prewalkStatement(statement);\n\t\t}\n\t}\n\n\t// Block-Prewalking iterates the scope for block variable declarations\n\tblockPrewalkStatements(statements) {\n\t\tfor (let index = 0, len = statements.length; index < len; index++) {\n\t\t\tconst statement = statements[index];\n\t\t\tthis.blockPrewalkStatement(statement);\n\t\t}\n\t}\n\n\t// Walking iterates the statements and expressions and processes them\n\twalkStatements(statements) {\n\t\tfor (let index = 0, len = statements.length; index < len; index++) {\n\t\t\tconst statement = statements[index];\n\t\t\tthis.walkStatement(statement);\n\t\t}\n\t}\n\n\tprewalkStatement(statement) {\n\t\tswitch (statement.type) {\n\t\t\tcase \"BlockStatement\":\n\t\t\t\tthis.prewalkBlockStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"DoWhileStatement\":\n\t\t\t\tthis.prewalkDoWhileStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportAllDeclaration\":\n\t\t\t\tthis.prewalkExportAllDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportDefaultDeclaration\":\n\t\t\t\tthis.prewalkExportDefaultDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportNamedDeclaration\":\n\t\t\t\tthis.prewalkExportNamedDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForInStatement\":\n\t\t\t\tthis.prewalkForInStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForOfStatement\":\n\t\t\t\tthis.prewalkForOfStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForStatement\":\n\t\t\t\tthis.prewalkForStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionDeclaration\":\n\t\t\t\tthis.prewalkFunctionDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"IfStatement\":\n\t\t\t\tthis.prewalkIfStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ImportDeclaration\":\n\t\t\t\tthis.prewalkImportDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"LabeledStatement\":\n\t\t\t\tthis.prewalkLabeledStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"SwitchStatement\":\n\t\t\t\tthis.prewalkSwitchStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"TryStatement\":\n\t\t\t\tthis.prewalkTryStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tthis.prewalkVariableDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"WhileStatement\":\n\t\t\t\tthis.prewalkWhileStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"WithStatement\":\n\t\t\t\tthis.prewalkWithStatement(statement);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tblockPrewalkStatement(statement) {\n\t\tswitch (statement.type) {\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tthis.blockPrewalkVariableDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportDefaultDeclaration\":\n\t\t\t\tthis.blockPrewalkExportDefaultDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportNamedDeclaration\":\n\t\t\t\tthis.blockPrewalkExportNamedDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ClassDeclaration\":\n\t\t\t\tthis.blockPrewalkClassDeclaration(statement);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\twalkStatement(statement) {\n\t\tif (this.hooks.statement.call(statement) !== undefined) return;\n\t\tswitch (statement.type) {\n\t\t\tcase \"BlockStatement\":\n\t\t\t\tthis.walkBlockStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ClassDeclaration\":\n\t\t\t\tthis.walkClassDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"DoWhileStatement\":\n\t\t\t\tthis.walkDoWhileStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportDefaultDeclaration\":\n\t\t\t\tthis.walkExportDefaultDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExportNamedDeclaration\":\n\t\t\t\tthis.walkExportNamedDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ExpressionStatement\":\n\t\t\t\tthis.walkExpressionStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForInStatement\":\n\t\t\t\tthis.walkForInStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForOfStatement\":\n\t\t\t\tthis.walkForOfStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ForStatement\":\n\t\t\t\tthis.walkForStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionDeclaration\":\n\t\t\t\tthis.walkFunctionDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"IfStatement\":\n\t\t\t\tthis.walkIfStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"LabeledStatement\":\n\t\t\t\tthis.walkLabeledStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ReturnStatement\":\n\t\t\t\tthis.walkReturnStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"SwitchStatement\":\n\t\t\t\tthis.walkSwitchStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"ThrowStatement\":\n\t\t\t\tthis.walkThrowStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"TryStatement\":\n\t\t\t\tthis.walkTryStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tthis.walkVariableDeclaration(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"WhileStatement\":\n\t\t\t\tthis.walkWhileStatement(statement);\n\t\t\t\tbreak;\n\t\t\tcase \"WithStatement\":\n\t\t\t\tthis.walkWithStatement(statement);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Real Statements\n\tprewalkBlockStatement(statement) {\n\t\tthis.prewalkStatements(statement.body);\n\t}\n\n\twalkBlockStatement(statement) {\n\t\tthis.inBlockScope(() => {\n\t\t\tconst body = statement.body;\n\t\t\tthis.blockPrewalkStatements(body);\n\t\t\tthis.walkStatements(body);\n\t\t});\n\t}\n\n\twalkExpressionStatement(statement) {\n\t\tthis.walkExpression(statement.expression);\n\t}\n\n\tprewalkIfStatement(statement) {\n\t\tthis.prewalkStatement(statement.consequent);\n\t\tif (statement.alternate) {\n\t\t\tthis.prewalkStatement(statement.alternate);\n\t\t}\n\t}\n\n\twalkIfStatement(statement) {\n\t\tconst result = this.hooks.statementIf.call(statement);\n\t\tif (result === undefined) {\n\t\t\tthis.walkExpression(statement.test);\n\t\t\tthis.walkStatement(statement.consequent);\n\t\t\tif (statement.alternate) {\n\t\t\t\tthis.walkStatement(statement.alternate);\n\t\t\t}\n\t\t} else {\n\t\t\tif (result) {\n\t\t\t\tthis.walkStatement(statement.consequent);\n\t\t\t} else if (statement.alternate) {\n\t\t\t\tthis.walkStatement(statement.alternate);\n\t\t\t}\n\t\t}\n\t}\n\n\tprewalkLabeledStatement(statement) {\n\t\tthis.prewalkStatement(statement.body);\n\t}\n\n\twalkLabeledStatement(statement) {\n\t\tconst hook = this.hooks.label.get(statement.label.name);\n\t\tif (hook !== undefined) {\n\t\t\tconst result = hook.call(statement);\n\t\t\tif (result === true) return;\n\t\t}\n\t\tthis.walkStatement(statement.body);\n\t}\n\n\tprewalkWithStatement(statement) {\n\t\tthis.prewalkStatement(statement.body);\n\t}\n\n\twalkWithStatement(statement) {\n\t\tthis.walkExpression(statement.object);\n\t\tthis.walkStatement(statement.body);\n\t}\n\n\tprewalkSwitchStatement(statement) {\n\t\tthis.prewalkSwitchCases(statement.cases);\n\t}\n\n\twalkSwitchStatement(statement) {\n\t\tthis.walkExpression(statement.discriminant);\n\t\tthis.walkSwitchCases(statement.cases);\n\t}\n\n\twalkTerminatingStatement(statement) {\n\t\tif (statement.argument) this.walkExpression(statement.argument);\n\t}\n\n\twalkReturnStatement(statement) {\n\t\tthis.walkTerminatingStatement(statement);\n\t}\n\n\twalkThrowStatement(statement) {\n\t\tthis.walkTerminatingStatement(statement);\n\t}\n\n\tprewalkTryStatement(statement) {\n\t\tthis.prewalkStatement(statement.block);\n\t}\n\n\twalkTryStatement(statement) {\n\t\tif (this.scope.inTry) {\n\t\t\tthis.walkStatement(statement.block);\n\t\t} else {\n\t\t\tthis.scope.inTry = true;\n\t\t\tthis.walkStatement(statement.block);\n\t\t\tthis.scope.inTry = false;\n\t\t}\n\t\tif (statement.handler) this.walkCatchClause(statement.handler);\n\t\tif (statement.finalizer) this.walkStatement(statement.finalizer);\n\t}\n\n\tprewalkWhileStatement(statement) {\n\t\tthis.prewalkStatement(statement.body);\n\t}\n\n\twalkWhileStatement(statement) {\n\t\tthis.walkExpression(statement.test);\n\t\tthis.walkStatement(statement.body);\n\t}\n\n\tprewalkDoWhileStatement(statement) {\n\t\tthis.prewalkStatement(statement.body);\n\t}\n\n\twalkDoWhileStatement(statement) {\n\t\tthis.walkStatement(statement.body);\n\t\tthis.walkExpression(statement.test);\n\t}\n\n\tprewalkForStatement(statement) {\n\t\tif (statement.init) {\n\t\t\tif (statement.init.type === \"VariableDeclaration\") {\n\t\t\t\tthis.prewalkStatement(statement.init);\n\t\t\t}\n\t\t}\n\t\tthis.prewalkStatement(statement.body);\n\t}\n\n\twalkForStatement(statement) {\n\t\tthis.inBlockScope(() => {\n\t\t\tif (statement.init) {\n\t\t\t\tif (statement.init.type === \"VariableDeclaration\") {\n\t\t\t\t\tthis.blockPrewalkVariableDeclaration(statement.init);\n\t\t\t\t\tthis.walkStatement(statement.init);\n\t\t\t\t} else {\n\t\t\t\t\tthis.walkExpression(statement.init);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (statement.test) {\n\t\t\t\tthis.walkExpression(statement.test);\n\t\t\t}\n\t\t\tif (statement.update) {\n\t\t\t\tthis.walkExpression(statement.update);\n\t\t\t}\n\t\t\tconst body = statement.body;\n\t\t\tif (body.type === \"BlockStatement\") {\n\t\t\t\t// no need to add additional scope\n\t\t\t\tthis.blockPrewalkStatements(body.body);\n\t\t\t\tthis.walkStatements(body.body);\n\t\t\t} else {\n\t\t\t\tthis.walkStatement(body);\n\t\t\t}\n\t\t});\n\t}\n\n\tprewalkForInStatement(statement) {\n\t\tif (statement.left.type === \"VariableDeclaration\") {\n\t\t\tthis.prewalkVariableDeclaration(statement.left);\n\t\t}\n\t\tthis.prewalkStatement(statement.body);\n\t}\n\n\twalkForInStatement(statement) {\n\t\tthis.inBlockScope(() => {\n\t\t\tif (statement.left.type === \"VariableDeclaration\") {\n\t\t\t\tthis.blockPrewalkVariableDeclaration(statement.left);\n\t\t\t\tthis.walkVariableDeclaration(statement.left);\n\t\t\t} else {\n\t\t\t\tthis.walkPattern(statement.left);\n\t\t\t}\n\t\t\tthis.walkExpression(statement.right);\n\t\t\tconst body = statement.body;\n\t\t\tif (body.type === \"BlockStatement\") {\n\t\t\t\t// no need to add additional scope\n\t\t\t\tthis.blockPrewalkStatements(body.body);\n\t\t\t\tthis.walkStatements(body.body);\n\t\t\t} else {\n\t\t\t\tthis.walkStatement(body);\n\t\t\t}\n\t\t});\n\t}\n\n\tprewalkForOfStatement(statement) {\n\t\tif (statement.left.type === \"VariableDeclaration\") {\n\t\t\tthis.prewalkVariableDeclaration(statement.left);\n\t\t}\n\t\tthis.prewalkStatement(statement.body);\n\t}\n\n\twalkForOfStatement(statement) {\n\t\tthis.inBlockScope(() => {\n\t\t\tif (statement.left.type === \"VariableDeclaration\") {\n\t\t\t\tthis.blockPrewalkVariableDeclaration(statement.left);\n\t\t\t\tthis.walkVariableDeclaration(statement.left);\n\t\t\t} else {\n\t\t\t\tthis.walkPattern(statement.left);\n\t\t\t}\n\t\t\tthis.walkExpression(statement.right);\n\t\t\tconst body = statement.body;\n\t\t\tif (body.type === \"BlockStatement\") {\n\t\t\t\t// no need to add additional scope\n\t\t\t\tthis.blockPrewalkStatements(body.body);\n\t\t\t\tthis.walkStatements(body.body);\n\t\t\t} else {\n\t\t\t\tthis.walkStatement(body);\n\t\t\t}\n\t\t});\n\t}\n\n\t// Declarations\n\tprewalkFunctionDeclaration(statement) {\n\t\tif (statement.id) {\n\t\t\tthis.scope.renames.set(statement.id.name, null);\n\t\t\tthis.scope.definitions.add(statement.id.name);\n\t\t}\n\t}\n\n\twalkFunctionDeclaration(statement) {\n\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\tthis.scope.topLevelScope = false;\n\t\tthis.inFunctionScope(true, statement.params, () => {\n\t\t\tfor (const param of statement.params) {\n\t\t\t\tthis.walkPattern(param);\n\t\t\t}\n\t\t\tif (statement.body.type === \"BlockStatement\") {\n\t\t\t\tthis.detectMode(statement.body.body);\n\t\t\t\tthis.prewalkStatement(statement.body);\n\t\t\t\tthis.walkStatement(statement.body);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(statement.body);\n\t\t\t}\n\t\t});\n\t\tthis.scope.topLevelScope = wasTopLevel;\n\t}\n\n\tprewalkImportDeclaration(statement) {\n\t\tconst source = statement.source.value;\n\t\tthis.hooks.import.call(statement, source);\n\t\tfor (const specifier of statement.specifiers) {\n\t\t\tconst name = specifier.local.name;\n\t\t\tthis.scope.renames.set(name, null);\n\t\t\tthis.scope.definitions.add(name);\n\t\t\tswitch (specifier.type) {\n\t\t\t\tcase \"ImportDefaultSpecifier\":\n\t\t\t\t\tthis.hooks.importSpecifier.call(statement, source, \"default\", name);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"ImportSpecifier\":\n\t\t\t\t\tthis.hooks.importSpecifier.call(\n\t\t\t\t\t\tstatement,\n\t\t\t\t\t\tsource,\n\t\t\t\t\t\tspecifier.imported.name,\n\t\t\t\t\t\tname\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"ImportNamespaceSpecifier\":\n\t\t\t\t\tthis.hooks.importSpecifier.call(statement, source, null, name);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tenterDeclaration(declaration, onIdent) {\n\t\tswitch (declaration.type) {\n\t\t\tcase \"VariableDeclaration\":\n\t\t\t\tfor (const declarator of declaration.declarations) {\n\t\t\t\t\tswitch (declarator.type) {\n\t\t\t\t\t\tcase \"VariableDeclarator\": {\n\t\t\t\t\t\t\tthis.enterPattern(declarator.id, onIdent);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionDeclaration\":\n\t\t\t\tthis.enterPattern(declaration.id, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"ClassDeclaration\":\n\t\t\t\tthis.enterPattern(declaration.id, onIdent);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tblockPrewalkExportNamedDeclaration(statement) {\n\t\tif (statement.declaration) {\n\t\t\tthis.blockPrewalkStatement(statement.declaration);\n\t\t}\n\t}\n\n\tprewalkExportNamedDeclaration(statement) {\n\t\tlet source;\n\t\tif (statement.source) {\n\t\t\tsource = statement.source.value;\n\t\t\tthis.hooks.exportImport.call(statement, source);\n\t\t} else {\n\t\t\tthis.hooks.export.call(statement);\n\t\t}\n\t\tif (statement.declaration) {\n\t\t\tif (\n\t\t\t\t!this.hooks.exportDeclaration.call(statement, statement.declaration)\n\t\t\t) {\n\t\t\t\tthis.prewalkStatement(statement.declaration);\n\t\t\t\tlet index = 0;\n\t\t\t\tthis.enterDeclaration(statement.declaration, def => {\n\t\t\t\t\tthis.hooks.exportSpecifier.call(statement, def, def, index++);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tif (statement.specifiers) {\n\t\t\tfor (\n\t\t\t\tlet specifierIndex = 0;\n\t\t\t\tspecifierIndex < statement.specifiers.length;\n\t\t\t\tspecifierIndex++\n\t\t\t) {\n\t\t\t\tconst specifier = statement.specifiers[specifierIndex];\n\t\t\t\tswitch (specifier.type) {\n\t\t\t\t\tcase \"ExportSpecifier\": {\n\t\t\t\t\t\tconst name = specifier.exported.name;\n\t\t\t\t\t\tif (source) {\n\t\t\t\t\t\t\tthis.hooks.exportImportSpecifier.call(\n\t\t\t\t\t\t\t\tstatement,\n\t\t\t\t\t\t\t\tsource,\n\t\t\t\t\t\t\t\tspecifier.local.name,\n\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\tspecifierIndex\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.hooks.exportSpecifier.call(\n\t\t\t\t\t\t\t\tstatement,\n\t\t\t\t\t\t\t\tspecifier.local.name,\n\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\tspecifierIndex\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twalkExportNamedDeclaration(statement) {\n\t\tif (statement.declaration) {\n\t\t\tthis.walkStatement(statement.declaration);\n\t\t}\n\t}\n\n\tblockPrewalkExportDefaultDeclaration(statement) {\n\t\tif (statement.declaration.type === \"ClassDeclaration\") {\n\t\t\tthis.blockPrewalkClassDeclaration(statement.declaration);\n\t\t}\n\t}\n\n\tprewalkExportDefaultDeclaration(statement) {\n\t\tthis.prewalkStatement(statement.declaration);\n\t\tif (\n\t\t\tstatement.declaration.id &&\n\t\t\tstatement.declaration.type !== \"FunctionExpression\" &&\n\t\t\tstatement.declaration.type !== \"ClassExpression\"\n\t\t) {\n\t\t\tthis.hooks.exportSpecifier.call(\n\t\t\t\tstatement,\n\t\t\t\tstatement.declaration.id.name,\n\t\t\t\t\"default\"\n\t\t\t);\n\t\t}\n\t}\n\n\twalkExportDefaultDeclaration(statement) {\n\t\tthis.hooks.export.call(statement);\n\t\tif (\n\t\t\tstatement.declaration.id &&\n\t\t\tstatement.declaration.type !== \"FunctionExpression\" &&\n\t\t\tstatement.declaration.type !== \"ClassExpression\"\n\t\t) {\n\t\t\tif (\n\t\t\t\t!this.hooks.exportDeclaration.call(statement, statement.declaration)\n\t\t\t) {\n\t\t\t\tthis.walkStatement(statement.declaration);\n\t\t\t}\n\t\t} else {\n\t\t\t// Acorn parses `export default function() {}` as `FunctionDeclaration` and\n\t\t\t// `export default class {}` as `ClassDeclaration`, both with `id = null`.\n\t\t\t// These nodes must be treated as expressions.\n\t\t\tif (statement.declaration.type === \"FunctionDeclaration\") {\n\t\t\t\tthis.walkFunctionDeclaration(statement.declaration);\n\t\t\t} else if (statement.declaration.type === \"ClassDeclaration\") {\n\t\t\t\tthis.walkClassDeclaration(statement.declaration);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(statement.declaration);\n\t\t\t}\n\t\t\tif (!this.hooks.exportExpression.call(statement, statement.declaration)) {\n\t\t\t\tthis.hooks.exportSpecifier.call(\n\t\t\t\t\tstatement,\n\t\t\t\t\tstatement.declaration,\n\t\t\t\t\t\"default\"\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n\n\tprewalkExportAllDeclaration(statement) {\n\t\tconst source = statement.source.value;\n\t\tthis.hooks.exportImport.call(statement, source);\n\t\tthis.hooks.exportImportSpecifier.call(statement, source, null, null, 0);\n\t}\n\n\tprewalkVariableDeclaration(statement) {\n\t\tif (statement.kind !== \"var\") return;\n\t\tthis._prewalkVariableDeclaration(statement, this.hooks.varDeclarationVar);\n\t}\n\n\tblockPrewalkVariableDeclaration(statement) {\n\t\tif (statement.kind === \"var\") return;\n\t\tconst hookMap =\n\t\t\tstatement.kind === \"const\"\n\t\t\t\t? this.hooks.varDeclarationConst\n\t\t\t\t: this.hooks.varDeclarationLet;\n\t\tthis._prewalkVariableDeclaration(statement, hookMap);\n\t}\n\n\t_prewalkVariableDeclaration(statement, hookMap) {\n\t\tfor (const declarator of statement.declarations) {\n\t\t\tswitch (declarator.type) {\n\t\t\t\tcase \"VariableDeclarator\": {\n\t\t\t\t\tthis.enterPattern(declarator.id, (name, decl) => {\n\t\t\t\t\t\tlet hook = hookMap.get(name);\n\t\t\t\t\t\tif (hook === undefined || !hook.call(decl)) {\n\t\t\t\t\t\t\thook = this.hooks.varDeclaration.get(name);\n\t\t\t\t\t\t\tif (hook === undefined || !hook.call(decl)) {\n\t\t\t\t\t\t\t\tthis.scope.renames.set(name, null);\n\t\t\t\t\t\t\t\tthis.scope.definitions.add(name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\twalkVariableDeclaration(statement) {\n\t\tfor (const declarator of statement.declarations) {\n\t\t\tswitch (declarator.type) {\n\t\t\t\tcase \"VariableDeclarator\": {\n\t\t\t\t\tconst renameIdentifier =\n\t\t\t\t\t\tdeclarator.init && this.getRenameIdentifier(declarator.init);\n\t\t\t\t\tif (renameIdentifier && declarator.id.type === \"Identifier\") {\n\t\t\t\t\t\tconst hook = this.hooks.canRename.get(renameIdentifier);\n\t\t\t\t\t\tif (hook !== undefined && hook.call(declarator.init)) {\n\t\t\t\t\t\t\t// renaming with \"var a = b;\"\n\t\t\t\t\t\t\tconst hook = this.hooks.rename.get(renameIdentifier);\n\t\t\t\t\t\t\tif (hook === undefined || !hook.call(declarator.init)) {\n\t\t\t\t\t\t\t\tthis.scope.renames.set(\n\t\t\t\t\t\t\t\t\tdeclarator.id.name,\n\t\t\t\t\t\t\t\t\tthis.scope.renames.get(renameIdentifier) || renameIdentifier\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\tthis.scope.definitions.delete(declarator.id.name);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.walkPattern(declarator.id);\n\t\t\t\t\tif (declarator.init) this.walkExpression(declarator.init);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tblockPrewalkClassDeclaration(statement) {\n\t\tif (statement.id) {\n\t\t\tthis.scope.renames.set(statement.id.name, null);\n\t\t\tthis.scope.definitions.add(statement.id.name);\n\t\t}\n\t}\n\n\twalkClassDeclaration(statement) {\n\t\tthis.walkClass(statement);\n\t}\n\n\tprewalkSwitchCases(switchCases) {\n\t\tfor (let index = 0, len = switchCases.length; index < len; index++) {\n\t\t\tconst switchCase = switchCases[index];\n\t\t\tthis.prewalkStatements(switchCase.consequent);\n\t\t}\n\t}\n\n\twalkSwitchCases(switchCases) {\n\t\tfor (let index = 0, len = switchCases.length; index < len; index++) {\n\t\t\tconst switchCase = switchCases[index];\n\n\t\t\tif (switchCase.test) {\n\t\t\t\tthis.walkExpression(switchCase.test);\n\t\t\t}\n\t\t\tthis.walkStatements(switchCase.consequent);\n\t\t}\n\t}\n\n\twalkCatchClause(catchClause) {\n\t\tthis.inBlockScope(() => {\n\t\t\t// Error binding is optional in catch clause since ECMAScript 2019\n\t\t\tif (catchClause.param !== null) {\n\t\t\t\tthis.enterPattern(catchClause.param, ident => {\n\t\t\t\t\tthis.scope.renames.set(ident, null);\n\t\t\t\t\tthis.scope.definitions.add(ident);\n\t\t\t\t});\n\t\t\t\tthis.walkPattern(catchClause.param);\n\t\t\t}\n\t\t\tthis.prewalkStatement(catchClause.body);\n\t\t\tthis.walkStatement(catchClause.body);\n\t\t});\n\t}\n\n\twalkPattern(pattern) {\n\t\tswitch (pattern.type) {\n\t\t\tcase \"ArrayPattern\":\n\t\t\t\tthis.walkArrayPattern(pattern);\n\t\t\t\tbreak;\n\t\t\tcase \"AssignmentPattern\":\n\t\t\t\tthis.walkAssignmentPattern(pattern);\n\t\t\t\tbreak;\n\t\t\tcase \"MemberExpression\":\n\t\t\t\tthis.walkMemberExpression(pattern);\n\t\t\t\tbreak;\n\t\t\tcase \"ObjectPattern\":\n\t\t\t\tthis.walkObjectPattern(pattern);\n\t\t\t\tbreak;\n\t\t\tcase \"RestElement\":\n\t\t\t\tthis.walkRestElement(pattern);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\twalkAssignmentPattern(pattern) {\n\t\tthis.walkExpression(pattern.right);\n\t\tthis.walkPattern(pattern.left);\n\t}\n\n\twalkObjectPattern(pattern) {\n\t\tfor (let i = 0, len = pattern.properties.length; i < len; i++) {\n\t\t\tconst prop = pattern.properties[i];\n\t\t\tif (prop) {\n\t\t\t\tif (prop.computed) this.walkExpression(prop.key);\n\t\t\t\tif (prop.value) this.walkPattern(prop.value);\n\t\t\t}\n\t\t}\n\t}\n\n\twalkArrayPattern(pattern) {\n\t\tfor (let i = 0, len = pattern.elements.length; i < len; i++) {\n\t\t\tconst element = pattern.elements[i];\n\t\t\tif (element) this.walkPattern(element);\n\t\t}\n\t}\n\n\twalkRestElement(pattern) {\n\t\tthis.walkPattern(pattern.argument);\n\t}\n\n\twalkExpressions(expressions) {\n\t\tfor (const expression of expressions) {\n\t\t\tif (expression) {\n\t\t\t\tthis.walkExpression(expression);\n\t\t\t}\n\t\t}\n\t}\n\n\twalkExpression(expression) {\n\t\tswitch (expression.type) {\n\t\t\tcase \"ArrayExpression\":\n\t\t\t\tthis.walkArrayExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ArrowFunctionExpression\":\n\t\t\t\tthis.walkArrowFunctionExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"AssignmentExpression\":\n\t\t\t\tthis.walkAssignmentExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"AwaitExpression\":\n\t\t\t\tthis.walkAwaitExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"BinaryExpression\":\n\t\t\t\tthis.walkBinaryExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"CallExpression\":\n\t\t\t\tthis.walkCallExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ClassExpression\":\n\t\t\t\tthis.walkClassExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ConditionalExpression\":\n\t\t\t\tthis.walkConditionalExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"FunctionExpression\":\n\t\t\t\tthis.walkFunctionExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"Identifier\":\n\t\t\t\tthis.walkIdentifier(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"LogicalExpression\":\n\t\t\t\tthis.walkLogicalExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"MemberExpression\":\n\t\t\t\tthis.walkMemberExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"NewExpression\":\n\t\t\t\tthis.walkNewExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ObjectExpression\":\n\t\t\t\tthis.walkObjectExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"SequenceExpression\":\n\t\t\t\tthis.walkSequenceExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"SpreadElement\":\n\t\t\t\tthis.walkSpreadElement(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"TaggedTemplateExpression\":\n\t\t\t\tthis.walkTaggedTemplateExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"TemplateLiteral\":\n\t\t\t\tthis.walkTemplateLiteral(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"ThisExpression\":\n\t\t\t\tthis.walkThisExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"UnaryExpression\":\n\t\t\t\tthis.walkUnaryExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"UpdateExpression\":\n\t\t\t\tthis.walkUpdateExpression(expression);\n\t\t\t\tbreak;\n\t\t\tcase \"YieldExpression\":\n\t\t\t\tthis.walkYieldExpression(expression);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\twalkAwaitExpression(expression) {\n\t\tthis.walkExpression(expression.argument);\n\t}\n\n\twalkArrayExpression(expression) {\n\t\tif (expression.elements) {\n\t\t\tthis.walkExpressions(expression.elements);\n\t\t}\n\t}\n\n\twalkSpreadElement(expression) {\n\t\tif (expression.argument) {\n\t\t\tthis.walkExpression(expression.argument);\n\t\t}\n\t}\n\n\twalkObjectExpression(expression) {\n\t\tfor (\n\t\t\tlet propIndex = 0, len = expression.properties.length;\n\t\t\tpropIndex < len;\n\t\t\tpropIndex++\n\t\t) {\n\t\t\tconst prop = expression.properties[propIndex];\n\t\t\tif (prop.type === \"SpreadElement\") {\n\t\t\t\tthis.walkExpression(prop.argument);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (prop.computed) {\n\t\t\t\tthis.walkExpression(prop.key);\n\t\t\t}\n\t\t\tif (prop.shorthand) {\n\t\t\t\tthis.scope.inShorthand = true;\n\t\t\t}\n\t\t\tthis.walkExpression(prop.value);\n\t\t\tif (prop.shorthand) {\n\t\t\t\tthis.scope.inShorthand = false;\n\t\t\t}\n\t\t}\n\t}\n\n\twalkFunctionExpression(expression) {\n\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\tthis.scope.topLevelScope = false;\n\t\tconst scopeParams = expression.params;\n\n\t\t// Add function name in scope for recursive calls\n\t\tif (expression.id) {\n\t\t\tscopeParams.push(expression.id.name);\n\t\t}\n\n\t\tthis.inFunctionScope(true, scopeParams, () => {\n\t\t\tfor (const param of expression.params) {\n\t\t\t\tthis.walkPattern(param);\n\t\t\t}\n\t\t\tif (expression.body.type === \"BlockStatement\") {\n\t\t\t\tthis.detectMode(expression.body.body);\n\t\t\t\tthis.prewalkStatement(expression.body);\n\t\t\t\tthis.walkStatement(expression.body);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(expression.body);\n\t\t\t}\n\t\t});\n\t\tthis.scope.topLevelScope = wasTopLevel;\n\t}\n\n\twalkArrowFunctionExpression(expression) {\n\t\tthis.inFunctionScope(false, expression.params, () => {\n\t\t\tfor (const param of expression.params) {\n\t\t\t\tthis.walkPattern(param);\n\t\t\t}\n\t\t\tif (expression.body.type === \"BlockStatement\") {\n\t\t\t\tthis.detectMode(expression.body.body);\n\t\t\t\tthis.prewalkStatement(expression.body);\n\t\t\t\tthis.walkStatement(expression.body);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(expression.body);\n\t\t\t}\n\t\t});\n\t}\n\n\twalkSequenceExpression(expression) {\n\t\tif (expression.expressions) this.walkExpressions(expression.expressions);\n\t}\n\n\twalkUpdateExpression(expression) {\n\t\tthis.walkExpression(expression.argument);\n\t}\n\n\twalkUnaryExpression(expression) {\n\t\tif (expression.operator === \"typeof\") {\n\t\t\tconst exprName = this.getNameForExpression(expression.argument);\n\t\t\tif (exprName && exprName.free) {\n\t\t\t\tconst hook = this.hooks.typeof.get(exprName.name);\n\t\t\t\tif (hook !== undefined) {\n\t\t\t\t\tconst result = hook.call(expression);\n\t\t\t\t\tif (result === true) return;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.walkExpression(expression.argument);\n\t}\n\n\twalkLeftRightExpression(expression) {\n\t\tthis.walkExpression(expression.left);\n\t\tthis.walkExpression(expression.right);\n\t}\n\n\twalkBinaryExpression(expression) {\n\t\tthis.walkLeftRightExpression(expression);\n\t}\n\n\twalkLogicalExpression(expression) {\n\t\tconst result = this.hooks.expressionLogicalOperator.call(expression);\n\t\tif (result === undefined) {\n\t\t\tthis.walkLeftRightExpression(expression);\n\t\t} else {\n\t\t\tif (result) {\n\t\t\t\tthis.walkExpression(expression.right);\n\t\t\t}\n\t\t}\n\t}\n\n\twalkAssignmentExpression(expression) {\n\t\tconst renameIdentifier = this.getRenameIdentifier(expression.right);\n\t\tif (expression.left.type === \"Identifier\" && renameIdentifier) {\n\t\t\tconst hook = this.hooks.canRename.get(renameIdentifier);\n\t\t\tif (hook !== undefined && hook.call(expression.right)) {\n\t\t\t\t// renaming \"a = b;\"\n\t\t\t\tconst hook = this.hooks.rename.get(renameIdentifier);\n\t\t\t\tif (hook === undefined || !hook.call(expression.right)) {\n\t\t\t\t\tthis.scope.renames.set(expression.left.name, renameIdentifier);\n\t\t\t\t\tthis.scope.definitions.delete(expression.left.name);\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (expression.left.type === \"Identifier\") {\n\t\t\tconst assignedHook = this.hooks.assigned.get(expression.left.name);\n\t\t\tif (assignedHook === undefined || !assignedHook.call(expression)) {\n\t\t\t\tthis.walkExpression(expression.right);\n\t\t\t}\n\t\t\tthis.scope.renames.set(expression.left.name, null);\n\t\t\tconst assignHook = this.hooks.assign.get(expression.left.name);\n\t\t\tif (assignHook === undefined || !assignHook.call(expression)) {\n\t\t\t\tthis.walkExpression(expression.left);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tthis.walkExpression(expression.right);\n\t\tthis.walkPattern(expression.left);\n\t\tthis.enterPattern(expression.left, (name, decl) => {\n\t\t\tthis.scope.renames.set(name, null);\n\t\t});\n\t}\n\n\twalkConditionalExpression(expression) {\n\t\tconst result = this.hooks.expressionConditionalOperator.call(expression);\n\t\tif (result === undefined) {\n\t\t\tthis.walkExpression(expression.test);\n\t\t\tthis.walkExpression(expression.consequent);\n\t\t\tif (expression.alternate) {\n\t\t\t\tthis.walkExpression(expression.alternate);\n\t\t\t}\n\t\t} else {\n\t\t\tif (result) {\n\t\t\t\tthis.walkExpression(expression.consequent);\n\t\t\t} else if (expression.alternate) {\n\t\t\t\tthis.walkExpression(expression.alternate);\n\t\t\t}\n\t\t}\n\t}\n\n\twalkNewExpression(expression) {\n\t\tconst callee = this.evaluateExpression(expression.callee);\n\t\tif (callee.isIdentifier()) {\n\t\t\tconst hook = this.hooks.new.get(callee.identifier);\n\t\t\tif (hook !== undefined) {\n\t\t\t\tconst result = hook.call(expression);\n\t\t\t\tif (result === true) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.walkExpression(expression.callee);\n\t\tif (expression.arguments) {\n\t\t\tthis.walkExpressions(expression.arguments);\n\t\t}\n\t}\n\n\twalkYieldExpression(expression) {\n\t\tif (expression.argument) {\n\t\t\tthis.walkExpression(expression.argument);\n\t\t}\n\t}\n\n\twalkTemplateLiteral(expression) {\n\t\tif (expression.expressions) {\n\t\t\tthis.walkExpressions(expression.expressions);\n\t\t}\n\t}\n\n\twalkTaggedTemplateExpression(expression) {\n\t\tif (expression.tag) {\n\t\t\tthis.walkExpression(expression.tag);\n\t\t}\n\t\tif (expression.quasi && expression.quasi.expressions) {\n\t\t\tthis.walkExpressions(expression.quasi.expressions);\n\t\t}\n\t}\n\n\twalkClassExpression(expression) {\n\t\tthis.walkClass(expression);\n\t}\n\n\t_walkIIFE(functionExpression, options, currentThis) {\n\t\tconst renameArgOrThis = argOrThis => {\n\t\t\tconst renameIdentifier = this.getRenameIdentifier(argOrThis);\n\t\t\tif (renameIdentifier) {\n\t\t\t\tconst hook = this.hooks.canRename.get(renameIdentifier);\n\t\t\t\tif (hook !== undefined && hook.call(argOrThis)) {\n\t\t\t\t\tconst hook = this.hooks.rename.get(renameIdentifier);\n\t\t\t\t\tif (hook === undefined || !hook.call(argOrThis)) {\n\t\t\t\t\t\treturn renameIdentifier;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.walkExpression(argOrThis);\n\t\t};\n\t\tconst params = functionExpression.params;\n\t\tconst renameThis = currentThis ? renameArgOrThis(currentThis) : null;\n\t\tconst args = options.map(renameArgOrThis);\n\t\tconst wasTopLevel = this.scope.topLevelScope;\n\t\tthis.scope.topLevelScope = false;\n\t\tconst scopeParams = params.filter((identifier, idx) => !args[idx]);\n\n\t\t// Add function name in scope for recursive calls\n\t\tif (functionExpression.id) {\n\t\t\tscopeParams.push(functionExpression.id.name);\n\t\t}\n\n\t\tthis.inFunctionScope(true, scopeParams, () => {\n\t\t\tif (renameThis) {\n\t\t\t\tthis.scope.renames.set(\"this\", renameThis);\n\t\t\t}\n\t\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\t\tconst param = args[i];\n\t\t\t\tif (!param) continue;\n\t\t\t\tif (!params[i] || params[i].type !== \"Identifier\") continue;\n\t\t\t\tthis.scope.renames.set(params[i].name, param);\n\t\t\t}\n\t\t\tif (functionExpression.body.type === \"BlockStatement\") {\n\t\t\t\tthis.detectMode(functionExpression.body.body);\n\t\t\t\tthis.prewalkStatement(functionExpression.body);\n\t\t\t\tthis.walkStatement(functionExpression.body);\n\t\t\t} else {\n\t\t\t\tthis.walkExpression(functionExpression.body);\n\t\t\t}\n\t\t});\n\t\tthis.scope.topLevelScope = wasTopLevel;\n\t}\n\n\twalkCallExpression(expression) {\n\t\tif (\n\t\t\texpression.callee.type === \"MemberExpression\" &&\n\t\t\texpression.callee.object.type === \"FunctionExpression\" &&\n\t\t\t!expression.callee.computed &&\n\t\t\t(expression.callee.property.name === \"call\" ||\n\t\t\t\texpression.callee.property.name === \"bind\") &&\n\t\t\texpression.arguments.length > 0\n\t\t) {\n\t\t\t// (function(…) { }.call/bind(?, …))\n\t\t\tthis._walkIIFE(\n\t\t\t\texpression.callee.object,\n\t\t\t\texpression.arguments.slice(1),\n\t\t\t\texpression.arguments[0]\n\t\t\t);\n\t\t} else if (expression.callee.type === \"FunctionExpression\") {\n\t\t\t// (function(…) { }(…))\n\t\t\tthis._walkIIFE(expression.callee, expression.arguments, null);\n\t\t} else if (expression.callee.type === \"Import\") {\n\t\t\tlet result = this.hooks.importCall.call(expression);\n\t\t\tif (result === true) return;\n\n\t\t\tif (expression.arguments) this.walkExpressions(expression.arguments);\n\t\t} else {\n\t\t\tconst callee = this.evaluateExpression(expression.callee);\n\t\t\tif (callee.isIdentifier()) {\n\t\t\t\tconst callHook = this.hooks.call.get(callee.identifier);\n\t\t\t\tif (callHook !== undefined) {\n\t\t\t\t\tlet result = callHook.call(expression);\n\t\t\t\t\tif (result === true) return;\n\t\t\t\t}\n\t\t\t\tlet identifier = callee.identifier.replace(/\\.[^.]+$/, \"\");\n\t\t\t\tif (identifier !== callee.identifier) {\n\t\t\t\t\tconst callAnyHook = this.hooks.callAnyMember.get(identifier);\n\t\t\t\t\tif (callAnyHook !== undefined) {\n\t\t\t\t\t\tlet result = callAnyHook.call(expression);\n\t\t\t\t\t\tif (result === true) return;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (expression.callee) this.walkExpression(expression.callee);\n\t\t\tif (expression.arguments) this.walkExpressions(expression.arguments);\n\t\t}\n\t}\n\n\twalkMemberExpression(expression) {\n\t\tconst exprName = this.getNameForExpression(expression);\n\t\tif (exprName && exprName.free) {\n\t\t\tconst expressionHook = this.hooks.expression.get(exprName.name);\n\t\t\tif (expressionHook !== undefined) {\n\t\t\t\tconst result = expressionHook.call(expression);\n\t\t\t\tif (result === true) return;\n\t\t\t}\n\t\t\tconst expressionAnyMemberHook = this.hooks.expressionAnyMember.get(\n\t\t\t\texprName.nameGeneral\n\t\t\t);\n\t\t\tif (expressionAnyMemberHook !== undefined) {\n\t\t\t\tconst result = expressionAnyMemberHook.call(expression);\n\t\t\t\tif (result === true) return;\n\t\t\t}\n\t\t}\n\t\tthis.walkExpression(expression.object);\n\t\tif (expression.computed === true) this.walkExpression(expression.property);\n\t}\n\n\twalkThisExpression(expression) {\n\t\tconst expressionHook = this.hooks.expression.get(\"this\");\n\t\tif (expressionHook !== undefined) {\n\t\t\texpressionHook.call(expression);\n\t\t}\n\t}\n\n\twalkIdentifier(expression) {\n\t\tif (!this.scope.definitions.has(expression.name)) {\n\t\t\tconst hook = this.hooks.expression.get(\n\t\t\t\tthis.scope.renames.get(expression.name) || expression.name\n\t\t\t);\n\t\t\tif (hook !== undefined) {\n\t\t\t\tconst result = hook.call(expression);\n\t\t\t\tif (result === true) return;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @deprecated\n\t * @param {any} params scope params\n\t * @param {function(): void} fn inner function\n\t * @returns {void}\n\t */\n\tinScope(params, fn) {\n\t\tconst oldScope = this.scope;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: oldScope.topLevelScope,\n\t\t\tinTry: false,\n\t\t\tinShorthand: false,\n\t\t\tisStrict: oldScope.isStrict,\n\t\t\tisAsmJs: oldScope.isAsmJs,\n\t\t\tdefinitions: oldScope.definitions.createChild(),\n\t\t\trenames: oldScope.renames.createChild()\n\t\t};\n\n\t\tthis.scope.renames.set(\"this\", null);\n\n\t\tthis.enterPatterns(params, ident => {\n\t\t\tthis.scope.renames.set(ident, null);\n\t\t\tthis.scope.definitions.add(ident);\n\t\t});\n\n\t\tfn();\n\n\t\tthis.scope = oldScope;\n\t}\n\n\tinFunctionScope(hasThis, params, fn) {\n\t\tconst oldScope = this.scope;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: oldScope.topLevelScope,\n\t\t\tinTry: false,\n\t\t\tinShorthand: false,\n\t\t\tisStrict: oldScope.isStrict,\n\t\t\tisAsmJs: oldScope.isAsmJs,\n\t\t\tdefinitions: oldScope.definitions.createChild(),\n\t\t\trenames: oldScope.renames.createChild()\n\t\t};\n\n\t\tif (hasThis) {\n\t\t\tthis.scope.renames.set(\"this\", null);\n\t\t}\n\n\t\tthis.enterPatterns(params, ident => {\n\t\t\tthis.scope.renames.set(ident, null);\n\t\t\tthis.scope.definitions.add(ident);\n\t\t});\n\n\t\tfn();\n\n\t\tthis.scope = oldScope;\n\t}\n\n\tinBlockScope(fn) {\n\t\tconst oldScope = this.scope;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: oldScope.topLevelScope,\n\t\t\tinTry: oldScope.inTry,\n\t\t\tinShorthand: false,\n\t\t\tisStrict: oldScope.isStrict,\n\t\t\tisAsmJs: oldScope.isAsmJs,\n\t\t\tdefinitions: oldScope.definitions.createChild(),\n\t\t\trenames: oldScope.renames.createChild()\n\t\t};\n\n\t\tfn();\n\n\t\tthis.scope = oldScope;\n\t}\n\n\t// TODO webpack 5: remove this methods\n\t// only for backward-compat\n\tdetectStrictMode(statements) {\n\t\tthis.detectMode(statements);\n\t}\n\n\tdetectMode(statements) {\n\t\tconst isLiteral =\n\t\t\tstatements.length >= 1 &&\n\t\t\tstatements[0].type === \"ExpressionStatement\" &&\n\t\t\tstatements[0].expression.type === \"Literal\";\n\t\tif (isLiteral && statements[0].expression.value === \"use strict\") {\n\t\t\tthis.scope.isStrict = true;\n\t\t}\n\t\tif (isLiteral && statements[0].expression.value === \"use asm\") {\n\t\t\tthis.scope.isAsmJs = true;\n\t\t}\n\t}\n\n\tenterPatterns(patterns, onIdent) {\n\t\tfor (const pattern of patterns) {\n\t\t\tif (typeof pattern !== \"string\") {\n\t\t\t\tthis.enterPattern(pattern, onIdent);\n\t\t\t} else if (pattern) {\n\t\t\t\tonIdent(pattern);\n\t\t\t}\n\t\t}\n\t}\n\n\tenterPattern(pattern, onIdent) {\n\t\tif (!pattern) return;\n\t\tswitch (pattern.type) {\n\t\t\tcase \"ArrayPattern\":\n\t\t\t\tthis.enterArrayPattern(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"AssignmentPattern\":\n\t\t\t\tthis.enterAssignmentPattern(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"Identifier\":\n\t\t\t\tthis.enterIdentifier(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"ObjectPattern\":\n\t\t\t\tthis.enterObjectPattern(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"RestElement\":\n\t\t\t\tthis.enterRestElement(pattern, onIdent);\n\t\t\t\tbreak;\n\t\t\tcase \"Property\":\n\t\t\t\tthis.enterPattern(pattern.value, onIdent);\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tenterIdentifier(pattern, onIdent) {\n\t\tonIdent(pattern.name, pattern);\n\t}\n\n\tenterObjectPattern(pattern, onIdent) {\n\t\tfor (\n\t\t\tlet propIndex = 0, len = pattern.properties.length;\n\t\t\tpropIndex < len;\n\t\t\tpropIndex++\n\t\t) {\n\t\t\tconst prop = pattern.properties[propIndex];\n\t\t\tthis.enterPattern(prop, onIdent);\n\t\t}\n\t}\n\n\tenterArrayPattern(pattern, onIdent) {\n\t\tfor (\n\t\t\tlet elementIndex = 0, len = pattern.elements.length;\n\t\t\telementIndex < len;\n\t\t\telementIndex++\n\t\t) {\n\t\t\tconst element = pattern.elements[elementIndex];\n\t\t\tthis.enterPattern(element, onIdent);\n\t\t}\n\t}\n\n\tenterRestElement(pattern, onIdent) {\n\t\tthis.enterPattern(pattern.argument, onIdent);\n\t}\n\n\tenterAssignmentPattern(pattern, onIdent) {\n\t\tthis.enterPattern(pattern.left, onIdent);\n\t}\n\n\tevaluateExpression(expression) {\n\t\ttry {\n\t\t\tconst hook = this.hooks.evaluate.get(expression.type);\n\t\t\tif (hook !== undefined) {\n\t\t\t\tconst result = hook.call(expression);\n\t\t\t\tif (result !== undefined) {\n\t\t\t\t\tif (result) {\n\t\t\t\t\t\tresult.setExpression(expression);\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.warn(e);\n\t\t\t// ignore error\n\t\t}\n\t\treturn new BasicEvaluatedExpression()\n\t\t\t.setRange(expression.range)\n\t\t\t.setExpression(expression);\n\t}\n\n\tparseString(expression) {\n\t\tswitch (expression.type) {\n\t\t\tcase \"BinaryExpression\":\n\t\t\t\tif (expression.operator === \"+\") {\n\t\t\t\t\treturn (\n\t\t\t\t\t\tthis.parseString(expression.left) +\n\t\t\t\t\t\tthis.parseString(expression.right)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"Literal\":\n\t\t\t\treturn expression.value + \"\";\n\t\t}\n\t\tthrow new Error(\n\t\t\texpression.type + \" is not supported as parameter for require\"\n\t\t);\n\t}\n\n\tparseCalculatedString(expression) {\n\t\tswitch (expression.type) {\n\t\t\tcase \"BinaryExpression\":\n\t\t\t\tif (expression.operator === \"+\") {\n\t\t\t\t\tconst left = this.parseCalculatedString(expression.left);\n\t\t\t\t\tconst right = this.parseCalculatedString(expression.right);\n\t\t\t\t\tif (left.code) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\trange: left.range,\n\t\t\t\t\t\t\tvalue: left.value,\n\t\t\t\t\t\t\tcode: true,\n\t\t\t\t\t\t\tconditional: false\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if (right.code) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\trange: [\n\t\t\t\t\t\t\t\tleft.range[0],\n\t\t\t\t\t\t\t\tright.range ? right.range[1] : left.range[1]\n\t\t\t\t\t\t\t],\n\t\t\t\t\t\t\tvalue: left.value + right.value,\n\t\t\t\t\t\t\tcode: true,\n\t\t\t\t\t\t\tconditional: false\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\trange: [left.range[0], right.range[1]],\n\t\t\t\t\t\t\tvalue: left.value + right.value,\n\t\t\t\t\t\t\tcode: false,\n\t\t\t\t\t\t\tconditional: false\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase \"ConditionalExpression\": {\n\t\t\t\tconst consequent = this.parseCalculatedString(expression.consequent);\n\t\t\t\tconst alternate = this.parseCalculatedString(expression.alternate);\n\t\t\t\tconst items = [];\n\t\t\t\tif (consequent.conditional) {\n\t\t\t\t\titems.push(...consequent.conditional);\n\t\t\t\t} else if (!consequent.code) {\n\t\t\t\t\titems.push(consequent);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (alternate.conditional) {\n\t\t\t\t\titems.push(...alternate.conditional);\n\t\t\t\t} else if (!alternate.code) {\n\t\t\t\t\titems.push(alternate);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\trange: undefined,\n\t\t\t\t\tvalue: \"\",\n\t\t\t\t\tcode: true,\n\t\t\t\t\tconditional: items\n\t\t\t\t};\n\t\t\t}\n\t\t\tcase \"Literal\":\n\t\t\t\treturn {\n\t\t\t\t\trange: expression.range,\n\t\t\t\t\tvalue: expression.value + \"\",\n\t\t\t\t\tcode: false,\n\t\t\t\t\tconditional: false\n\t\t\t\t};\n\t\t}\n\t\treturn {\n\t\t\trange: undefined,\n\t\t\tvalue: \"\",\n\t\t\tcode: true,\n\t\t\tconditional: false\n\t\t};\n\t}\n\n\tparse(source, initialState) {\n\t\tlet ast;\n\t\tlet comments;\n\t\tif (typeof source === \"object\" && source !== null) {\n\t\t\tast = source;\n\t\t\tcomments = source.comments;\n\t\t} else {\n\t\t\tcomments = [];\n\t\t\tast = Parser.parse(source, {\n\t\t\t\tsourceType: this.sourceType,\n\t\t\t\tonComment: comments\n\t\t\t});\n\t\t}\n\n\t\tconst oldScope = this.scope;\n\t\tconst oldState = this.state;\n\t\tconst oldComments = this.comments;\n\t\tthis.scope = {\n\t\t\ttopLevelScope: true,\n\t\t\tinTry: false,\n\t\t\tinShorthand: false,\n\t\t\tisStrict: false,\n\t\t\tisAsmJs: false,\n\t\t\tdefinitions: new StackedSetMap(),\n\t\t\trenames: new StackedSetMap()\n\t\t};\n\t\tconst state = (this.state = initialState || {});\n\t\tthis.comments = comments;\n\t\tif (this.hooks.program.call(ast, comments) === undefined) {\n\t\t\tthis.detectMode(ast.body);\n\t\t\tthis.prewalkStatements(ast.body);\n\t\t\tthis.blockPrewalkStatements(ast.body);\n\t\t\tthis.walkStatements(ast.body);\n\t\t}\n\t\tthis.scope = oldScope;\n\t\tthis.state = oldState;\n\t\tthis.comments = oldComments;\n\t\treturn state;\n\t}\n\n\tevaluate(source) {\n\t\tconst ast = Parser.parse(\"(\" + source + \")\", {\n\t\t\tsourceType: this.sourceType,\n\t\t\tlocations: false\n\t\t});\n\t\t// TODO(https://github.com/acornjs/acorn/issues/741)\n\t\t// @ts-ignore\n\t\tif (ast.body.length !== 1 || ast.body[0].type !== \"ExpressionStatement\") {\n\t\t\tthrow new Error(\"evaluate: Source is not a expression\");\n\t\t}\n\t\t// TODO(https://github.com/acornjs/acorn/issues/741)\n\t\t// @ts-ignore\n\t\treturn this.evaluateExpression(ast.body[0].expression);\n\t}\n\n\tgetComments(range) {\n\t\treturn this.comments.filter(\n\t\t\tcomment => comment.range[0] >= range[0] && comment.range[1] <= range[1]\n\t\t);\n\t}\n\n\tparseCommentOptions(range) {\n\t\tconst comments = this.getComments(range);\n\t\tif (comments.length === 0) {\n\t\t\treturn EMPTY_COMMENT_OPTIONS;\n\t\t}\n\t\tlet options = {};\n\t\tlet errors = [];\n\t\tfor (const comment of comments) {\n\t\t\tconst { value } = comment;\n\t\t\tif (value && webpackCommentRegExp.test(value)) {\n\t\t\t\t// try compile only if webpack options comment is present\n\t\t\t\ttry {\n\t\t\t\t\tconst val = vm.runInNewContext(`(function(){return {${value}};})()`);\n\t\t\t\t\tObject.assign(options, val);\n\t\t\t\t} catch (e) {\n\t\t\t\t\te.comment = comment;\n\t\t\t\t\terrors.push(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn { options, errors };\n\t}\n\n\tgetNameForExpression(expression) {\n\t\tlet expr = expression;\n\t\tconst exprName = [];\n\t\twhile (\n\t\t\texpr.type === \"MemberExpression\" &&\n\t\t\texpr.property.type === (expr.computed ? \"Literal\" : \"Identifier\")\n\t\t) {\n\t\t\texprName.push(expr.computed ? expr.property.value : expr.property.name);\n\t\t\texpr = expr.object;\n\t\t}\n\t\tlet free;\n\t\tif (expr.type === \"Identifier\") {\n\t\t\tfree = !this.scope.definitions.has(expr.name);\n\t\t\texprName.push(this.scope.renames.get(expr.name) || expr.name);\n\t\t} else if (\n\t\t\texpr.type === \"ThisExpression\" &&\n\t\t\tthis.scope.renames.get(\"this\")\n\t\t) {\n\t\t\tfree = true;\n\t\t\texprName.push(this.scope.renames.get(\"this\"));\n\t\t} else if (expr.type === \"ThisExpression\") {\n\t\t\tfree = this.scope.topLevelScope;\n\t\t\texprName.push(\"this\");\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t\tlet prefix = \"\";\n\t\tfor (let i = exprName.length - 1; i >= 2; i--) {\n\t\t\tprefix += exprName[i] + \".\";\n\t\t}\n\t\tif (exprName.length > 1) {\n\t\t\tprefix += exprName[1];\n\t\t}\n\t\tconst name = prefix ? prefix + \".\" + exprName[0] : exprName[0];\n\t\tconst nameGeneral = prefix;\n\t\treturn {\n\t\t\tname,\n\t\t\tnameGeneral,\n\t\t\tfree\n\t\t};\n\t}\n\n\tstatic parse(code, options) {\n\t\tconst type = options ? options.sourceType : \"module\";\n\t\tconst parserOptions = Object.assign(\n\t\t\tObject.create(null),\n\t\t\tdefaultParserOptions,\n\t\t\toptions\n\t\t);\n\n\t\tif (type === \"auto\") {\n\t\t\tparserOptions.sourceType = \"module\";\n\t\t} else if (parserOptions.sourceType === \"script\") {\n\t\t\tparserOptions.allowReturnOutsideFunction = true;\n\t\t}\n\n\t\tlet ast;\n\t\tlet error;\n\t\tlet threw = false;\n\t\ttry {\n\t\t\tast = acornParser.parse(code, parserOptions);\n\t\t} catch (e) {\n\t\t\terror = e;\n\t\t\tthrew = true;\n\t\t}\n\n\t\tif (threw && type === \"auto\") {\n\t\t\tparserOptions.sourceType = \"script\";\n\t\t\tparserOptions.allowReturnOutsideFunction = true;\n\t\t\tif (Array.isArray(parserOptions.onComment)) {\n\t\t\t\tparserOptions.onComment.length = 0;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tast = acornParser.parse(code, parserOptions);\n\t\t\t\tthrew = false;\n\t\t\t} catch (e) {\n\t\t\t\tthrew = true;\n\t\t\t}\n\t\t}\n\n\t\tif (threw) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn ast;\n\t}\n}\n\n// TODO remove in webpack 5\nObject.defineProperty(Parser.prototype, \"getCommentOptions\", {\n\tconfigurable: false,\n\tvalue: util.deprecate(\n\t\t/**\n\t\t * @deprecated\n\t\t * @param {TODO} range Range\n\t\t * @returns {void}\n\t\t * @this {Parser}\n\t\t */\n\t\tfunction(range) {\n\t\t\treturn this.parseCommentOptions(range).options;\n\t\t},\n\t\t\"Parser.getCommentOptions: Use Parser.parseCommentOptions(range) instead\"\n\t)\n});\n\nmodule.exports = Parser;\n"]},"metadata":{},"sourceType":"script"}